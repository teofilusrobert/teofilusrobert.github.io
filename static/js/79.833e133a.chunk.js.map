{"version":3,"file":"static/js/79.833e133a.chunk.js","mappings":"mJACO,MAAMA,EAAkB,CAC3BC,KAAM,oBACNC,OAAQ,CACJC,OAAkB,kQAUlBC,KAAgB,sHAIhBC,IAAe,gMAWVC,EAAwB,IAC9BN,EACHE,OAAQ,IACDF,EAAgBE,OAEnBC,OAAQH,EAAgBE,OAAOC,OAAOI,QAAQ,WAAY,cAKrDC,EAAoB,CAC7BP,KAAM,oBACNC,OAAQ,CACJC,OAAkB,gIAMlBC,KAAgB,yFAIhBC,IAAe,sJ,6JCnDhB,MAAMI,EAAY,CACrBR,KAAM,aACNC,OAAQ,CACJC,OAAkB,geAalBC,KAAgB,6LAOpBM,SAAU,CACNP,OAAkB,geAalBC,KAAgB,ihBAqBXO,EAAc,CACvBV,KAAM,aACNC,OAAQ,CACJC,OAAkB,mGAKlBC,KAAgB,iJAOpBM,SAAU,CACNP,OAAkB,0KAMlBC,KAAgB,uVClExB,IAAIQ,EACAC,EAMG,MAAMC,UAA2BC,EAAAA,EAEpCC,WAAAA,GAEIJ,IAAAA,GAAeK,EAAAA,EAAAA,GAA4B,CACvChB,KAAM,uBACNiB,KAAM,CACFlB,EAAAA,GACAS,EACAU,EAAAA,MAIRN,IAAAA,GAAcO,EAAAA,EAAAA,GAA2B,CACrCnB,KAAM,uBACNiB,KAAM,CACFV,EAAAA,GACAG,EACAU,EAAAA,MAIF,MAAAC,EAAiB,IAAIC,EAAAA,EAAa,CACpCC,UAAW,CAAEC,MAAO,IAAIC,EAAAA,EAAUC,KAAM,eACxCC,YAAa,CAAEH,MAAO,IAAII,aAAa,CAAC,EAAG,EAAG,EAAG,IAAKF,KAAM,aAC5DG,aAAc,CAAEL,MAAO,IAAII,aAAa,CAAC,EAAG,IAAKF,KAAM,aACvDI,kBAAmB,CAAEN,MAAO,IAAIC,EAAAA,EAAUC,KAAM,eAChDK,YAAa,CAAEP,MAAO,IAAII,aAAa,CAAC,IAAK,IAAK,GAAK,KAAOF,KAAM,eAGlE,OACFd,YACAD,aACAqB,UAAW,CACPC,cAAe,IAAIX,EAAAA,EAAa,CAC5BY,iBAAkB,CAAEV,MAAO,IAAIC,EAAAA,EAAUC,KAAM,eAC/CS,OAAQ,CAAEX,MAAO,IAAII,aAAa,CAAC,EAAG,EAAG,EAAG,IAAKF,KAAM,aACvDU,OAAQ,CAAEZ,MAAO,EAAGE,KAAM,SAE9BL,iBACAgB,SAAUC,EAAAA,EAAQC,MAAMC,OACxBC,SAAUH,EAAAA,EAAQC,MAAMC,OAAOE,QAEtC,CAGEC,cAAAA,CACHC,EAAeC,EACfC,EACAC,EAAiBC,EACjBC,GAGM,MAAA5B,EAAiB6B,KAAKlB,UAAUX,eAEhC8B,EAAeF,EAAQL,MACvBQ,EAAgBH,EAAQJ,OACxBQ,EAAgBJ,EAAQI,cAExBvB,EAAoBT,EAAeiC,SAASxB,kBAEhCA,EAAAyB,IACdT,EAAOU,EAAIL,EAAeP,EAC1BE,EAAOW,EAAIN,EAAeN,EAC1BC,EAAOY,EAAIN,EAAgBR,EAC3BE,EAAOa,EAAIP,EAAgBP,EAC3BC,EAAOc,GAAKhB,EACZE,EAAOe,GAAKhB,GAEhBf,EAAkBgC,SAEHzC,EAAAiC,SAAS/B,UAAY8B,EAAcU,SACnC1C,EAAAiC,SAAS3B,YAAc0B,EAAc1B,YACrCN,EAAAiC,SAASzB,aAAewB,EAAcxB,aACrDR,EAAeiC,SAASxB,kBAAoBA,EAC7BT,EAAAiC,SAASvB,YAAY,GAAKa,EAC1BvB,EAAAiC,SAASvB,YAAY,GAAKc,EAC1BxB,EAAAiC,SAASvB,YAAY,GAAKgB,EAC1B1B,EAAAiC,SAASvB,YAAY,GAAKiB,EAErCC,IAEK,KAAAjB,UAAUK,SAAWY,EAAQT,OAC7B,KAAAR,UAAUS,SAAWQ,EAAQT,OAAOE,MAC7C,ECvGD,MAAMsB,UAAqBC,EAAAA,EAE9BlD,WAAAA,GAEU,OACFmD,UAAW,IAAItC,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAClDuC,IAAK,IAAIvC,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC5CwC,QAAS,IAAIC,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,KAC5C,ECMT,MAAMC,EAAa,IAAIN,EAGhB,MAAMO,EAQTxD,WAAAA,GANA,KAAOyD,UAAoB,EAQlB,KAAAC,SAAW,IAAIR,EAAAA,EAAa,CAC7BG,QAASE,EAAWF,QAAQM,QAC5BR,UAAWI,EAAWJ,UAAUQ,QAChCP,IAAKG,EAAWH,IAAIO,SACvB,CAGEC,OAAAA,GAEHzB,KAAKuB,SAASE,UACdzB,KAAK0B,QAAQD,SAAQ,EAStB,MAAME,EAeT9D,WAAAA,CAAY+D,GAFZ,KAAiBC,OAAgBC,EAAAA,EAAMC,UAInC/B,KAAKgC,UAAYJ,CAAA,CAGdK,kBAAAA,CAAmBC,GAEhB,MAAAC,EAAmBnC,KAAKoC,qBAAqBF,GAE7CG,EAAaF,EAAiBb,SAEpCtB,KAAKsC,gBAAgBJ,GAErB,MAAMZ,EAAWa,EAAiBb,SAE9B,GAAAA,GAAYA,IAAae,EAC7B,CACU,oBAAEE,GAAkBJ,EAEnB,OAACI,EAAcC,SAASC,sBAC3BF,EACAL,EAAWnC,QACf,CAGJ,OAAQsC,IAAef,CAAA,CAQpBoB,aAAAA,CAAcC,EAA4BC,GAEvC,MAAAC,EAAU7C,KAAKgC,UAAUc,YAAYC,MAG3C/C,KAAKsC,gBAAgBK,GAEf,MAAAR,EAAmBnC,KAAKoC,qBAAqBO,IAE7C,SAAEpB,EAAUD,SAAAA,GAAaa,EAE/B,GAAIb,EACJ,CACIa,EAAiBI,gBAAjBJ,EAAiBI,cAAkB,IAAIS,EAAAA,GAEvC,MAAMT,EAAgBJ,EAAiBI,cAEnCI,EAAaM,gBAEbjD,KAAKkD,qBAAqBP,GAE1BJ,EAAchB,SAAWA,EACzBgB,EAAcL,WAAaS,EAC3BJ,EAAcY,UAAYR,EAAaS,eACzBb,EAAAc,WAAWV,EAAaW,WAG1Cf,EAAcgB,YAAevD,KAAKgC,UAAUwB,aAAeb,EAAaa,aAEhEX,EAAAY,WAAWlB,EAAeK,EAAc,MAIhDC,EAAQa,MAAMd,GAEdT,EAAiBT,SAAjBS,EAAiBT,OAAW,IAAI/D,GAEhCqC,KAAK2D,iBAAiBhB,GAEtBC,EAAegB,IAAIjB,EACvB,CAGGkB,OAAAA,CAAQlB,GAEX,MAAM,OAAEjB,GAAW1B,KAAKoC,qBAAqBO,GAE7CjB,EAAOoC,OAAO,GAAK9D,KAAKgC,UAAU+B,eAAeC,UAG3C,MAAAjF,EAAgB2C,EAAO5C,UAAUC,cAAcqB,SAErDrB,EAAcC,iBAAmB2D,EAAaS,eAC9CrE,EAAcG,OAASc,KAAKgC,UAAUwB,aAAeb,EAAaa,cAElES,EAAAA,EAAAA,GACItB,EAAauB,gBACbnF,EAAcE,OACd,GAGJe,KAAK6B,OAAOsC,WAAYC,EAAAA,EAAAA,GAA0BzB,EAAa0B,eAAgB1B,EAAa5C,QAAQuE,SAE/F,KAAAtC,UAAUuC,QAAQC,KAAK,CACxBjD,SAAUH,EACVM,SACA+C,MAAOzE,KAAK6B,QACf,CAGE8B,gBAAAA,CAAiBhB,GAEd,MAAAR,EAAmBnC,KAAKoC,qBAAqBO,IAE7C,SAAErB,GAAaa,EAErB,GAAIb,EACJ,CACU,oBAAEiB,GAAkBJ,EAEtBQ,EAAaM,eAAejD,KAAKkD,qBAAqBP,GAE5CJ,EAAAC,SAASkC,cAAcnC,EAAa,MACtD,GACSI,EAAaM,cACtB,CACU,aAAEvB,GAAWS,EAGZT,EAAAjC,eACHkD,EAAajD,MACbiD,EAAahD,OACbgD,EAAagC,eAAe/E,OAC5B+C,EAAaiC,OAAOC,EACpBlC,EAAaiC,OAAOE,EACpBnC,EAAa5C,QACjB,CACJ,CAGIqC,oBAAAA,CAAqBF,GAElB,OAAAA,EAAW6C,SAAS/E,KAAKgC,UAAUgD,MAAQhF,KAAKiF,sBAAsB/C,EAAU,CAGnF+C,qBAAAA,CAAsBtC,GAEpB,MAAAuC,EAAU,IAAI7D,EAKb,OAHP6D,EAAQhD,WAAaS,EACrBA,EAAaoC,SAAS/E,KAAKgC,UAAUgD,KAAOE,EAErCA,CAAA,CAGHhC,oBAAAA,CAAqBP,GAEnB,MAAAwC,EAAiBnF,KAAKoC,qBAAqBO,IAE3C,SAAEpB,GAAa4D,EAEf3F,EAAQmD,EAAa5C,QAAQT,OAAOE,MAEhB,WAAtBA,EAAM4F,cAEN5F,EAAM4F,YAAc,SACpB5F,EAAM6F,UCrNF,SAAO1C,EAA4B1B,GAE/C,MAAMlB,EAAU4C,EAAa5C,QAEvBL,EAAQK,EAAQuF,MAAM5F,MACtBC,EAASI,EAAQuF,MAAM3F,OAE7B,IAAIE,EAAU,EACVC,EAAU,EAEV6C,EAAa4C,uBAEb1F,EAAU8C,EAAaiC,OAAOC,EAC9B/E,EAAU6C,EAAaiC,OAAOE,GAGlC7D,EAAI,GAAKA,EAAI,IAAMpB,EACnBoB,EAAI,GAAKA,EAAI,GAAK,EAAIpB,EACtBoB,EAAI,GAAKA,EAAI,IAAMnB,EACnBmB,EAAI,GAAKA,EAAI,GAAK,EAAInB,EAEtB,MAAMK,EAAgB5B,EAAAA,EAAOiH,OAEfrF,EAAAsF,SAAS9C,EAAagC,eAAe/E,QAEnDO,EAAcO,IAAMiC,EAAajD,MACjCS,EAAcQ,IAAMgC,EAAahD,OAEjCQ,EAAcS,SAEdT,EAAcuF,MAAM/C,EAAajD,MAAQA,EAAOiD,EAAahD,OAASA,GC9BnE,SAAqBgG,EAAmBC,EAAgBC,EAAgBjG,GAE3E,IAAIkG,EAAQ,EACN,MAAAC,EAAOJ,EAAMK,QAAUJ,GAAU,GAEjCtF,EAAIV,EAAOU,EACXC,EAAIX,EAAOW,EACXC,EAAIZ,EAAOY,EACXC,EAAIb,EAAOa,EACXC,EAAKd,EAAOc,GACZC,EAAKf,EAAOe,GAIlB,IAFUkF,GAAAD,EAEHE,EAAQC,GACf,CACU,MAAAlB,EAAIc,EAAME,GACVf,EAAIa,EAAME,EAAS,GAEzBF,EAAME,GAAWvF,EAAIuE,EAAMrE,EAAIsE,EAAKpE,EACpCiF,EAAME,EAAS,GAAMtF,EAAIsE,EAAMpE,EAAIqE,EAAKnE,EAE9BkF,GAAAD,EAEVE,GAAA,CAER,CDMgBG,CAAAhF,EAAK,EAAG,EAAGd,EAC3B,CDuLe+F,CAAAvD,EAAcpB,EAASN,KG3NtB,SAAa0B,EAA4B3B,GAE/C,MAAAnB,EAAU8C,EAAaiC,OAAOC,EAC9B/E,EAAU6C,EAAaiC,OAAOE,EAEpC9D,EAAU,IAAMnB,EAAU8C,EAAajD,MACvCsB,EAAU,IAAMlB,EAAU6C,EAAahD,OACvCqB,EAAU,IAAM,EAAInB,GAAW8C,EAAajD,MAC5CsB,EAAU,IAAMlB,EAAU6C,EAAahD,OACvCqB,EAAU,IAAM,EAAInB,GAAW8C,EAAajD,MAC5CsB,EAAU,IAAM,EAAIlB,GAAW6C,EAAahD,OAC5CqB,EAAU,IAAMnB,EAAU8C,EAAajD,MACvCsB,EAAU,IAAM,EAAIlB,GAAW6C,EAAahD,MAChD,CH+MqBwG,CAAAxD,EAAcpB,EAASP,UAAS,CAG1CS,OAAAA,GAEHzB,KAAKgC,UAAY,KAGbM,eAAAA,CAAgBK,GAEd,MAAAwC,EAAiBnF,KAAKoC,qBAAqBO,GAC3C5C,EAAU4C,EAAa5C,QAE7B,IAAIqG,GAAqB,EASzB,OAPIpG,KAAKgC,UAAUxD,OAAS6H,EAAAA,EAAaC,QAEfF,EAAApG,KAAKgC,UAA4BuE,QAAQC,SAASC,mBAG5EtB,EAAe7D,SAAWvB,EAAQI,cAAcuG,WAAaN,GAAsBrG,EAAQT,OAAOqH,cAE3FxB,EAAe7D,QAAA,EAxMjBK,EAGKiF,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcC,WACdD,EAAAA,GAAcE,YACdF,EAAAA,GAAcG,aAElBlK,KAAM,gBIvDdmK,EAAAA,GAAWrD,IAAIjC,E,iCCSR,MAAMqB,EAANnF,WAAAA,GAEH,KAAOqJ,YAAc,UAIrB,KAAgBC,YAAa,EAK7B,KAAOC,YAAc,EACrB,KAAOC,gBAAkB,EAKzB,KAAO9D,YAAqB,EAG5B,KAAOf,SAAoB,KAC3B,KAAO8E,OAAgB,KAGvB,KAAOC,wBAAiC,EAGxC,KAAQC,aAAsB,EAE9B,aAAIrD,GAAc,OAAOnE,KAAKkC,WAAWmC,cAAA,CAEzC,YAAIoD,GAAoB,OAAAzH,KAAK0H,WAAa1H,KAAKuB,SAASkG,QAAA,CACxD,YAAIA,CAASnJ,GAAmB0B,KAAK0H,UAAYpJ,CAAA,CAE1CqJ,KAAAA,GAEH3H,KAAKkC,WAAa,KAClBlC,KAAKD,QAAU,KACfC,KAAKwC,SAAW,KAChBxC,KAAKsH,OAAS,KACdtH,KAAKuB,SAAW,KAChBvB,KAAKwH,aAAc,EACnBxH,KAAKuH,wBAAyB,EAS3BlE,UAAAA,CAAW/E,GAEV0B,KAAKD,UAAYzB,IAErB0B,KAAKD,QAAUzB,EACf0B,KAAKuH,wBAAyB,GAGlC,OAAItG,GAEA,MAEM2G,EAFW5H,KAAKuB,SAEIsG,UAAU,OAE9B5G,EAAM2G,EAASE,KAErB,IAAIC,EAAiB9G,EACf,MAAAd,EAAgBH,KAAKD,QAAQI,cAoB5B,OAlBFA,EAAcuG,WAEfqB,EAAiB/H,KAAKgI,gBAElBhI,KAAKuH,yBAA2BpH,EAAc8H,WAAajI,KAAKwH,cAAgBI,EAASK,cAEpFF,GAAkBA,EAAe/B,OAAS/E,EAAI+E,UAE/C+B,EAAiB/H,KAAKgI,gBAAkB,IAAItJ,aAAauC,EAAI+E,SAGjEhG,KAAKuH,uBAAyBpH,EAAc8H,UAC5CjI,KAAKwH,YAAcI,EAASK,UAEd9H,EAAA+H,YAAYjH,EAAqB8G,KAIhDA,CAAA,CAGX,aAAI/G,GAEA,OAAOhB,KAAKuB,SAASP,SAAA,CAGzB,WAAIE,GAEA,OAAOlB,KAAKuB,SAASL,OAAA,CAGzB,SAAIiH,GAEA,OAAOnI,KAAKkC,WAAWgC,eAAA,CAG3B,kBAAId,GAEA,OAAOpD,KAAKkC,WAAWkB,cAAA,CAG3B,iBAAIgF,GAEO,OAAApI,KAAKuB,SAASP,UAAUgF,OAAS,EAG5C,aAAIqC,GAEO,OAAArI,KAAKuB,SAASL,QAAQ8E,MAAA,E,iCChIrC,MAAMsC,EAAe,CACjBC,OAAQ,EACR3E,IAAK,EACL4E,SAAU,EACVC,OAAQ,EACRC,QAAS,EACTC,MAAO,EACP,aAAc,EACd,UAAW,EACX,aAAc,EACdC,IAAK,EACLC,IAAK,IAiBIC,EAAN,MAAMA,EAaTjL,WAAAA,GAEImC,KAAK8H,KAAO,EAEZ9H,KAAKmE,UAAY,SACjBnE,KAAK+I,cAAgB,EAErB/I,KAAKgJ,OAAQ,EACbhJ,KAAKiJ,WAAY,EAOrB,SAAID,GAEA,SAAuB,EAAbhJ,KAAK8H,KAAa,CAGhC,SAAIkB,CAAM1K,MAEc,EAAb0B,KAAK8H,QAAyBxJ,IAEjC0B,KAAK8H,MAAS,EAClB,CAOJ,WAAIoB,GAEA,SAAuB,EAAblJ,KAAK8H,KAAa,CAGhC,WAAIoB,CAAQ5K,MAEY,EAAb0B,KAAK8H,QAA0BxJ,IAElC0B,KAAK8H,MAAS,EAClB,CAIJ,YAAIqB,CAAS7K,GAEK,SAAVA,GAOJ0B,KAAKoJ,SAAU,EACfpJ,KAAKqJ,mBAA+B,UAAV/K,GANtB0B,KAAKoJ,SAAU,CAMiB,CAGxC,YAAID,GAEI,OAACnJ,KAAKoJ,QAKHpJ,KAAKqJ,mBAAqB,QAAU,OAHhC,MAGgC,CAO/C,WAAID,GAEA,SAAuB,EAAbpJ,KAAK8H,KAAa,CAGhC,WAAIsB,CAAQ9K,MAEY,EAAb0B,KAAK8H,QAA2BxJ,IAEnC0B,KAAK8H,MAAS,EAClB,CAOJ,aAAIwB,GAEA,SAAuB,EAAbtJ,KAAK8H,KAAa,CAGhC,aAAIwB,CAAUhL,MAEU,EAAb0B,KAAK8H,QAA8BxJ,IAEtC0B,KAAK8H,MAAS,EAClB,CAOJ,aAAImB,GAEA,SAAuB,GAAbjJ,KAAK8H,KAAa,CAGhC,aAAImB,CAAU3K,MAEU,GAAb0B,KAAK8H,QAA8BxJ,IAEtC0B,KAAK8H,MAAS,GAClB,CAOJ,sBAAIuB,GAEA,SAAuB,GAAbrJ,KAAK8H,KAAa,CAGhC,sBAAIuB,CAAmB/K,MAEC,GAAb0B,KAAK8H,QAA2BxJ,IAEnC0B,KAAK8H,MAAS,GAClB,CAQJ,aAAI3D,GAEA,OAAOnE,KAAKuJ,UAAA,CAGhB,aAAIpF,CAAU7F,GAEV0B,KAAKgJ,MAAmB,SAAV1K,EACd0B,KAAKuJ,WAAajL,EACb,KAAAkL,aAAelB,EAAahK,IAAuC,EAO5E,iBAAIyK,GAEA,OAAO/I,KAAKyJ,cAAA,CAGhB,iBAAIV,CAAczK,GAET,KAAA4K,UAAY5K,EACjB0B,KAAKyJ,eAAiBnL,CAAA,CAInBoL,QAAAA,GAEH,MAAO,iCACY1J,KAAKmE,gCACInE,KAAKqJ,8BAChBrJ,KAAKoJ,qBACHpJ,KAAKiJ,2BACDjJ,KAAK+I,gBAAa,CAS7C,YAAcY,GAEJ,MAAAlF,EAAQ,IAAIqE,EAKX,OAHPrE,EAAM6E,WAAY,EAClB7E,EAAMuE,OAAQ,EAEPvE,CAAA,GA9MFqE,EAiNK/G,UAAY+G,EAAMa,QAjN7B,IAAM7H,EAANgH,C,+BCyCA,MAAMc,EA0BT,WAAcC,CAAKC,GAERC,OAAAC,eAAehK,KAAM,WACxB,CACIK,GAAAA,CAAI4J,GAEWC,WAAAC,oBAAoB,SAAUnK,KAAKoK,aAC9CpK,KAAKqK,UAAYJ,EACbA,IAEWC,WAAAI,iBAAiB,SAAUtK,KAAKoK,aAC3CpK,KAAKuK,SACT,EAEJC,GAAAA,GAEI,OAAOxK,KAAKqK,SAAA,IAIxBrK,KAAKoK,YAAc,KAEVpK,KAAKqK,YAKVrK,KAAKyK,gBAGLzK,KAAK0K,UAAYC,sBAAsB,IAAM3K,KAAKuK,YAGtDvK,KAAKyK,cAAgB,KAEbzK,KAAK0K,YAELE,qBAAqB5K,KAAK0K,WAC1B1K,KAAK0K,UAAY,OAIzB1K,KAAKuK,OAAS,KAEN,IAACvK,KAAKqK,UAEN,OAMA,IAAA3K,EACAC,EAGA,GANJK,KAAKyK,gBAMDzK,KAAKqK,YAAcH,WAAWW,OAE9BnL,EAAQwK,WAAWY,WACnBnL,EAASuK,WAAWa,gBAIxB,CACI,MAAM,YAAEC,EAAA,aAAaC,GAAiBjL,KAAKqK,UAEnC3K,EAAAsL,EACCrL,EAAAsL,CAAA,CAGR,KAAArJ,SAAS2I,OAAO7K,EAAOC,GAC5BK,KAAKkL,UAITlL,KAAK0K,UAAY,KACjB1K,KAAKqK,UAAY,KACZ,KAAAc,SAAWrB,EAAQqB,UAAY,KAOxC,cAAc1J,GAECyI,WAAAC,oBAAoB,SAAUnK,KAAKoK,aAC9CpK,KAAKyK,gBACLzK,KAAKyK,cAAgB,KACrBzK,KAAKoK,YAAc,KACnBpK,KAAKmL,SAAW,KAChBnL,KAAKuK,OAAS,MArHTX,EAGKhD,UAA+BC,EAAAA,GAAcuE,Y,wBCgExD,MAAMC,EAmBT,WAAcxB,CAAKC,GAGfA,EAAUC,OAAOuB,OAAO,CACpBC,WAAW,EACXC,cAAc,GACf1B,GAGIC,OAAAC,eAAehK,KAAM,SACxB,CACIK,GAAAA,CAAIoL,GAEIzL,KAAK0L,SAEL1L,KAAK0L,QAAQC,OAAO3L,KAAKkL,OAAQlL,MAErCA,KAAK0L,QAAUD,EACXA,GAEAA,EAAO7H,IAAI5D,KAAKkL,OAAQlL,KAAM4L,EAAAA,EAAgBC,IAClD,EAEJrB,GAAAA,GAEI,OAAOxK,KAAK0L,OAAA,IAIxB1L,KAAK8L,KAAO,KAER9L,KAAK0L,QAAQI,QAGjB9L,KAAK+L,MAAQ,KAET/L,KAAK0L,QAAQK,SAGjB/L,KAAK0L,QAAU,KACf1L,KAAKyL,OAAS3B,EAAQ0B,aAAeQ,EAAAA,EAAOxG,OAAS,IAAIwG,EAAAA,EAGrDlC,EAAQyB,WAERvL,KAAK+L,OACT,CAOJ,cAActK,GAEV,GAAIzB,KAAK0L,QACT,CACI,MAAMO,EAAYjM,KAAK0L,QAEvB1L,KAAKyL,OAAS,KACdQ,EAAUxK,SAAQ,CACtB,EAhFK4J,EAGKzE,UAA+BC,EAAAA,GAAcuE,YCzI/DnE,EAAAA,GAAWrD,IAAIgG,GACf3C,EAAAA,GAAWrD,IAAIyH,E,kCCOR,MAAMa,EAANrO,WAAAA,GAEH,KAAOqJ,YAAc,UACrB,KAAOO,SAAqB,gBAG5B,KAAgBW,cAAgB,EAChC,KAAgBC,UAAY,EAC5B,KAAgBlB,YAAa,EAQ7B,KAAO5D,YAAqB,EAI5B,KAAO4I,gBAAkB,EACzB,KAAO3J,SAAoB,KAC3B,KAAO8E,OAAgB,KAEvB,aAAInD,GAAc,OAAOnE,KAAKkC,WAAWmC,cAAA,CACzC,SAAI8D,GAAU,OAAOnI,KAAKkC,WAAWgC,eAAA,CAE9ByD,KAAAA,GAEH3H,KAAKkC,WAAa,KAClBlC,KAAKD,QAAU,KACfC,KAAKwC,SAAW,KAChBxC,KAAKsH,OAAS,KACdtH,KAAKoM,OAAS,KAGX3K,OAAAA,GACP,E,gFCzBG,MAAM4K,EAANxO,WAAAA,GAEH,KAAOyO,QAA+B,GACtC,KAAOC,SAAU,EACV9K,OAAAA,GAEE,KAAA6K,QAAQE,QAASzJ,IAElB0J,EAAAA,EAAQC,OAAO3J,KAGnB/C,KAAKsM,QAAQtG,OAAS,GAKvB,MAAM2G,EAiBT9O,WAAAA,CAAY+D,EAAoBgL,GAJzB,KAAAnI,MAAe3C,EAAAA,EAAM6H,QAMxB3J,KAAK4B,SAAWA,EAEhB5B,KAAK6M,SAAWD,EAEhB5M,KAAK4B,SAASkL,QAAQC,cAAcnJ,IAAI5D,KAAI,CAGzC+M,aAAAA,GAEE,KAAAF,SAASE,cAAc/M,KAAK4B,SAAQ,CAGtCK,kBAAAA,CAAmB+K,GAGtB,MAAMzG,EAAUyG,EAASzG,QAEnB0G,IAAeD,EAASjI,SAExBmI,EAAalN,KAAK4B,SAASuL,gBAAgBC,iBAAiB7G,GAElE,SAAI2G,EAAWG,aAAeJ,IAAeC,EAAWG,YAMjD,CAGJ3K,aAAAA,CAAcsK,EAAoBpK,GAErC,MAAMsK,EAAalN,KAAK4B,SAASuL,gBAAgBC,iBAAiBJ,EAASzG,SAIvEyG,EAAS/J,eAETjD,KAAKsN,SAASN,GAGdE,EAAWG,YAEN,KAAAE,cAAcP,EAAUpK,IAI7B5C,KAAK4B,SAASkB,YAAYC,MAAMW,MAAMd,GACtCA,EAAegB,IAAIoJ,GACvB,CAGGrJ,gBAAAA,CAAiBqJ,GAEd,MAEAV,EAFUtM,KAAKwN,yBAAyBR,GAEtBV,QAExB,IAAK,IAAImB,EAAI,EAAGA,EAAInB,EAAQtG,OAAQyH,IACpC,CACU,MAAA1K,EAAQuJ,EAAQmB,GAEhB1K,EAAAP,SAASkC,cAAc3B,EAAK,CACtC,CAGGc,OAAAA,CAAQmJ,GAEX,IAAKA,EAASU,aAAc,OAE5B,MAAM9L,EAAW5B,KAAK4B,SAChB2E,EAAUyG,EAASzG,QAIzB,IAHsB3E,EAASuL,gBAGZQ,cAAcpH,GAAS+F,QAAQtG,OAChD,OAEF,MAAMtE,EAAS6E,EAAQqH,cAAgB5N,KAAK6M,SAASnL,OAEhD,KAAA+C,MAAMN,UAAY6I,EAAS3I,eAE1B,MAAAtF,EAAgB2C,EAAO5C,UAAUC,cAAcqB,SAErDrB,EAAcC,iBAAmBgO,EAAS5J,eAC5BrE,EAAAG,OAAS0C,EAAS4B,aAAewJ,EAASxJ,cAExDS,EAAAA,EAAAA,GACI+I,EAAS9I,gBACTnF,EAAcE,OACd,GAGC,KAAA4N,SAAShJ,QAAQ7D,KAAMgN,EAAQ,CAGhCM,QAAAA,CAASN,GAEP,MAAA9H,EAAUlF,KAAKwN,yBAAyBR,GAExCE,EAAalN,KAAK4B,SAASuL,gBAAgBC,iBAAiBJ,EAASzG,SAG3ErB,EAAQzD,UAEJyL,EAAWG,aAEN,KAAAQ,4BAA4Bb,EAAU9H,EAC/C,CAGIqI,aAAAA,CAAcP,EAAoBpK,GAEhC,MAAAkL,EAAY9N,KAAK4B,SAASkB,YAAYC,MAEtCuJ,EAAUtM,KAAKwN,yBAAyBR,GAAUV,QAExD,IAAK,IAAImB,EAAI,EAAGA,EAAInB,EAAQtG,OAAQyH,IACpC,CACU,MAAA1K,EAAQuJ,EAAQmB,GAEZK,EAAArK,WAAWV,EAAOH,EAAc,CAC9C,CAGI4K,wBAAAA,CAAyBR,GAEtB,OAAAA,EAASjI,SAAS/E,KAAK4B,SAASoD,MAAQhF,KAAK+N,0BAA0Bf,EAAQ,CAGlFe,yBAAAA,CAA0Bf,GAExB,MAAA9H,EAAU,IAAImH,EAIb,OAFPW,EAASjI,SAAS/E,KAAK4B,SAASoD,KAAOE,EAEhCA,CAAA,CAGH2I,2BAAAA,CAA4Bb,EAAoB9H,GAEpD,MAAMqB,EAAUyG,EAASzG,QAEnB2G,EAAiClN,KAAK4B,SAASuL,gBAAgBQ,cAAcpH,GAE7EhD,EAAevD,KAAK4B,SAAS4B,aAAewJ,EAASxJ,aAE3D0B,EAAQoH,QAAUY,EAAWZ,QAAQ0B,IAAKjL,IAEhC,MAAAkL,EAAaxB,EAAAA,EAAQjC,IAAI0D,EAAAA,GAQxB,OANPnL,EAAMoL,OAAOF,GAEbA,EAAW/L,WAAa8K,EAExBiB,EAAW1K,YAAcA,EAElB0K,GACV,CAGExM,OAAAA,GAEHzB,KAAK4B,SAAW,KAEhB5B,KAAK6M,SAASpL,UACdzB,KAAK6M,SAAW,KAChB7M,KAAKyE,MAAQ,MA1LRkI,EAGK/F,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcC,WACdD,EAAAA,GAAcE,YACdF,EAAAA,GAAcG,aAElBlK,KAAM,YC7CdmK,EAAAA,GAAWrD,IAAI+I,GACf1F,EAAAA,GAAWrD,IAAIwK,EAAAA,G,4ICDR,MAAMC,EAAsB,CAC/BvR,KAAM,yBACNC,OAAQ,CACJC,OAAkB,iSAUlBC,KAAgB,sHAIhBC,IAAe,+LAOnBK,SAAU,CACNP,OAAkB,oQASlBC,KAAgB,+HAQXqR,EAAwB,CACjCxR,KAAM,yBACNC,OAAQ,CACJC,OAAkB,8HAKlBC,KAAgB,0FAIhBC,IAAe,sJAOnBK,SAAU,CACNP,OAAkB,oDAGlBC,KAAgB,8FCpEXsR,EAAU,CACnBzR,KAAM,WACNS,SAAU,CACNP,OAAkB,qjCAiCbwR,EAAY,CACrB1R,KAAM,WACNS,SAAU,CACNP,OAAkB,yjCCpB1B,IAAIS,EACAC,EAGG,MAAM+Q,UAAkB7Q,EAAAA,EAE3BC,WAAAA,CAAY6Q,GAEF,MAAAtO,EAAW,IAAIhC,EAAAA,EAAa,CAC9Ba,OAAQ,CAAEX,MAAO,IAAII,aAAa,CAAC,EAAG,EAAG,EAAG,IAAKF,KAAM,aACvDQ,iBAAkB,CAAEV,MAAO,IAAIC,EAAAA,EAAUC,KAAM,eAC/CmQ,UAAW,CAAErQ,MAAO,EAAGE,KAAM,OAC7BU,OAAQ,CAAEZ,MAAO,EAAGE,KAAM,SAG9Bf,IAAAA,GAAeK,EAAAA,EAAAA,GAA4B,CACvChB,KAAM,aACNiB,KAAM,CACF6Q,EAAAA,GACAC,EAAAA,EAAAA,GAAwBH,GACxBL,EACAE,EACAvQ,EAAAA,MAIRN,IAAAA,GAAcO,EAAAA,EAAAA,GAA2B,CACrCnB,KAAM,aACNiB,KAAM,CACF+Q,EAAAA,GACAC,EAAAA,EAAAA,GAA0BL,GAC1BJ,EACAE,EACAtQ,EAAAA,MAIF,OACFR,YACAD,aACAqB,UAAW,CACPC,cAAeqB,EACf4O,eAAeC,EAAAA,EAAAA,GAA6BP,KAEnD,E,0HC0BF,MAAeQ,UACVC,EAAAA,EADLtR,WAAAA,GAAA,SAAAuR,WAKa,KAAAC,MAAyCtF,OAAAuF,OAAO,MAMhE,KAAgBC,WAA2C,EAM3D,KAAgBC,WAA2C,GAE3D,KAAgBC,YAA2B,CAAEC,SAAU,EAAGC,OAAQ,EAAGC,QAAS,GAK9E,KAAgBC,eAAmD,EAEnE,KAAgBC,cAAiD,CAAEtR,KAAM,OAAQuR,MAAO,GAExF,KAAgBC,MAAgC,GAEhD,KAAOC,iBAAkB,EAGzB,KAAgBC,wBAAkC,IAClD,KAAUC,qBAAuB,IAMjC,QAAWC,GAMP,OAHAC,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,4EAGbtQ,KAAKwP,UAAA,CAOhB,gBAAWe,GAMP,OAHAF,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,+EAGbtQ,KAAKgQ,KAAA,CAOhB,QAAWjK,GAMP,OAHAsK,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,sFAGbtQ,KAAKyP,YAAYC,QAAA,CAO5B,sBAAWc,GAOP,OAHAH,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,mGAGbtQ,KAAK8P,cAAcC,KAAA,CAO9B,qBAAWU,GAMP,OAHAJ,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,iGAGbtQ,KAAK8P,cAActR,IAAA,CAGvBiD,OAAAA,GACP,IADeiP,EAAAtB,UAAApJ,OAAA,QAAA2K,IAAAvB,UAAA,IAAAA,UAAA,GAEN,KAAAwB,KAAK,UAAW5Q,MAErBA,KAAK6Q,qBAEM,UAAApD,KAAKzN,KAAKqP,MAGjBrP,KAAKqP,MAAM5B,GAAG1N,SAAS0B,UAG1BzB,KAAKqP,MAAiB,KAEnBqB,IAEK,KAAAV,MAAMxD,QAASsE,GAASA,EAAK/Q,QAAQ0B,SAAQ,IACjDzB,KAAKgQ,MAAgB,KAC1B,EC9KD,MAAMe,EAAN,MAAMA,UAA0B7B,EA+BnCrR,WAAAA,CAAYiM,GAEF,QAtBV,KAAOkH,WAAa,EAEpB,KAAyBhB,MAAmE,GAE5F,KAAiBiB,SAAmB,EACnB,KAAAC,cAA+CnH,OAAAuF,OAAO,MACvE,KAAQ6B,cAA0B,GAClC,KAAQC,UAAY,EACpB,KAAQC,UAAY,EACpB,KAAQC,sBAAwB,EAChC,KAAQC,mBAAoB,EAE5B,KAAiBC,cAAwB,EAYrC,MAAMC,EAAiB,IAAKV,EAAkBW,kBAAmB5H,GAEjE9J,KAAK2R,aAAeF,EAAeG,YACnC5R,KAAK6R,QAAUJ,EAAeK,OAExB,MAAAtS,EAAQiS,EAAejS,MAAMuS,QAE/BN,EAAeO,eAGfxS,EAAMyS,MAAM9J,MAAQ,SACpB3I,EAAMyS,MAAMC,MAAQ,EACd1S,EAAAyS,MAAMlS,QAAUX,EAAAA,EAAQ+S,MAC9B3S,EAAMyS,MAAMG,KAAO,MAGvBpS,KAAKiQ,gBAAkBwB,EAAeO,aAEtC,MAAMK,EAAoB7S,EAAMkQ,SAGhClQ,EAAMkQ,SAAW1P,KAAKkQ,wBAEhB,MAAAE,GAAOkC,EAAAA,EAAAA,GAAwB9S,GAEjCiS,EAAec,aAEX/S,EAAMgT,UAKAhT,EAAAgT,QAAQ9S,OAASM,KAAKmQ,qBAAuBkC,GAKjD7S,EAAAkQ,SAAW1P,KAAKmQ,qBAAuBkC,EAGjDrS,KAAKyS,OAASjT,EACT,KAAAgS,aAAeC,EAAeiB,cAAe,EAC7C,KAAA1B,WAAaS,EAAeT,YAAc,EAC1C,KAAAC,SAAWQ,EAAekB,SAAW,EAEtClB,EAAemB,eAEV,KAAAC,cAAgBpB,EAAemB,wBAAwBE,EAAAA,EACtDrB,EAAemB,aACf,IAAIE,EAAAA,EAAarB,EAAemB,eAGzC5S,KAAKyP,YAA8BsD,EAAAA,EAAkBC,YAAY5C,GACjEpQ,KAAKuP,WAAwB/P,EAAM+P,YAAcvP,KAAKyP,YAAYC,UAAYlQ,EAAMkQ,QAAA,CAGlFuD,gBAAAA,CAAiB5D,GAEd,MAAA6D,EAAWH,EAAAA,EAAkBI,kBAAkB9D,GAChD+D,OAAQC,IAAUrT,KAAKmR,cAAcmC,SAASD,IAC9CD,OAAQ,CAAAC,EAAMvN,EAAOyN,IAASA,EAAKC,QAAQH,KAAUvN,GAG1D,IAAKoN,EAASlN,OAAQ,OAIlB,IAAAyN,EAFJzT,KAAKmR,cAAgB,IAAInR,KAAKmR,iBAAkB+B,GAM5CO,GADJ,IADIzT,KAAKuR,kBAEMvR,KAAK0T,YAIL1T,KAAKgQ,MAAMhQ,KAAKuR,mBAG/B,IAAI,OAAEoC,EAAA,QAAQpN,GAAYkN,EAASG,iBAC/BC,EAAgBJ,EAAS1T,QAAQT,OAErC,MAAME,EAAQQ,KAAKyS,OAEnB,IAAIqB,EAAW9T,KAAKoR,UAChB2C,EAAW/T,KAAKqR,UAChB2C,EAAuBhU,KAAKsR,sBAE1B,MAAA2C,EAAYjU,KAAKmQ,qBAAuBnQ,KAAKkQ,wBAC7CyC,EAAU3S,KAAKiR,SAAWgD,EAEhC,IAAIC,GAAc,EAEZ,MAAAC,EAAkBR,EAAOjU,MAAQM,KAAKgR,WACtCoD,EAAmBT,EAAOhU,OAASK,KAAKgR,WAE9C,IAAK,IAAIvD,EAAI,EAAGA,EAAIyF,EAASlN,OAAQyH,IACrC,CACU,MAAA4F,EAAOH,EAASzF,GAEhB4G,EAAUtB,EAAAA,EAAkBuB,YAAYjB,EAAM7T,EAAOmU,GAAQ,GAInEU,EAAQ9E,WAAa8E,EAAQ1U,OAEvB,MAAAD,EAAQ2U,EAAQ3U,MAAQuU,EAMxBM,EAJoBC,KAAKC,MAA0B,WAApBjV,EAAMkV,UAAyB,EAAI,GAAKhV,GAI1B,EAAViT,EACnCgC,EAHUN,EAAQ1U,OAAUsU,EAGO,EAAVtB,EAU3B,GARUuB,GAAA,EAED,OAATb,GAA0B,OAATA,GAA0B,OAATA,GAA0B,MAATA,IAErCa,GAAA,EACdF,EAAuBQ,KAAKC,KAAKD,KAAK3L,IAAI8L,EAAcX,KAGxDF,EAAWS,EAAcJ,IAEbJ,GAAAC,EAGWA,EAAAW,EACZb,EAAA,EAEPC,EAAWC,EAAuBI,GACtC,CACIP,EAAcxO,SAER,MAAAuP,EAAW5U,KAAK0T,YAEtBC,EAASiB,EAAShB,iBAAiBD,OACnCpN,EAAUqO,EAAShB,iBAAiBrN,QACpCsN,EAAgBe,EAAS7U,QAAQT,OAEtBwU,EAAA,EACAC,EAAA,EACYC,EAAA,EAIzB,MAAAa,EAAYnV,EAAQuU,GACnBzU,EAAMsV,YAAYC,UAAY,IAC9BvV,EAAMgT,SAAS9S,OAAS,GAW/B,GARK,KAAA2P,MAAMgE,GAAQ,CACf2B,GAAI3B,EAAK4B,YAAY,GACrBC,SAAUlV,KAAKiR,SACfkE,SAAUnV,KAAKiR,SACf4D,WACAO,QAAS,CAAC,GAGVlB,EACJ,CACS,KAAAmB,WACD9O,EACA8N,EACAP,EAAWnB,EACXoB,EAAWpB,EACXsB,EACAzU,GAGE,MAAA8V,EAAKzB,EAAcnU,MAAQuU,EAC3BsB,EAAK1B,EAAclU,OAASsU,EAE5B3O,EAAQ,IAAIkQ,EAAAA,EACZ1B,EAAYwB,EAAMzB,EAAcnU,MAChCqU,EAAYwB,EAAM1B,EAAclU,OAChC4U,EAAee,EAAMzB,EAAcnU,MACnCiV,EAAgBY,EAAM1B,EAAclU,QAG1CK,KAAKqP,MAAMgE,GAAMtT,QAAU,IAAIX,EAAAA,EAAQ,CACnCE,OAAQuU,EACRvO,UAGQwO,GAAAU,KAAKC,KAAKF,EAAW,CACrC,CAGJV,EAAcxO,SAEdrF,KAAKoR,UAAY0C,EACjB9T,KAAKqR,UAAY0C,EACjB/T,KAAKsR,sBAAwB0C,EAG7BhU,KAAKwR,cAAgBxR,KAAKyV,cAAcvC,EAAU3M,EAAO,CAO7D,gBAAoBgK,GAMhB,OAHAF,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,+EAGbtQ,KAAKgQ,KAAA,CAGRyF,aAAAA,CAAcC,EAAoBnP,GAEtC,MAAMoP,EAAe3V,KAAKkR,cAE1B,IAAK,IAAIzD,EAAI,EAAGA,EAAIiI,EAAS1P,OAAQyH,IACrC,CACU,MAAAmI,EAAQF,EAASjI,GAEvB,IAAK,IAAIoI,EAAI,EAAGA,EAAI7V,KAAKmR,cAAcnL,OAAQ6P,IAC/C,CAEU,MAAAC,EAAS9V,KAAKmR,cAAc0E,GAE9B,IAAAE,EAAKJ,EAAaC,GAEjBG,IAAIA,EAAKJ,EAAaC,GAASrP,EAAQ+N,YAAYsB,GAAOlW,OAE3D,IAAAsW,EAAKL,EAAaG,GAEjBE,IAAIA,EAAKL,EAAaG,GAAUvP,EAAQ+N,YAAYwB,GAAQpW,OAEjE,IAAIuW,EAAQ1P,EAAQ+N,YAAYsB,EAAQE,GAAQpW,MAC5CwW,EAASD,GAASF,EAAKC,GAEvBE,IAEAlW,KAAKqP,MAAMuG,GAAOR,QAAQU,GAAUI,GAIxCD,EAAQ1P,EAAQ+N,YAAYsB,EAAQE,GAAQpW,MAC5CwW,EAASD,GAASF,EAAKC,GAEnBE,IAEAlW,KAAKqP,MAAMyG,GAAQV,QAAQQ,GAASM,EACxC,CACJ,CACJ,CAGIxC,SAAAA,GAEC,KAAAnC,oBAEL,MAAM4E,EAAoBnW,KAAKgR,WACzB4C,EAAmBwC,EAAAA,EAAWC,2BAChCrW,KAAK2R,aACL3R,KAAK2R,aACLwE,GAGJnW,KAAKsW,cAAc1C,EAAiBrN,QAASvG,KAAKyS,OAAQ0D,GAE1D,MAAMnF,EAAamF,GAAqBnW,KAAKmQ,qBAAuBnQ,KAAKkQ,yBACnEnQ,EAAU,IAAIX,EAAAA,EAAQ,CACxBE,OAAQ,IAAIiX,EAAAA,EAAY,CACpBC,SAAU5C,EAAiBD,OAC3B3C,aACAyF,UAAW,8BACXC,oBAAqB1W,KAAK6R,YAK9B7R,KAAK6S,gBAEG9S,EAAAT,OAAOE,MAAQQ,KAAK6S,eAGhC,MAAMY,EAAW,CACbG,mBACA7T,WAKG,OAFF,KAAAiQ,MAAMhQ,KAAKuR,mBAAqBkC,EAE9BA,CAAA,CAIH6C,aAAAA,CAAc/P,EAAoC/G,EAAkBwR,GAExExR,EAAMkQ,SAAW1P,KAAKmQ,qBACd5J,EAAAb,MAAMsL,EAAYA,GAClBzK,EAAA6J,MAAOkC,EAAAA,EAAAA,GAAwB9S,GACvCA,EAAMkQ,SAAW1P,KAAKkQ,wBACtB3J,EAAQoQ,aAAenX,EAAMmX,aAE7B,MAAMC,EAASpX,EAAMgT,QACfqE,EAAkBD,GAAQlX,OAAS,EAkBzC,GAhBIkX,IAEArQ,EAAQuQ,UAAYD,EACpBtQ,EAAQwQ,SAAWH,EAAOI,KAC1BzQ,EAAQ0Q,WAAaL,EAAOK,WAGpB1Q,EAAA2Q,aAAcC,EAAAA,EAAAA,GAAmBP,EAAQrQ,IAGjD/G,EAAMyS,QAGN1L,EAAQ6Q,WAAYD,EAAAA,EAAAA,GAAmB3X,EAAMyS,MAAO1L,IAGpD/G,EAAMsV,WACV,CACI,MAAMuC,EAAgB7X,EAAMsV,WACtBwC,EAAMC,EAAAA,EAAM/R,OAAOgS,SAASH,EAAclP,OAAOsP,UAEjDC,EAAiBL,EAAcM,KAAO3G,EACtC4G,EAAqBP,EAActC,SAAW/D,EAEpDzK,EAAQsR,YAAc,QAAiB,IAATP,EAAI,MAAqB,IAATA,EAAI,MAAqB,IAATA,EAAI,MAAYD,EAAcnF,SAC5F3L,EAAQuR,WAAaJ,EACrBnR,EAAQwR,cAAgBvD,KAAKwD,IAAIX,EAAcY,OAASL,EACxDrR,EAAQ2R,cAAgB1D,KAAK2D,IAAId,EAAcY,OAASL,CAAA,MAIxDrR,EAAQsR,YAAc,QACtBtR,EAAQuR,WAAa,EACrBvR,EAAQwR,cAAgB,EACxBxR,EAAQ2R,cAAgB,CAC5B,CAGI7C,UAAAA,CACJ9O,EACA8N,EACAxP,EACAC,EACAmP,EACAzU,GAGA,MAAM6T,EAAOgB,EAAQ+D,KACfC,EAAiBhE,EAAQgE,eACzBzB,EAASpX,EAAMgT,QAEfqE,GAAmBD,GAAQlX,OAAS,GAAKuU,EAEzCvT,EAAKmE,EAAKgS,EAAkB,EAC5BlW,EAAKmE,EAAK+R,EAAkB,EAE5BjH,EAAUyI,EAAezI,QAAUqE,EACnC1E,EAAa8E,EAAQ9E,WAAa0E,EAExC,IAAIqE,GAAe,EAEf9Y,EAAMoX,QAAUC,IAEDyB,GAAA,EACf/R,EAAQgS,WAAWlF,EAAM3S,EAAIC,EAAK4O,EAAaK,IAGnD,MAAM,WAAEkI,EAAA,cAAYC,EAAeG,cAAAA,GAAkB3R,EAEjD/G,EAAMyS,QAEFqG,IAEA/R,EAAQuR,WAAa,EACrBvR,EAAQwR,cAAgB,EACxBxR,EAAQ2R,cAAgB,GAE5B3R,EAAQiS,SAASnF,EAAM3S,EAAIC,EAAK4O,EAAaK,IAG7C0I,IAEA/R,EAAQuR,WAAaA,EACrBvR,EAAQwR,cAAgBA,EACxBxR,EAAQ2R,cAAgBA,EAC5B,CAGYzW,OAAAA,GAEZgX,MAAMhX,UAEN,IAAK,IAAIgM,EAAI,EAAGA,EAAIzN,KAAKgQ,MAAMhK,OAAQyH,IACvC,CACI,MAAM,iBAAEmG,EAAkB7T,QAAAA,GAAYC,KAAKgQ,MAAMvC,GAEjD2I,EAAAA,EAAWsC,uBAAuB9E,GAClC7T,EAAQ0B,SAAQ,EAAI,CAGvBzB,KAAKgQ,MAAiB,OAvblBe,EAEKW,eAA2C,CACrDE,YAAa,IACbpS,MAAO,IAAImZ,EAAAA,EACX7G,QAAQ,GALT,IAAM8G,EAAN7H,ECHA,SAAS8H,EACZxJ,EACA7P,EACA4Q,EACA0I,GAGA,MAAMC,EAAmC,CACrCrZ,MAAO,EACPC,OAAQ,EACRqZ,QAAS,EACTtT,MAAOlG,EAAMkQ,SAAWU,EAAKF,wBAC7B+I,MAAO,CAAC,CACJvZ,MAAO,EACPwZ,cAAe,GACfC,WAAY,EACZC,YAAa,GACb/J,MAAO,MAIf0J,EAAWC,QAAU5I,EAAKP,eAEtB,IAAAwJ,EAAcN,EAAWE,MAAM,GAE/BK,EAAuB,KACvBC,GAAY,EAGhB,MAAMC,EAAc,CAChBC,WAAW,EACX/Z,MAAO,EACPqM,MAAO,EACPjG,MAAO,EACP9E,UAAW,GACXqO,MAAO,IAGLqK,EAAYC,IAEd,MAAM5N,EAAQsN,EAAY3Z,MAE1B,IAAK,IAAImW,EAAI,EAAGA,EAAI2D,EAAY1T,MAAO+P,IACvC,CACU,MAAA+D,EAAWD,EAAK3Y,UAAU6U,GAEhCwD,EAAYhK,MAAMwK,KAAKF,EAAKtK,MAAMwG,IACtBwD,EAAAH,cAAcW,KAAKD,EAAW7N,EAAK,CAGnDsN,EAAY3Z,OAASia,EAAKja,MAEd6Z,GAAA,EAGZC,EAAY9Z,MAAQ,EACpB8Z,EAAY1T,MAAQ,EACpB0T,EAAYnK,MAAMrJ,OAAS,GAKzB8T,EAAWA,KAET,IAAAhU,EAAQuT,EAAYhK,MAAMrJ,OAAS,EAEvC,GAAI8S,EACJ,CACQ,IAAAiB,EAAWV,EAAYhK,MAAMvJ,GAEjC,KAAoB,MAAbiU,GAEHV,EAAY3Z,OAAS0Q,EAAKf,MAAM0K,GAAUlF,SAC/BkF,EAAAV,EAAYhK,QAAQvJ,EACnC,CAGJiT,EAAWrZ,MAAQ8U,KAAK3L,IAAIkQ,EAAWrZ,MAAO2Z,EAAY3Z,OAE5C2Z,EAAA,CACV3Z,MAAO,EACPwZ,cAAe,GACf7J,MAAO,GACP8J,WAAY,EACZC,YAAa,IAGLG,GAAA,EACDR,EAAAE,MAAMY,KAAKR,GACtBN,EAAWpZ,QAAUyQ,EAAKb,YAGxB7J,EAAQ0K,EAAKF,wBAA0B1Q,EAAMkQ,SAE7CsK,EAAwBxa,EAAMya,cAAgBvU,EAC9CwU,EAAwB1a,EAAM2a,cAAgBzU,EAE9C0U,EAAa5a,EAAM6a,UAAY7a,EAAM4a,WAErCE,EAAmBxD,GACrBA,EAAYkD,EAAwBE,EAGxC,IAAK,IAAIzM,EAAI,EAAGA,EAAI4B,EAAMrJ,OAAS,EAAGyH,IACtC,CACQ,IAAA4F,EAEE,MAAAkH,EAAQ9M,IAAM4B,EAAMrJ,OAErBuU,IAEDlH,EAAOhE,EAAM5B,IAGjB,MAAM+M,EAAWpK,EAAKf,MAAMgE,IAASjD,EAAKf,MAAM,KAQhD,GANiB,SAAUoL,KAAKpH,IACQ,OAATA,GAA0B,OAATA,GAAiBkH,EAMjE,CA0BQ,IAzBuBhB,GAAa/Z,EAAM6a,UAAYC,EAAgBjB,EAAY3Z,MAAQ8Z,EAAY9Z,QAI7Foa,IAETJ,EAASF,GAEJe,GAEWlB,EAAAH,cAAcW,KAAK,KAKnCL,EAAYzN,MAAQsN,EAAY3Z,MAEhCga,EAASF,GAEJe,GAEWlB,EAAAH,cAAcW,KAAK,IAI1B,OAATxG,GAA0B,OAATA,EAES,IAAtBgG,EAAY3Z,OAEHoa,SAEjB,IACUS,EACV,CACI,MAAMpB,EAAaqB,EAAS3F,UAAY2F,EAASpF,QAAQkE,IAAiB,GAAKU,EAE/EX,EAAY3Z,OAASyZ,EAErBE,EAAYF,WAAaA,EACzBE,EAAYD,YAAYS,KAAKR,EAAYH,cAAclT,QAC3CqT,EAAAhK,MAAMwK,KAAKxG,EAAI,CAG/B,KAGJ,CACI,MAAM+B,EAAUoF,EAASpF,QAAQkE,IAAiB,EAE5CoB,EAAgBF,EAAS3F,SAAWO,EAAU4E,EAE1BI,GAAcE,EAAgBjB,EAAY3Z,MAAQ8Z,EAAY9Z,MAAQgb,KAI5FhB,EAASF,GACAM,KAGbN,EAAYxY,UAAUwY,EAAY1T,SAAW0T,EAAY9Z,MAAQ0V,EACrDoE,EAAAnK,MAAMwK,KAAKxG,GAEvBmG,EAAY9Z,OAASgb,CAAA,CAGVpB,EAAAjG,CAAA,CAmBZ,OAfEyG,IAEW,WAAhBta,EAAMmb,MAgBd,SAAqBC,GAEjB,IAAK,IAAInN,EAAI,EAAGA,EAAImN,EAAgB3B,MAAMjT,OAAQyH,IAClD,CACU,MAAAoN,EAAOD,EAAgB3B,MAAMxL,GAC7B5H,EAAW+U,EAAgBlb,MAAQ,EAAMmb,EAAKnb,MAAQ,EAE5D,IAAK,IAAImW,EAAI,EAAGA,EAAIgF,EAAK3B,cAAclT,OAAQ6P,IAEtCgF,EAAA3B,cAAcrD,IAAMhQ,CAC7B,CAER,CA1BQiV,CAAY/B,GAES,UAAhBvZ,EAAMmb,MA0BnB,SAAoBC,GAEhB,IAAK,IAAInN,EAAI,EAAGA,EAAImN,EAAgB3B,MAAMjT,OAAQyH,IAClD,CACU,MAAAoN,EAAOD,EAAgB3B,MAAMxL,GAC7B5H,EAAW+U,EAAgBlb,MAAUmb,EAAKnb,MAEhD,IAAK,IAAImW,EAAI,EAAGA,EAAIgF,EAAK3B,cAAclT,OAAQ6P,IAEtCgF,EAAA3B,cAAcrD,IAAMhQ,CAC7B,CAER,CApCQkV,CAAWhC,GAEU,YAAhBvZ,EAAMmb,OAoCnB,SAAsBC,GAElB,MAAMlb,EAAQkb,EAAgBlb,MAE9B,IAAK,IAAI+N,EAAI,EAAGA,EAAImN,EAAgB3B,MAAMjT,OAAQyH,IAClD,CACU,MAAAoN,EAAOD,EAAgB3B,MAAMxL,GAEnC,IAAIuN,EAAO,EACPC,EAAaJ,EAAKzB,YAAY4B,KAE9BnV,EAAS,EAEP,MAAAqV,EAAcL,EAAKzB,YAAYpT,OAI/BmT,GAFiBzZ,EAAQmb,EAAKnb,OAASwb,EAI7C,IAAK,IAAIrF,EAAI,EAAGA,EAAIgF,EAAK3B,cAAclT,OAAQ6P,IAEvCA,IAAMoF,IAEOA,EAAAJ,EAAKzB,YAAY4B,KAEpBnV,GAAAsT,GAGT0B,EAAA3B,cAAcrD,IAAMhQ,CAC7B,CAER,CAjEQsV,CAAapC,GAGVA,CACX,CCpOA,IAAIqC,EAAY,EAiaH,MAAAC,EAAoB,IApPjC,MAAAxd,WAAAA,GAQoB,KAAAyd,MAAQ,CAAC,CAAC,IAAK,KAAM,CAAC,IAAK,KAAM,KAQjD,KAAgBC,QAAU,CAAC,CAAC,IAAK,MAMjC,KAAgBC,aAAe,CAAC,CAAC,IAAK,KAAM,CAAC,IAAK,KAAM,CAAC,IAAK,KAAM,KAOpE,KAAgBC,MAAQ,CAAC,CAAC,IAAK,MAG/B,KAAO/J,eAA0D,CAC7DrC,MAAOrP,KAAKwb,aACZxK,WAAY,EACZ2B,QAAS,EACTD,aAAa,EACbE,aAAc,KAClB,CAOO8I,OAAAA,CAAQtD,EAAc5Y,GAErB,IAAAmc,EAAgB,GAAGnc,EAAMgQ,oBACzBwC,GAAe,EAGnB,GAAIxS,EAAMyS,MAAMG,OAAS5S,EAAMgT,QAEVmJ,GAAAnc,EAAMyS,MAAMG,KAAKwJ,SACnB5J,GAAA,OAEV,GAAAxS,EAAMgT,SAAWhT,EAAMsV,WAChC,CAGI,IAAI+G,EAAMrc,EAAMoc,SAGhBC,EAAMA,EAAIC,UAAU,EAAGD,EAAIE,YAAY,MAEvCJ,EAAgB,GAAGE,WACJ7J,GAAA,EAInB,IAAKgK,EAAAA,EAAMC,IAAIN,GACf,CACU,MAAAO,EAAM,IAAItD,EAAkB,CAC9BpZ,QACAwS,eACAO,cAAc,KACXvS,KAAK0R,iBAGZ0J,IAGIA,EAAY,KAGPe,EAAAA,EAAAA,GAAA,aAAc,gCAAgCf,qIAGnDc,EAAAE,KAAK,UAAW,KAEhBhB,IACAY,EAAAA,EAAMrQ,OAAOgQ,KAGXK,EAAAA,EAAA3b,IACFsb,EACAO,EACJ,CAGE,MAAAG,EAAcL,EAAAA,EAAMxR,IAAImR,GAIvB,OAFNU,EAAkCpJ,mBAAmBmF,GAE/CiE,CAAA,CASJC,SAAAA,CAAUlE,EAAc5Y,GAC/B,IADiDsZ,IAAA1J,UAAApJ,OAAA,QAAA2K,IAAAvB,UAAA,KAAAA,UAAA,GAE7C,MAAMmN,EAAavc,KAAK0b,QAAQtD,EAAM5Y,GAItC,OAAOqZ,EAFU9F,EAAAA,EAAkBI,kBAAkBiF,GAEhB5Y,EAAO+c,EAAYzD,EAAO,CAS5DxE,WAAAA,CACH8D,EACA5Y,GAGJ,IAFIsZ,IAAA1J,UAAApJ,OAAA,QAAA2K,IAAAvB,UAAA,KAAAA,UAAA,GAGA,OAAOpP,KAAKsc,UAAUlE,EAAM5Y,EAAOsZ,EAAO,CAuBvC0D,OAAAA,GAEC,IAAA1S,EAAAsF,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,GAEmB,kBAAZtF,IAEGA,EAAA,CACNhN,KAAMgN,EACNtK,MAAA4P,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,GACAC,OAAOD,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,KAASC,MAChB2B,YAAY5B,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,KAAS4B,WACrB2B,SAASvD,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,KAASuD,QAClBD,aAAatD,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,KAASsD,cAK1BrC,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,4HAIxB,MAAMxT,EAAOgN,GAAShN,KAEtB,IAAKA,EAEK,UAAI2f,MAAM,oDAGpB3S,EAAU,IAAK9J,KAAK0R,kBAAmB5H,GAEvC,MAAM4S,EAAY5S,EAAQtK,MAEpBA,EAAQkd,aAAqB/D,EAAAA,EAAY+D,EAAY,IAAI/D,EAAAA,EAAU+D,GACnE1K,EAAoC,OAArBxS,EAAMyS,MAAMG,WAAsC,IAArB5S,EAAMyS,MAAMG,KACxDhC,EAAO,IAAIwI,EAAkB,CAC/BpZ,QACAwS,eACAU,YAAa5I,EAAQ4I,YACrBC,QAAS7I,EAAQ6I,QACjB3B,WAAYlH,EAAQkH,WACpBuB,cAAc,EACdK,aAAc9I,EAAQ8I,eAGpB+J,EC5XP,SAA2BtN,GAG9B,GAAc,KAAVA,EAEA,MAAO,GAIU,kBAAVA,IAEPA,EAAQ,CAACA,IAIb,MAAMuN,EAAmB,GAEzB,IAAK,IAAInP,EAAI,EAAGoI,EAAIxG,EAAMrJ,OAAQyH,EAAIoI,EAAGpI,IACzC,CACU,MAAAoP,EAAOxN,EAAM5B,GAGf,GAAAqP,MAAMC,QAAQF,GAClB,CACQ,GAAgB,IAAhBA,EAAK7W,OAEL,MAAM,IAAIyW,MAAM,iEAAiEI,EAAK7W,WAEtF,GAAmB,IAAnB6W,EAAK,GAAG7W,QAAmC,IAAnB6W,EAAK,GAAG7W,OAE1B,UAAIyW,MAAM,8CAGpB,MAAMO,EAAYH,EAAK,GAAGI,WAAW,GAC/BC,EAAUL,EAAK,GAAGI,WAAW,GAEnC,GAAIC,EAAUF,EAEJ,UAAIP,MAAM,0CAGpB,IAAK,IAAIU,EAAIH,EAAWI,EAAIF,EAASC,GAAKC,EAAGD,IAEzCP,EAAO/C,KAAKwD,OAAOC,aAAaH,GACpC,MAIAP,EAAO/C,QAAQiD,MAAMS,KAAKV,GAC9B,CAGA,GAAkB,IAAlBD,EAAO5W,OAED,UAAIyW,MAAM,sDAGb,OAAAG,CACX,CDkU0BY,CAAkB1T,EAAQuF,OAQrC,OANPe,EAAK6C,iBAAiB0J,EAAU3F,KAAK,KAErCgF,EAAAA,EAAM3b,IAAI,GAAGvD,WAAesT,GAEvBA,EAAAgM,KAAK,UAAW,IAAMJ,EAAAA,EAAMrQ,OAAO,GAAG7O,aAEpCsT,CAAA,CAOJqN,SAAAA,CAAU3gB,GAEP,MAAA4gB,EAAW,GAAG5gB,WACdsT,EAAO4L,EAAAA,EAAMxR,IAAgBkT,GAE/BtN,GAEAA,EAAK3O,SACT,GE5YD,MAAMkc,UAA2BC,EAAAA,EAE7Bnc,OAAAA,GAECzB,KAAKuG,QAAQqH,cAER,KAAArH,QAAQqH,aAAanM,UAG9BgX,MAAMhX,SAAQ,EAKf,MAAMoc,EAcThgB,WAAAA,CAAY+D,GAER5B,KAAKgC,UAAYJ,EACjB5B,KAAKgC,UAAU8b,aAAaC,eAAe/d,KAAM,iBAAgB,CAG9DiC,kBAAAA,CAAmB+b,GAEhB,MAAAC,EAAqBje,KAAKke,kBAAkBF,GASlD,OAPIA,EAAWG,iBAEXH,EAAWG,gBAAiB,EAEvB,KAAAC,eAAeJ,EAAYC,IAG7Bje,KAAKgC,UAAUc,YAAYkK,SAAS/K,mBAAmBgc,EAAkB,CAO7Evb,aAAAA,CAAcsb,EAAwBpb,GAEnC,MAAAqb,EAAqBje,KAAKke,kBAAkBF,GAGlDK,EAAcL,EAAYC,GAEtBD,EAAWG,iBAEXH,EAAWG,gBAAiB,EAEvB,KAAAC,eAAeJ,EAAYC,IAGpCje,KAAKgC,UAAUc,YAAYkK,SAAStK,cAAcub,EAAoBrb,GAElEqb,EAAmB1X,QAAQqH,cAE3B5N,KAAKse,qBAAqBN,EAC9B,CAGGra,gBAAAA,CAAiBqa,GAEd,MAAAC,EAAqBje,KAAKke,kBAAkBF,GAGlDK,EAAcL,EAAYC,GAE1Bje,KAAKgC,UAAUc,YAAYkK,SAASrJ,iBAAiBsa,GAEjDA,EAAmB1X,QAAQqH,cAE3B5N,KAAKse,qBAAqBN,EAC9B,CAGII,cAAAA,CAAeJ,EAAwBO,GAErC,cAAEhY,GAAYgY,EAEdhC,EAAalB,EAAkBK,QAAQsC,EAAW5F,KAAM4F,EAAWvL,QAEzElM,EAAQiY,QAE8B,SAAlCjC,EAAWzM,cAActR,OAEpB+H,EAAQqH,eAGTrH,EAAQqH,aAAe,IAAIa,EAAUzO,KAAKgC,UAAUyc,OAAOC,wBAInE,MAAMrP,EAAQ0D,EAAAA,EAAkBI,kBAAkB6K,EAAW5F,MACvD5Y,EAAQwe,EAAWvL,OAEzB,IAAIsB,EAAWwI,EAAW1M,eAG1B,MAAM8O,EAAmB9F,EAAoBxJ,EAAO7P,EAAO+c,GAAY,GAEjE5J,EAAUnT,EAAMmT,QAChBjN,EAAQiZ,EAAiBjZ,MAE/B,IAAIhF,EAAKie,EAAiBjf,MACtBiB,EAAKge,EAAiBhf,OAASgf,EAAiB3F,QAEhDxZ,EAAMgT,UAEA9R,GAAAlB,EAAMgT,QAAQ9S,MAAQgG,EACtB/E,GAAAnB,EAAMgT,QAAQ9S,MAAQgG,GAGhCa,EACKqY,WAAYZ,EAAWa,QAAQC,GAAKpe,EAAMiS,GAAWqL,EAAWa,QAAQE,GAAKpe,EAAMgS,GACnFjN,MAAMA,EAAOA,GAElB,MAAMsZ,EAAOzC,EAAWtM,gBAAkBzQ,EAAMyS,MAAM9J,MAAQ,SAE9D,IAAK,IAAIsF,EAAI,EAAGA,EAAIkR,EAAiB1F,MAAMjT,OAAQyH,IACnD,CACU,MAAAoN,EAAO8D,EAAiB1F,MAAMxL,GAEpC,IAAK,IAAIoI,EAAI,EAAGA,EAAIgF,EAAK3B,cAAclT,OAAQ6P,IAC/C,CACU,MAAAxC,EAAOwH,EAAKxL,MAAMwG,GAElB2E,EAAW+B,EAAWlN,MAAMgE,GAE9BmH,GAAUza,SAEFwG,EAAAxG,QACJya,EAASza,QACTif,GAAc,QACdxK,KAAKyK,MAAMpE,EAAK3B,cAAcrD,GAAK2E,EAAStF,SAC5CV,KAAKyK,MAAMlL,EAAWyG,EAASrF,SAEvC,CAGJpB,GAAYwI,EAAWhN,UAAA,CAC3B,CAGI2O,iBAAAA,CAAkBF,GAEf,OAAAA,EAAWjZ,SAAS/E,KAAKgC,UAAUgD,MAAQhF,KAAKkf,YAAYlB,EAAU,CAG1EkB,WAAAA,CAAYlB,GAGT,MAAAmB,EAAkB,IAAIxB,EAMrB,OAJPK,EAAWjZ,SAAS/E,KAAKgC,UAAUgD,KAAOma,EAErC,KAAAf,eAAeJ,EAAYmB,GAEzBA,CAAA,CAGHb,oBAAAA,CAAqBN,GAEzB,MAAMzX,EAAUvG,KAAKke,kBAAkBF,GAAYzX,QAE7CiJ,EAAawO,EAAWvL,OAAOjD,WAC/B6M,EAAcL,EAAAA,EAAMxR,IAAI,GAAGgF,aAG3B,EAAElP,EAAGC,EAAAA,EAAA,EAAGC,EAAGC,EAAAA,GAAMud,EAAW5a,eAE5Bgc,EAAK5K,KAAK6K,KAAM/e,EAAIA,EAAMC,EAAIA,GAC9B+e,EAAK9K,KAAK6K,KAAM7e,EAAIA,EAAMC,EAAIA,GAC9B8e,GAAc/K,KAAKgL,IAAIJ,GAAM5K,KAAKgL,IAAIF,IAAO,EAE7CrL,EAAYoI,EAAYlM,qBAAuB6N,EAAWvL,OAAO/C,SAEjEqF,EAAWwK,EAAalD,EAAYvM,cAAcC,OAAS,EAAIkE,GAErE1N,EAAQqH,aAAa9O,UAAUC,cAAcqB,SAASuO,UAAYoG,CAAA,CAG/DtT,OAAAA,GAEHzB,KAAKgC,UAAY,MAIzB,SAASqc,EAAcoB,EAAuBC,GAE1CA,EAAMtc,eAAiBqc,EAAUrc,eACjCsc,EAAMxb,gBAAkBub,EAAUvb,gBAClCwb,EAAMC,WAAaF,EAAUE,WAC7BD,EAAMrb,eAAiBob,EAAUpb,eACjCqb,EAAME,oBAAsBH,EAAUG,oBACtCF,EAAMtc,eAAiBqc,EAAUrc,eACjCsc,EAAMG,mBAAqBJ,EAAUI,mBACrCH,EAAMI,WAAaL,EAAUK,WAC7BJ,EAAMlc,aAAeic,EAAUjc,YACnC,CAtMaqa,EAGKjX,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcC,WACdD,EAAAA,GAAcE,YACdF,EAAAA,GAAcG,aAElBlK,KAAM,cCnCdmK,EAAAA,GAAWrD,IAAIia,E,6DCQR,MAAMkC,UAA0B7T,EAAAA,EAUnCrO,WAAAA,CAAY+D,GAEF,QARV,KAAOoe,mBAAoB,EAYvBhgB,KAAKgC,UAAYJ,EAERA,EAAAkL,QAAQmT,iBAAiBrc,IAAI5D,KAAI,CAIvCigB,gBAAAA,GAEH,MAAM7H,EAAOpY,KAAKkC,WAEdkW,EAAK8H,iBAEL9H,EAAK+H,cACT,CAIG1e,OAAAA,GAEHzB,KAAKgC,UAAUoe,SAASC,qBAAqBrgB,KAAKsgB,gBAElDtgB,KAAKsgB,eAAiB,KACrBtgB,KAAKgC,UAAqB,MCnC5B,MAAMue,EAcT1iB,WAAAA,CAAY+D,GAER5B,KAAKgC,UAAYJ,CAAA,CAGdK,kBAAAA,CAAmBme,GAEtB,OAAOA,EAASjC,cAAA,CAGbzb,aAAAA,CAAc0d,EAAoBxd,GAE/B,MAAA4d,EAAoBxgB,KAAKygB,YAAYL,GAEvCA,EAASjC,iBAETne,KAAK0gB,eAAeN,GAAUO,MAAOC,IAEjCC,QAAQC,MAAMF,KAGlBR,EAASjC,gBAAiB,GAE1B4C,EAAAA,EAAAA,GAAiBP,EAAmBJ,IAGxCpgB,KAAKgC,UAAUc,YAAYC,MAAMU,WAAW+c,EAAmB5d,EAAc,CAG1Ee,gBAAAA,CAAiByc,GAEd,MAAAI,EAAoBxgB,KAAKygB,YAAYL,GAEzBI,EAAAhe,SAASkC,cAAc8b,EAAiB,CAG9D,oBAAcE,CAAeN,GAEzBA,EAASjC,gBAAiB,EAEpB,MAAAqC,EAAoBxgB,KAAKygB,YAAYL,GAE3C,GAAII,EAAkBR,kBAAmB,OAErCQ,EAAkBF,iBAElBtgB,KAAKgC,UAAUoe,SAASC,qBAAqBG,EAAkBF,gBAC/DE,EAAkBF,eAAiB,MAGvCE,EAAkBR,mBAAoB,EAEtCI,EAASY,YAAcZ,EAASF,gBAAkBlgB,KAAKgC,UAAUgP,WAAaoP,EAASpP,WAEvF,MAAMsP,EAAiBtgB,KAAKgC,UAAUoe,SAASa,kBAAkBb,GAEjEI,EAAkBF,eAAiBA,EAEnCE,EAAkBzgB,cAAgBugB,EAG5B,MAAAY,EAAcd,EAASc,aAAed,EAASe,kBAEjDD,IAGAA,EAAYE,oBAAqB,GAGrCZ,EAAkBR,mBAAoB,GAEtCe,EAAAA,EAAAA,GAAiBP,EAAmBJ,EAAQ,CAGxCK,WAAAA,CAAYL,GAET,OAAAA,EAASrb,SAAS/E,KAAKgC,UAAUgD,MAAQhF,KAAKkf,YAAYkB,EAAQ,CAGtElB,WAAAA,CAAYkB,GAEf,MAAMI,EAAoB,IAAIT,EAAkB/f,KAAKgC,WAW9C,OATPwe,EAAkBte,WAAake,EAC/BI,EAAkBrd,UAAYid,EAAShd,eACvCod,EAAkBzgB,QAAUX,EAAAA,EAAQC,MAClBmhB,EAAApU,OAAS,CAAEiV,KAAM,EAAGC,KAAM,EAAGC,KAAM,EAAGC,KAAM,GAC9DhB,EAAkBjd,YAAevD,KAAKgC,UAAUwB,aAAe4c,EAAS5c,aAExE4c,EAASY,YAAcZ,EAASF,gBAAkBlgB,KAAKgC,UAAUgP,WAAaoP,EAASpP,WACvFoP,EAASrb,SAAS/E,KAAKgC,UAAUgD,KAAOwb,EAEjCA,CAAA,CAGJ/e,OAAAA,GAEHzB,KAAKgC,UAAY,MA/GZue,EAGK3Z,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcC,WACdD,EAAAA,GAAcE,YACdF,EAAAA,GAAcG,aAElBlK,KAAM,Y,6ECpBd,MAAM2kB,EAAQ,6BAERC,EAAU,+BAGT,MAAMC,EAST9jB,WAAAA,GAPA,KAAO+jB,QAAUC,SAASC,gBAAgBL,EAAO,OACjD,KAAOM,cAAgBF,SAASC,gBAAgBL,EAAO,iBACvD,KAAOO,WAAaH,SAASC,gBAAgBJ,EAAS,OACtD,KAAOO,aAAeJ,SAASC,gBAAgBJ,EAAS,SACjD,KAAAQ,MAAQ,IAAIC,MAKf,MAAM,cAAEJ,EAAA,QAAeH,EAASK,aAAAA,EAAA,WAAcD,GAAehiB,KAG/C+hB,EAAAK,aAAa,QAAS,SACtBL,EAAAK,aAAa,SAAU,SACrCL,EAAcviB,MAAM6iB,SAAW,SAE/BT,EAAQU,YAAYP,GAEpBA,EAAcO,YAAYL,GAC1BF,EAAcO,YAAYN,EAAU,E,wBCjBrC,SAASO,EAAe/iB,GAE3B,MAAMoX,EAASpX,EAAMgT,QACfJ,EAAO5S,EAAMyS,MAuBbuQ,EAAY,CAAC,SArBI,CACnB,UAAUjL,EAAAA,EAAM/R,OAAOgS,SAASpF,EAAKjK,OAAOsa,UAC5C,cAAejjB,EAAMkQ,aACrB,gBAAgBlQ,EAAMgQ,aACtB,gBAAgBhQ,EAAMkjB,aACtB,eAAeljB,EAAMkV,YACrB,iBAAiBlV,EAAMmjB,cACvB,mBAAmBnjB,EAAMya,kBACzB,eAAeza,EAAMmb,QACrB,YAAYnb,EAAMmT,YAClB,gBAAsC,QAArBnT,EAAMojB,YAAwBpjB,EAAM6a,SAAY,WAAa7a,EAAMojB,gBACjFpjB,EAAM+P,WAAa,CAAC,gBAAgB/P,EAAM+P,gBAAkB,MAC5D/P,EAAM6a,SAAW,CAChB,eAAc7a,EAAM4a,WAAa,YAAc,cAC/C,cAAc5a,EAAM2a,mBACpB,MACDvD,EAAS,CAACiM,EAAYjM,IAAW,MACjCpX,EAAMsV,WAAa,CAACgO,EAAgBtjB,EAAMsV,aAAe,MACzDtV,EAAMujB,cACX/L,KAAK,UAMA,OAqDX,SAAuBgM,EAAiDC,GAEpE,IAAK,MAAMxV,KAAKuV,EAChB,CACU,MAAAE,EAAWF,EAAUvV,GACrB0V,EAAc,GAEpB,IAAK,MAAMtN,KAAKqN,EAER/f,EAAU0S,GAEVsN,EAAYtJ,KAAK1W,EAAU0S,GAA6BqN,EAASrN,KAE5DuN,EAAUvN,IAGHsN,EAAAtJ,KAAKuJ,EAAUvN,GAA6BzY,QAAQ,YAAa8lB,EAASrN,KAI1FoN,EAAApJ,KAAK,GAAGpM,OAAO0V,EAAYnM,KAAK,SAAQ,CAEpD,CA7EkBqM,CAAA7jB,EAAMwjB,UAAWR,GAExBA,EAAUxL,KAAK,IAC1B,CAEA,SAAS8L,EAAgBQ,GAEf,MAAAnb,EAAQoP,EAAAA,EAAM/R,OAAOgS,SAAS8L,EAAgBnb,OAAOob,SAASD,EAAgBpR,OAAOsR,SAIrF5J,EAAW,GAHPpF,KAAKyK,MAAMzK,KAAKwD,IAAIsL,EAAgBrL,OAASqL,EAAgBvO,eAC7DP,KAAKyK,MAAMzK,KAAK2D,IAAImL,EAAgBrL,OAASqL,EAAgBvO,cAInE,OAAAuO,EAAgB3L,KAAO,EAEhB,gBAAgBiC,KAAY0J,EAAgB3L,UAAUxP,IAG1D,gBAAgByR,KAAYzR,GACvC,CAEA,SAAS0a,EAAYjM,GAEV,OACH,8BAA8BA,EAAOlX,UACrC,8BAA8B6X,EAAAA,EAAM/R,OAAOgS,SAASZ,EAAOzO,OAAOsa,UAClE,sBAAsB7L,EAAOlX,UAC7B,sBAAsB6X,EAAAA,EAAM/R,OAAOgS,SAASZ,EAAOzO,OAAOsa,UAC1D,uBACFzL,KAAK,IACX,CAGA,MAAMoM,EAAY,CACd1T,SAAU,yBACVF,WAAY,yBACZkT,WAAY,yBACZhO,UAAW,wBACXiO,YAAa,0BACb1I,cAAe,8BACfU,MAAO,wBACPhI,QAAS,uBACTiQ,WAAY,yBACZrT,WAAY,2BACZ4K,cAAe,0BAIbhX,EAAY,CACdiP,KAAO9T,GAAkB,UAAUiZ,EAAAA,EAAM/R,OAAOgS,SAASlZ,GAAOmkB,UAChErI,WAAa9b,GAAkB,eAAcA,EAAQ,YAAc,cACnEsY,OAAQiM,EACR/N,WAAYgO,GCNT,MAAMW,UAAsB9K,EAAAA,EA+B/B9a,WAAAA,GACA,IADYiM,EAAgCsF,UAAApJ,OAAA,QAAA2K,IAAAvB,UAAA,GAAAA,UAAA,MAExCqJ,MAAM3O,GA/BV,KAAQ4Z,cAA0B,GAiCzB,KAAAX,aAAejZ,EAAQiZ,cAAgB,GACvC,KAAAC,UAAYlZ,EAAQkZ,WAAa,CAAC,EAQ3C,gBAAID,CAAazkB,GAEb0B,KAAK0jB,cAAgBplB,aAAiBwe,MAAQxe,EAAQ,CAACA,GACvD0B,KAAKqF,QAAO,CAIhB,gBAAI0d,GAEA,OAAO/iB,KAAK0jB,aAAA,CAuBTre,MAAAA,GAEHrF,KAAK2jB,UAAY,KACjBlL,MAAMpT,QAAO,CA2CV0M,KAAAA,GAEH,OAAO,IAAI0R,EAAc,CACrB9I,MAAO3a,KAAK2a,MACZP,WAAYpa,KAAKoa,WACjBtF,WAAY9U,KAAK8U,WAAa,IAAK9U,KAAK8U,YAAe,KACvD1C,KAAMpS,KAAKiS,MACXzC,WAAYxP,KAAKwP,WACjBE,SAAU1P,KAAK0P,SACfgF,UAAW1U,KAAK0U,UAChBiO,YAAa3iB,KAAK2iB,YAClBD,WAAY1iB,KAAK0iB,WACjBzI,cAAeja,KAAKia,cACpB1K,WAAYvP,KAAKuP,WACjBoD,QAAS3S,KAAK2S,QACdiE,OAAQ5W,KAAKwS,QACboQ,WAAY5iB,KAAK4iB,WACjBvI,SAAUra,KAAKqa,SACfF,cAAena,KAAKma,cACpB4I,aAAc/iB,KAAK+iB,aACnBC,UAAW,IAAKhjB,KAAKgjB,YACxB,CAOL,YAAIY,GAOA,OALK5jB,KAAK2jB,YAED,KAAAA,UAAYpB,EAAeviB,OAG7BA,KAAK2jB,SAAA,CAaTE,WAAAA,GACP,QAAAC,EAAA1U,UAAApJ,OADsB1H,EACtB,IAAAwe,MAAAgH,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADsBzlB,EACtBylB,GAAA3U,UAAA2U,GACU,MAAAC,EAAQ1lB,EAAM8U,OAAQ6Q,IAAOjkB,KAAK+iB,aAAazP,SAAS2Q,IAE1DD,EAAMhe,OAAS,IAEV,KAAA+c,aAAalJ,QAAQmK,GAC1BhkB,KAAKqF,SACT,CAUG6e,cAAAA,GACP,QAAAC,EAAA/U,UAAApJ,OADyB1H,EACzB,IAAAwe,MAAAqH,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IADyB9lB,EACzB8lB,GAAAhV,UAAAgV,GACU,MAAAC,EAAW/lB,EAAM8U,OAAQ6Q,GAAMjkB,KAAK+iB,aAAazP,SAAS2Q,IAE5DI,EAASre,OAAS,IAEb,KAAA+c,aAAe/iB,KAAK+iB,aAAa3P,OAAQ6Q,IAAOI,EAAS/Q,SAAS2Q,IACvEjkB,KAAKqF,SACT,CAiCJ,QAAa+M,CAAK9T,GAGO,kBAAVA,GAAuC,kBAAVA,IAGpC6d,EAAAA,EAAAA,GAAK,gEAIT1D,MAAMrG,KAAO9T,CAAA,CA4CjB,UAAasY,CAAOtY,GAGZA,GAA0B,kBAAVA,GAAuC,kBAAVA,IAG7C6d,EAAAA,EAAAA,GAAK,kEAIT1D,MAAM7B,OAAStY,CAAA,E,cCtVD,eAAAgmB,EAAY9kB,EAA4B+kB,GAEpD,MAAAC,QC/BV,eAAuCD,GAEnC,MAAME,QAAiBC,EAAAA,EAAWla,MAAMma,MAAMJ,GAExCK,QAAaH,EAASG,OAEtBC,EAAS,IAAIC,WASZ,aAPuB,IAAIC,QAAS,CAAAC,EAASC,KAEhDJ,EAAOK,UAAY,IAAMF,EAAQH,EAAOjI,QACxCiI,EAAOM,QAAUF,EACjBJ,EAAOO,cAAcR,IAI7B,CDe0BS,CAAiBd,GAEhC,6CACa/kB,EAAMgQ,mCACVgV,8BACGhlB,EAAMkjB,oCACPljB,EAAMkV,mBAE5B,CEzCa,MAAA4Q,EAAA,IAA4BC,ICDzC,IAAIC,ECuBG,MAAMC,EAoBT5nB,WAAAA,CAAY+D,GAER5B,KAAKgC,UAAYJ,EACZ,KAAA8jB,cAAgB9jB,EAASpD,OAAS6H,EAAAA,EAAasf,MAAA,CAOjDC,UAAAA,CAAW9b,GAEP,OAAA9J,KAAKihB,kBAAkBnX,EAAO,CAGlCmX,iBAAAA,CAAkBnX,GAEd,OAAA9J,KAAK6lB,qBAAqB/b,EAAO,CAG5C,0BAAc+b,CAAqB/b,GAE/B,MAAM,KAAEsO,EAAA,MAAM5Y,EAAOwR,WAAAA,EAAA,aAAY4B,GAAiB9I,EAO5Cgc,EAAerZ,EAAAA,EAAQjC,IAAImX,GAC3BoE,ECpEE,SAAoB3N,EAAc5Y,GAE9C,MAAMgQ,EAAahQ,EAAMgQ,WACnBuW,EAAyB,GACzBC,EAAkC,CAAC,EAMnCC,EAAU7N,EAAK8N,MAFP,2BAId,SAASC,EAAcC,GAEdJ,EAAOI,KAERL,EAAalM,KAAKuM,GAElBJ,EAAOI,IAAc,EACzB,CAGA,GAAAtJ,MAAMC,QAAQvN,GAEd,IAAK,IAAI/B,EAAI,EAAGA,EAAI+B,EAAWxJ,OAAQyH,IAErB0Y,EAAA3W,EAAW/B,SAK7B0Y,EAAc3W,GAGdyW,GAEQA,EAAAzZ,QAAS0Z,IAIbC,EAFmBD,EAAMG,MAAM,KAAK,GAAGC,UAMpC,UAAA7Y,KAAKjO,EAAMwjB,UAIlBmD,EAFmB3mB,EAAMwjB,UAAUvV,GAAG+B,YAKnC,OAAAuW,CACX,CDgB6BQ,CAAoBnO,EAAM5Y,GACzCgnB,QF5DQ,eAClBT,EACAvmB,EACAkS,GAGA,MAAM+U,EAAeV,EAChB3S,OAAQ5D,GAAewM,EAAAA,EAAMC,IAAI,GAAGzM,cACpCxB,IAAK,CAAAwB,EAAY/B,KAEd,IAAK6X,EAAsBrJ,IAAIzM,GAC/B,CACI,MAAM,IAAE+U,GAAQvI,EAAAA,EAAMxR,IAAI,GAAGgF,aAEnB,IAAN/B,EAEsB6X,EAAAjlB,IAAImP,EAAY8U,EAAY,CAC9C5B,WAAYljB,EAAMkjB,WAClBhO,UAAWlV,EAAMkV,UACjBlF,cACD+U,IAKmBe,EAAAjlB,IAAImP,EAAY8U,EAAY,CAC9C5B,WAAYhR,EAAegR,WAC3BhO,UAAWhD,EAAegD,UAC1BlF,cACD+U,GACP,CAGG,OAAAe,EAAsB9a,IAAIgF,KAGzC,aAAcuV,QAAQ2B,IAAID,IAAezP,KAAK,KAClD,CEuB8B2P,CAClBZ,EACAvmB,EACAikB,EAAcmD,kBAEZC,EDnEP,SACHzO,EACA5Y,EACAsnB,EACAC,GAGuBA,IAAAA,EAAAvB,IAA2BA,EAAyB,IAAI7D,IAE/E,MAAM,WAAEK,EAAA,aAAYC,EAAcL,QAAAA,GAAYmF,EAE9C/E,EAAWgF,UAAY,UAAUxnB,EAAMokB,2CAA2CxL,UAEvE4J,EAAAI,aAAa,QAAS,qDAE7B0E,IAEA7E,EAAagF,YAAcH,GAItBjF,SAAAqF,KAAK5E,YAAYV,GAEpB,MAAAuF,EAAgBnF,EAAWoF,wBAEjCxF,EAAQjW,SAGF,MAAA0b,EAAgC,EAAhB7nB,EAAMmT,QAErB,OACHjT,MAAOynB,EAAcznB,MAAQ2nB,EAC7B1nB,OAAQwnB,EAAcxnB,OAAS0nB,EAEvC,CCiCyBC,CAAgBlP,EAAM5Y,EAAOgnB,EAASV,GAEjDpmB,EAAQ8U,KAAKC,KAAKD,KAAKC,KAAMD,KAAK3L,IAAI,EAAGge,EAASnnB,OAA0B,EAAhBF,EAAMmT,SAAiB3B,GACnFrR,EAAS6U,KAAKC,KAAKD,KAAKC,KAAMD,KAAK3L,IAAI,EAAGge,EAASlnB,QAA2B,EAAhBH,EAAMmT,SAAiB3B,GAErFkR,EAAQ4D,EAAa5D,MAKrBA,EAAAxiB,MAFe,GAEE,EAARA,GACTwiB,EAAAviB,OAHe,GAGI,EAATA,GAEhB,MAAM4nB,EEpFP,SACHnP,EACA5Y,EACAwR,EACAwV,EACAV,GAGA,MAAM,WAAE9D,EAAA,aAAYC,EAAcL,QAAAA,GAAYkE,EAE9C9D,EAAWgF,UAAY,UAAUxnB,EAAMokB,2CAA2CxL,UAClF4J,EAAWI,aAAa,QAAS,oBAAoBpR,wDACrDiR,EAAagF,YAAcT,EAE3B,MAAM,MAAE9mB,EAAA,OAAOC,GAAWmmB,EAAa5D,MAKvC,OAHAN,EAAQQ,aAAa,QAAS1iB,EAAMgK,YACpCkY,EAAQQ,aAAa,SAAUziB,EAAO+J,aAE/B,IAAI8d,eAAgBC,kBAAkB7F,EACjD,CFgEuB8F,CAAUtP,EAAM5Y,EAAOwR,EAAYwV,EAASV,SGtFnD,SAAa5D,EAAyBqC,EAAaoD,GAExD,WAAI5C,QAAc6C,UAMjBD,SAEM,IAAI5C,QAAe8C,GAAYC,WAAWD,EAAS,MAG7D3F,EAAM6F,OAAS,KAEH/C,KAGZ9C,EAAM8F,IAAM,mCAAmCC,mBAAmB1D,KAClErC,EAAMgG,YAAc,aAE5B,CHmEcC,CAAajG,EAAOqF,EI5F3B,WAEH,MAAM,UAAEa,GAAc1D,EAAAA,EAAWla,MAAM6d,eAE/B,uCAAkC5N,KAAK2N,EACnD,CJuF0CE,IAAcvC,EAAa/f,OAAS,GAEtE,MAAMwQ,EAAiD0L,EACnD,IAAAtO,EAEA5T,KAAK0lB,gBAGc9R,EK3Ff,SAA4BsO,EAAyBlR,GAIjE,MAAM4C,EAAmBwC,EAAAA,EAAWC,2BAChC6L,EAAMxiB,MACNwiB,EAAMviB,OACNqR,IAIE,QAAEzK,GAAYqN,EAMb,OAJPrN,EAAQgiB,UAAU,EAAG,EAAGrG,EAAMxiB,MAAOwiB,EAAMviB,QACnC4G,EAAAiiB,UAAUtG,EAAO,EAAG,GAGrBtO,CACX,CLyE+B6U,CAA4BvG,EAAOlR,IAG1D,MAAMjR,GAAU2oB,EAAAA,EAAAA,GAAwB9U,EAAmBA,EAAiBD,OAAS6C,EACjF0L,EAAMxiB,MAnBW,EAoBjBwiB,EAAMviB,OApBW,EAqBjBqR,GAaG,OAVH4B,IAAc7S,EAAQT,OAAOE,MAAQoT,GAErC5S,KAAK0lB,gBAEL1lB,KAAKgC,UAAUjC,QAAQ4oB,WAAW5oB,EAAQT,QAC1C8W,EAAAA,EAAWsC,uBAAuB9E,IAGtCnH,EAAAA,EAAQC,OAAOoZ,GAER/lB,CAAA,CAGJsgB,oBAAAA,CAAqBC,GAETA,EAAAsI,KAAM7oB,IAEjBC,KAAK6oB,SAAS9oB,KACf4gB,MAAM,MAGLxE,EAAAA,EAAAA,GAAK,4CAER,CAGG0M,QAAAA,CAAS9oB,GAED+oB,EAAAA,EAAAC,cAAchpB,GAAS,GACnCA,EAAQT,OAAOkX,SAAW,KAC1BzW,EAAQT,OAAO0pB,eAAiB,UAG7BvnB,OAAAA,GAGFzB,KAAKgC,UAAqB,MA5HtByjB,EAGK7e,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcoiB,YACdpiB,EAAAA,GAAcqiB,aACdriB,EAAAA,GAAcsiB,cAElBrsB,KAAM,YMjCdmK,EAAAA,GAAWrD,IAAI6hB,GACfxe,EAAAA,GAAWrD,IAAI2c,E,mDCCR,MAAM6I,UAAsBld,EAAAA,EAI/BrO,WAAAA,CAAY+D,GAEF,QAIN5B,KAAKgC,UAAYJ,EAERA,EAAAkL,QAAQmT,iBAAiBrc,IAAI5D,KAAI,CAGvCigB,gBAAAA,GAEH,MAAM7H,EAAOpY,KAAKkC,WAEdkW,EAAK8H,iBAEL9H,EAAK+H,cACT,CAGG1e,OAAAA,GAEHzB,KAAKgC,UAAUqnB,WAAWN,cAAc/oB,KAAKD,SAE5CC,KAAKgC,UAAqB,MCzB5B,MAAMsnB,EAcTzrB,WAAAA,CAAY+D,GAER5B,KAAKgC,UAAYJ,CAAA,CAGdK,kBAAAA,CAAmBmW,GAEtB,OAAOA,EAAK+F,cAAA,CAGTzb,aAAAA,CAAc0V,EAAYxV,GAEvB,MAAA2mB,EAAgBvpB,KAAKygB,YAAYrI,GAEnCA,EAAK+F,iBAELne,KAAK0gB,eAAetI,GACpBA,EAAK+F,gBAAiB,GAG1Bne,KAAKgC,UAAUc,YAAYC,MAAMU,WAAW8lB,EAAe3mB,EAAc,CAGtEe,gBAAAA,CAAiByU,GAEd,MAAAmR,EAAgBvpB,KAAKygB,YAAYrI,GAEzBmR,EAAA/mB,SAASkC,cAAc6kB,EAAa,CAG9C7I,cAAAA,CAAetI,GAEb,MAAAmR,EAAgBvpB,KAAKygB,YAAYrI,GAEnCmR,EAAcxpB,SAEdC,KAAKgC,UAAUqnB,WAAWN,cAAcQ,EAAcxpB,SAG1DqY,EAAK4I,YAAc5I,EAAK8H,gBAAkBlgB,KAAKgC,UAAUgP,WAAaoH,EAAKpH,WAE3EuY,EAAcxpB,QAAUwpB,EAAcxpB,QAAUC,KAAKgC,UAAUqnB,WAAWzD,WAAWxN,IAErF2I,EAAAA,EAAAA,GAAiBwI,EAAenR,EAAI,CAGhCqI,WAAAA,CAAYrI,GAET,OAAAA,EAAKrT,SAAS/E,KAAKgC,UAAUgD,MAAQhF,KAAKkf,YAAY9G,EAAI,CAG9D8G,WAAAA,CAAY9G,GAEf,MAAMmR,EAAgB,IAAIH,EAAcppB,KAAKgC,WAStC,OAPPunB,EAAcrnB,WAAakW,EAC3BmR,EAAcpmB,UAAYiV,EAAKhV,eACjBmmB,EAAAnd,OAAS,CAAEiV,KAAM,EAAGC,KAAM,EAAGC,KAAM,EAAGC,KAAM,GAC1D+H,EAAchmB,YAAevD,KAAKgC,UAAUwB,aAAe4U,EAAK5U,aAEhE4U,EAAKrT,SAAS/E,KAAKgC,UAAUgD,KAAOukB,EAE7BA,CAAA,CAGJ9nB,OAAAA,GAEHzB,KAAKgC,UAAY,MAjFZsnB,EAGK1iB,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcC,WACdD,EAAAA,GAAcE,YACdF,EAAAA,GAAcG,aAElBlK,KAAM,Q,+DCAP,MAAM0sB,EAcT3rB,WAAAA,CAAYmE,GAERhC,KAAKgC,UAAYA,CAAA,CAed4jB,UAAAA,CACH9b,EACAkX,EACAvO,EACAgX,GAGuB,kBAAZ3f,KAGPuG,EAAAA,EAAAA,IAAY,QAAS,qFAGXvG,EAAA,CACNsO,KAAMtO,EACNtK,MAAOiT,EACPzB,WAAYgQ,IAIdlX,EAAQtK,iBAAiBmZ,EAAAA,IAE3B7O,EAAQtK,MAAQ,IAAImZ,EAAAA,EAAU7O,EAAQtK,QAGpCsK,EAAQ8I,wBAAwBE,EAAAA,IAElChJ,EAAQ8I,aAAe,IAAIE,EAAAA,EAAahJ,EAAQ8I,eAGxB,kBAAjB9I,EAAQsO,OAEPtO,EAAAsO,KAAOtO,EAAQsO,KAAK1O,YAGhC,MAAM,KAAE0O,EAAA,MAAM5Y,EAAOoT,aAAAA,GAAiB9I,EAEhCkH,EAAalH,EAAQkH,YAAchR,KAAKgC,UAAUgP,YAElD,MAAE1L,EAAA,iBAAOsO,GAAqB8V,EAAAA,EAAoBC,oBAAoB,CACxEvR,OACA5Y,QACAwR,eAGEjR,GAAU2oB,EAAAA,EAAAA,GAAwB9U,EAAiBD,OAAQrO,EAAM5F,MAAO4F,EAAM3F,OAAQqR,GAY5F,GAVI4B,IAAc7S,EAAQT,OAAOE,MAAQoT,GAErCpT,EAAM8mB,OAGAhhB,EAAAskB,IAAIpqB,EAAMmT,SACR5S,EAAAuF,MAAMG,SAASH,GACvBvF,EAAQ8pB,aAGRrqB,EAAMsqB,QACV,CAGI,MAAMC,EAAkB/pB,KAAKgqB,cAAcjqB,EAASP,EAAMsqB,SAQnD,OALP9pB,KAAK+oB,cAAchpB,GAEnB2pB,EAAAA,EAAoBhR,uBAAuB9E,GAGpCmW,CAAA,CAOJ,OAJP/pB,KAAKgC,UAAUjC,QAAQ4oB,WAAW5oB,EAAQuE,SAE1ColB,EAAAA,EAAoBhR,uBAAuB9E,GAEpC7T,CAAA,CAQJgpB,aAAAA,CAAchpB,GAEjB,MAAMT,EAASS,EAAQT,OAEvBA,EAAOkX,SAAW,KAClBlX,EAAO0pB,eAAiB,UACxB1pB,EAAOmX,UAAY,uBAEPqS,EAAAA,EAAAC,cAAchpB,GAAS,EAAI,CAOpCkqB,kBAAAA,IAGH5Z,EAAAA,EAAAA,IACI,SACA,oGACJ,CAcI2Z,aAAAA,CAAcjqB,EAAkB+pB,GAG9B,MAAAI,EAAsBlqB,KAAKgC,UAAUmoB,aAAaA,aAGlDC,EAAgBpqB,KAAKgC,UAAUoR,OAAOiX,wBAAwB,CAChEtqB,UACA+pB,YASG,OAHP9pB,KAAKgC,UAAUmoB,aAAaG,KAAKJ,GAAqB,GAG/CE,CAAA,CAGJ3oB,OAAAA,GAEFzB,KAAKgC,UAAqB,MA5KtBwnB,EAGK5iB,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcoiB,YACdpiB,EAAAA,GAAcqiB,aACdriB,EAAAA,GAAcsiB,cAElBrsB,KAAM,cCxBdmK,EAAAA,GAAWrD,IAAI4lB,GACfviB,EAAAA,GAAWrD,IAAI0lB,E,0FCmBR,MAAMiB,EAKF9oB,OAAAA,GACP,EAkCG,MAAM+oB,EA0BT3sB,WAAAA,CAAY+D,EAAoBgL,GAdzB,KAAA7N,cAAgB,IAAIX,EAAAA,EAAa,CACpCY,iBAAkB,CAAEV,MAAO,IAAIC,EAAAA,EAAUC,KAAM,eAC/CS,OAAQ,CAAEX,MAAO,IAAII,aAAa,CAAC,EAAG,EAAG,EAAG,IAAKF,KAAM,aACvDU,OAAQ,CAAEZ,MAAO,EAAGE,KAAM,SAGvB,KAAAisB,uBAAyB,IAAIC,EAAAA,EAAU,CAC1C,EAAG1qB,KAAKjB,gBASRiB,KAAK4B,SAAWA,EAChB5B,KAAK6M,SAAWD,EAEhB5M,KAAK6M,SAAShD,MAAK,CAGhB5H,kBAAAA,CAAmB0oB,GAEhB,MAAAC,EAAW5qB,KAAK6qB,aAAaF,GAE7B1d,EAAa2d,EAASre,QAEtBue,EAAYH,EAAKpe,QAIvB,GAFAqe,EAASre,QAAUue,EAEf7d,IAAe6d,EAER,YAEFA,EACT,CACI,MAAMvpB,EAAWopB,EAAKI,UAGlB,GAAAxpB,EAASL,QAAQ8E,SAAW4kB,EAASviB,WAC9B9G,EAASP,UAAUgF,SAAW4kB,EAASI,WAKvC,OAHEJ,EAAAviB,UAAY9G,EAASL,QAAQ8E,OAC7B4kB,EAAAI,WAAazpB,EAASP,UAAUgF,QAElC,EAGL,MAAAzD,EAAgBvC,KAAKirB,kBAAkBN,GAOtC,OALHpoB,EAAcxC,QAAQiF,MAAQ2lB,EAAKrnB,SAAS0B,MAE5CzC,EAAcgF,wBAAyB,IAGnChF,EAAcC,SAASC,sBAC3BF,EACAooB,EAAKrnB,SACT,CAGG,SAGJZ,aAAAA,CAAcioB,EAAY/nB,GAEvB,MAAAC,EAAU7C,KAAK4B,SAASkB,YAAYC,OAEpC,QAAEwJ,GAAYvM,KAAK6qB,aAAaF,GAEtC,GAAIpe,EACJ,CACU,MAAA2e,EAAmBlrB,KAAKirB,kBAAkBN,GAE/BO,EAAA7nB,WAAWsnB,EAAKrnB,UACjC4nB,EAAiB3pB,SAAWopB,EAAKI,UAEzBloB,EAAAY,WAAWynB,EAAkBtoB,EAAc,MAInDC,EAAQa,MAAMd,GAEdA,EAAegB,IAAI+mB,EACvB,CAGGhnB,gBAAAA,CAAiBgnB,GAEpB,GAAIA,EAAKpe,QACT,CACU,MAAA2e,EAAmBlrB,KAAKirB,kBAAkBN,GAE/BO,EAAA7nB,WAAWsnB,EAAKrnB,UAEjC4nB,EAAiB3pB,SAAWopB,EAAKI,UAEhBG,EAAA1oB,SAASkC,cAAcwmB,EAAgB,CAC5D,CAGGrnB,OAAAA,CAAQ8mB,GAEX,IAAKA,EAAKjd,aAAc,OAExBid,EAAKlmB,MAAMN,WAAYC,EAAAA,EAAAA,GAA0BumB,EAAKtmB,eAAgBsmB,EAAK5qB,QAAQuE,SAEnF,MAAMvF,EAAgBiB,KAAKjB,cAEbA,EAAAqB,SAASpB,iBAAmB2rB,EAAKvnB,eAC/CrE,EAAcqB,SAASlB,OAASc,KAAK4B,SAAS4B,aAAemnB,EAAKnnB,aAClEzE,EAAcsG,UAEdpB,EAAAA,EAAAA,GACI0mB,EAAKzmB,gBACLnF,EAAcqB,SAASnB,OACvB,GAGC,KAAA4N,SAAShJ,QAAQ7D,KAAM2qB,EAAI,CAG5BE,YAAAA,CAAaF,GAxMzB,IAAAQ,EAAAC,EA4Me,OAFPD,EAAAR,EAAK5lB,UAALqmB,EAAcprB,KAAK4B,SAASoD,OAA5BmmB,EAAAC,GAAqC,IAAIb,GAElCI,EAAK5lB,SAAS/E,KAAK4B,SAASoD,KAAK4lB,UAAY5qB,KAAKqrB,cAAcV,EAAI,CAGvEU,aAAAA,CAAcV,GAQlB,OANAA,EAAK5lB,SAAS/E,KAAK4B,SAASoD,KAAK4lB,SAAW,CACxCre,QAASoe,EAAKpe,QACdlE,UAAWsiB,EAAKI,UAAU7pB,SAAS8E,OACnCglB,WAAYL,EAAKI,UAAU/pB,WAAWgF,QAGnC2kB,EAAK5lB,SAAS/E,KAAK4B,SAASoD,KAAK4lB,QAAA,CAGpCK,iBAAAA,CAAkBN,GA1N9B,IAAAQ,EAAAC,EA8Ne,OAFPD,EAAAR,EAAK5lB,UAALqmB,EAAcprB,KAAK4B,SAASoD,OAA5BmmB,EAAAC,GAAqC,IAAIb,GAElCI,EAAK5lB,SAAS/E,KAAK4B,SAASoD,KAAKzC,eAAiBvC,KAAKsrB,mBAAmBX,EAAI,CAGjFW,kBAAAA,CAAmBX,GAGjB,MAAAY,EAAyB,IAAIvoB,EAAAA,EAS5B,OAPPuoB,EAAQrpB,WAAayoB,EACbY,EAAAloB,WAAWsnB,EAAKrnB,UACxBioB,EAAQpoB,UAAYwnB,EAAKvnB,eACzBmoB,EAAQhoB,YAAevD,KAAK4B,SAAS4B,aAAemnB,EAAKnnB,aAEzDmnB,EAAK5lB,SAAS/E,KAAK4B,SAASoD,KAAKzC,cAAgBgpB,EAE1CA,CAAA,CAGJ9pB,OAAAA,GAEHzB,KAAKjB,cAAgB,KACrBiB,KAAKyqB,uBAAyB,KAE9BzqB,KAAK6M,SAASpL,UACdzB,KAAK6M,SAAW,KAEhB7M,KAAK4B,SAAW,MAxLX4oB,EAGK5jB,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcC,WACdD,EAAAA,GAAcE,YACdF,EAAAA,GAAcG,aAElBlK,KAAM,QCtEdmK,EAAAA,GAAWrD,IAAI4mB,E,gDCGf,MAAMgB,EAAa,I,QAAIC,GAYhB,SAAS/C,EACZxG,EACAxiB,EACAC,EACAqR,GAGA,MAAM5E,EAASof,EAEfpf,EAAOiV,KAAO,EACdjV,EAAOmV,KAAO,EAEPnV,EAAAkV,KAAQY,EAAMxiB,MAAQsR,EAAc,EACpC5E,EAAAoV,KAAQU,EAAMviB,OAASqR,EAAc,EAE5C,MAAMjR,EAAU+oB,EAAAA,EAAY4C,kBACxBtf,EAAO1M,MACP0M,EAAOzM,OACPqR,GACA,GAmBG,OAhBPjR,EAAQT,OAAO0pB,eAAiB,QAChCjpB,EAAQT,OAAOkX,SAAW0L,EAC1BniB,EAAQT,OAAOmX,UAAY,8BAEnB1W,EAAAuF,MAAM5F,MAAQA,EAAQsR,EACtBjR,EAAAuF,MAAM3F,OAASA,EAASqR,EAOhCjR,EAAQT,OAAOsR,KAAK,SAAU7Q,EAAQT,QAEtCS,EAAQ8pB,YAED9pB,CACX,C,4DCrBO,MAAM4rB,EAAN,MAAMA,UAAsB5qB,EAAAA,EAwB/BlD,WAAAA,GAEI4a,MAAM,CAAC,GAEP,IAAI3O,GAAUsF,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,KAAW,CAAC,EAEH,kBAAZtF,KAIPuG,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,gGAGVxG,EAAA,CACNpK,MAAOoK,EACPnK,OAAAyP,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,GACAwc,UAAAxc,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,GACAyc,UAAAzc,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,KAIRpP,KAAK8rB,MAAMhiB,EAAO,CAOfgiB,KAAAA,CAAMhiB,GAETA,EAAU,IAAK6hB,EAAcja,kBAAmB5H,GAE3C,KAAA8hB,UAAY5rB,KAAK4rB,WAAa9hB,EAAQ8hB,UACtC,KAAAC,UAAY7rB,KAAK6rB,WAAa/hB,EAAQ+hB,UAEtC,KAAAnsB,MAAQM,KAAKN,OAASoK,EAAQpK,MAC9B,KAAAC,OAASK,KAAKL,QAAUmK,EAAQnK,OAE/B,MAAAsW,EAAQjW,KAAK4rB,UAAY5rB,KAAK6rB,UAC9BE,EAAQ,GACR9qB,EAAM,GACNC,EAAU,GAEV0qB,EAAY5rB,KAAK4rB,UAAY,EAC7BC,EAAY7rB,KAAK6rB,UAAY,EAE7BG,EAAShsB,KAAKN,MAASksB,EACvBK,EAASjsB,KAAKL,OAAUksB,EAE9B,IAAK,IAAIpe,EAAI,EAAGA,EAAIwI,EAAOxI,IAC3B,CACU,MAAA5I,EAAK4I,EAAIzN,KAAK4rB,UACd9mB,EAAM2I,EAAIzN,KAAK4rB,UAAa,EAElCG,EAAMlS,KAAKhV,EAAImnB,EAAOlnB,EAAImnB,GAC1BhrB,EAAI4Y,KAAKhV,EAAI+mB,EAAW9mB,EAAI+mB,EAAS,CAGzC,MAAMK,EAAWN,EAAYC,EAE7B,IAAK,IAAIpe,EAAI,EAAGA,EAAIye,EAAUze,IAC9B,CACI,MAAM0e,EAAO1e,EAAIme,EACXQ,EAAQ3e,EAAIme,EAAa,EAEzBttB,EAAS8tB,EAAOpsB,KAAK4rB,UAAaO,EAClCE,EAAUD,EAAOpsB,KAAK4rB,UAAaO,EAAO,EAC1CG,GAAWF,EAAO,GAAKpsB,KAAK4rB,UAAaO,EACzCI,GAAWH,EAAO,GAAKpsB,KAAK4rB,UAAaO,EAAO,EAE9CjrB,EAAA2Y,KAAKvb,EAAO+tB,EAAQC,EACxBD,EAAQE,EAAQD,EAAM,CAG9BtsB,KAAKwsB,QAAQ,GAAG1kB,KAAO,IAAIpJ,aAAaqtB,GACxC/rB,KAAKwsB,QAAQ,GAAG1kB,KAAO,IAAIpJ,aAAauC,GACxCjB,KAAKysB,YAAY3kB,KAAO,IAAI3G,YAAYD,GAGnC,KAAAsrB,QAAQ,GAAGnnB,SACX,KAAAmnB,QAAQ,GAAGnnB,SAChBrF,KAAKysB,YAAYpnB,QAAO,GAzGnBsmB,EAEKja,eAA6D,CACvEhS,MAAO,IACPC,OAAQ,IACRisB,UAAW,GACXC,UAAW,IANZ,IAAMa,EAANf,ECCA,MAAMgB,EAAN,MAAMA,UAA0BD,EAqCnC7uB,WAAAA,GACA,IADYiM,EAAoCsF,UAAApJ,OAAA,QAAA2K,IAAAvB,UAAA,GAAAA,UAAA,MAE5CtF,EAAU,IAAK6iB,EAAkBjb,kBAAmB5H,GAE9C,OACFpK,MAAOoK,EAAQpK,MACfC,OAAQmK,EAAQnK,OAChBisB,UAAW,EACXC,UAAW,IAGf7rB,KAAKqF,OAAOyE,EAAO,CAOhBzE,MAAAA,CAAOyE,GAEL,KAAApK,MAAQoK,EAAQpK,OAASM,KAAKN,MAC9B,KAAAC,OAASmK,EAAQnK,QAAUK,KAAKL,OAChC,KAAAitB,eAAiB9iB,EAAQ+iB,eAAiB7sB,KAAK4sB,eAC/C,KAAAE,gBAAkBhjB,EAAQijB,gBAAkB/sB,KAAK8sB,gBACjD,KAAAE,WAAaljB,EAAQmjB,WAAajtB,KAAKgtB,WACvC,KAAAE,YAAcpjB,EAAQqjB,YAAcntB,KAAKktB,YACzC,KAAAE,WAAatjB,EAAQujB,WAAartB,KAAKotB,WACvC,KAAAE,cAAgBxjB,EAAQyjB,cAAgBvtB,KAAKstB,cAE7C,KAAAE,SAAW1jB,EAAQlF,QAAQC,EAC3B,KAAA4oB,SAAW3jB,EAAQlF,QAAQE,EAEhC9E,KAAK6pB,YACL7pB,KAAK0tB,iBAAgB,CAIlBA,eAAAA,GAEH,MAAMC,EAAI3tB,KAAKgB,WACT,MACFtB,EAAA,OACAC,EAAA,WACAqtB,EAAA,YACAE,EAAA,WACAE,EAAA,cACAE,EAAA,SACAE,EAAA,SACAC,GACAztB,KAEE4tB,EAAIZ,EAAaE,EACjBW,EAASnuB,EAAQkuB,EAAI,EAAMluB,EAAQkuB,EAEnCE,EAAIV,EAAaE,EACjBS,EAASpuB,EAASmuB,EAAI,EAAMnuB,EAASmuB,EAErCpoB,EAAQ8O,KAAK5L,IAAIilB,EAAQE,GAEzBC,EAAgBR,EAAW9tB,EAC3BuuB,EAAgBR,EAAW9tB,EAE/BguB,EAAA,GAAKA,EAAE,GAAKA,EAAE,IAAMA,EAAE,KAAOK,EAC/BL,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAOX,EAAatnB,EAASsoB,EACtDL,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMjuB,EAASwtB,EAAcxnB,EAASsoB,EAC7DL,EAAA,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMjuB,EAAQsuB,EAErCL,EAAA,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAAMM,EAC7BN,EAAE,GAAKA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAOP,EAAa1nB,EAASuoB,EACtDN,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMhuB,EAAU2tB,EAAgB5nB,EAASuoB,EACjEN,EAAA,IAAMA,EAAE,IAAMA,EAAE,IAAMA,EAAE,IAAMhuB,EAASsuB,EAEpC,KAAApmB,UAAU,aAAaxC,QAAO,CAIhCwkB,SAAAA,GAEH,MAAM5oB,EAAMjB,KAAKiB,IAEbA,EAAA,GAAKA,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAM,EAClCA,EAAA,GAAKA,EAAI,GAAKA,EAAI,GAAKA,EAAI,GAAK,EAEhCA,EAAA,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EACnCA,EAAA,IAAMA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EAElC,MAAAitB,EAAO,EAAMluB,KAAK4sB,eAClBuB,EAAO,EAAMnuB,KAAK8sB,gBAExB7rB,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAMitB,EAAOluB,KAAKgtB,WACnD/rB,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAMktB,EAAOnuB,KAAKotB,WAEnDnsB,EAAI,GAAKA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EAAKitB,EAAOluB,KAAKktB,YACxDjsB,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAMA,EAAI,IAAM,EAAKktB,EAAOnuB,KAAKstB,cAEpD,KAAAzlB,UAAU,OAAOxC,QAAO,GApIxBsnB,EAGKjb,eAA2C,CAErDhS,MAAO,IAEPC,OAAQ,IAERstB,UAAW,GAEXI,UAAW,GAEXF,WAAY,GAEZI,aAAc,GAGdV,cAAe,IAEfE,eAAgB,KApBjB,IAAMqB,EAANzB,ECxBA,MAAM0B,UAA+BrrB,EAAAA,EAExCnF,WAAAA,GAEU,QACD,KAAA0D,SAAW,IAAI6sB,CAAkB,CAGnC3sB,OAAAA,GAEHzB,KAAKuB,SAASE,SAAQ,EAQvB,MAAM6sB,EAcTzwB,WAAAA,CAAY+D,GAER5B,KAAKgC,UAAYJ,CAAA,CAGdc,aAAAA,CAAc6rB,EAAyB3rB,GAEpC,MAAA4rB,EAAYxuB,KAAKyuB,cAAcF,GAEjCA,EAAOtrB,eAAoB,KAAAyrB,uBAAuBH,EAAQC,GAE9DxuB,KAAKgC,UAAUc,YAAYC,MAAMU,WAAW+qB,EAAW5rB,EAAc,CAGlEe,gBAAAA,CAAiB4qB,GAEd,MAAAC,EAAYxuB,KAAKyuB,cAAcF,GAEjCA,EAAOtrB,eAAoB,KAAAyrB,uBAAuBH,EAAQC,GAEpDA,EAAAhsB,SAASkC,cAAc8pB,EAAS,CAGvCvsB,kBAAAA,CAAmBssB,GAEhB,MAAAC,EAAYxuB,KAAKyuB,cAAcF,GAE9B,OAACC,EAAUhsB,SAASC,sBACvB+rB,EACAD,EAAOjrB,SACX,CAGIorB,sBAAAA,CAAuBH,EAAyBI,GAEnDA,EAAgBptB,SACZ8D,OAAOkpB,GAGII,EAAAtrB,WAAWkrB,EAAOjrB,SAAQ,CAGtCmrB,aAAAA,CAAcF,GAEX,OAAAA,EAAOxpB,SAAS/E,KAAKgC,UAAUgD,MAAQhF,KAAK4uB,eAAeL,EAAM,CAGpEK,cAAAA,CAAeL,GAEb,MAAArpB,EAAUqpB,EAAOxpB,SAAS/E,KAAKgC,UAAUgD,KAAO,IAAIqpB,EAEpD9rB,EAAgB2C,EAaf,OAXP3C,EAAcL,WAAaqsB,EAC3BhsB,EAAcY,UAAYorB,EAAOnrB,eACjCb,EAAcxC,QAAUwuB,EAAOjrB,SAC/Bf,EAAcgB,YAAevD,KAAKgC,UAAUwB,aAAe+qB,EAAO/qB,aAG7D+qB,EAAOtrB,eAEH,KAAAyrB,uBAAuBH,EAAQhsB,GAGjC2C,CAAA,CAGJzD,OAAAA,GAEFzB,KAAKgC,UAAqB,MAnFtBssB,EAGK1nB,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcC,WACdD,EAAAA,GAAcE,YACdF,EAAAA,GAAcG,aAElBlK,KAAM,mBCrCdmK,EAAAA,GAAWrD,IAAI0qB,E,+BCOR,MAAMO,EAaThxB,WAAAA,CAAY+D,GAER5B,KAAKgC,UAAYJ,CAAA,CAGdiY,IAAAA,CAAKiV,EAAsBrP,EAAsB7c,GAEhC5C,KAAKgC,UAAUc,YAEvBC,MAAMW,MAAMd,GAExBA,EAAegB,IAAI,CACfmrB,aAAc,SACdC,WAAW,EACXC,OAAQ,aACRxP,YACAqP,gBACkB,CAGnBI,GAAAA,CAAIC,EAAuBC,EAAuBxsB,GAErD5C,KAAKgC,UAAUc,YAAYC,MAAMW,MAAMd,GAEvCA,EAAegB,IAAI,CACfmrB,aAAc,SACdE,OAAQ,YACRD,WAAW,GACd,CAGEnrB,OAAAA,CAAQwrB,GAEgB,eAAvBA,EAAYJ,OAEP,KAAAjtB,UAAUoR,OAAOyG,KAAKwV,GAEC,cAAvBA,EAAYJ,QAEZ,KAAAjtB,UAAUoR,OAAO8b,KAC1B,CAGGztB,OAAAA,GAEHzB,KAAKgC,UAAY,MA1DZ6sB,EAEKjoB,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcC,WACdD,EAAAA,GAAcE,YACdF,EAAAA,GAAcG,aAElBlK,KAAM,U,iGCOd,MAAMwyB,EAAe,IAAIC,EAAAA,EAAS,CAC9BC,WAAY,CACRC,UAAW,CACPC,OAAQ,IAAIhxB,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAC/CixB,OAAQ,YACR/pB,OAAQ,EACRC,OAAQ,IAGhB4mB,YAAa,IAAItrB,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,MAuCjD,MAAMyuB,EAAN/xB,WAAAA,GAMI,KAAOgyB,MAAO,EAMd,KAAOC,aAAwB,KAM/B,KAAOC,YAAwB,KAM/B,KAAOjG,QAAoB,KAMpB,KAAA1d,OAAS,IAAIqf,EAAAA,EAMpB,KAAOhM,UAAuB,KAM9B,KAAOuQ,eAAyB,EAMhC,KAAOC,oBAAqC,KAMrC,KAAAC,YAAc,CAAErrB,EAAG,EAAGC,EAAG,EAAGpF,MAAO,EAAGC,OAAQ,EAAE,EAoBpD,MAAMwwB,EA4BTtyB,WAAAA,CAAY+D,GAfZ,KAAQwuB,kBAAoB,EAC5B,KAAQC,aAA6B,GAEpB,KAAAC,sBAAwB,IAAIlyB,EAAAA,EAAa,CACtDmyB,WAAY,CAAEjyB,MAAO,IAAII,aAAa,GAAIF,KAAM,aAChDgyB,YAAa,CAAElyB,MAAO,IAAII,aAAa,GAAIF,KAAM,aACjDiyB,YAAa,CAAEnyB,MAAO,IAAII,aAAa,GAAIF,KAAM,aACjDkyB,aAAc,CAAEpyB,MAAO,IAAII,aAAa,GAAIF,KAAM,aAClDmyB,aAAc,CAAEryB,MAAO,IAAII,aAAa,GAAIF,KAAM,aAClDoyB,eAAgB,CAAEtyB,MAAO,IAAII,aAAa,GAAIF,KAAM,eAGxD,KAAiBqyB,uBAAoC,IAAInG,EAAAA,EAAU,IAK/D1qB,KAAK4B,SAAWA,CAAA,CAOpB,qBAAWkvB,GAEP,OAAO9wB,KAAK+wB,mBAAmBhB,WAAA,CAQ5BlW,IAAAA,CAAKwV,GAER,MAAMztB,EAAW5B,KAAK4B,SAEhBkoB,EAAUuF,EAAYP,aAAahF,QAInCkH,EAAahxB,KAAKixB,kBAExBD,EAAWnB,MAAO,EAElBmB,EAAWlH,QAAUA,EACrBkH,EAAWvR,UAAY4P,EAAY5P,UACxBuR,EAAAf,oBAAsBruB,EAASuoB,aAAa+G,cAEvD,MAAMC,EAAqBvvB,EAASuoB,aAAaA,aAAaiH,aAAa9xB,OAErE+xB,EAAiBF,EAAmBngB,WACpCsgB,EAAgBH,EAAmBI,UAGrC,GAAmB,IAAnBzH,EAAQ9jB,OAIR,YAFAgrB,EAAWnB,MAAO,GAKtB,MAAMzjB,EAAS4kB,EAAW5kB,OAM1B,GAJK,KAAAolB,qBAAqBnC,EAAajjB,GAEvCpM,KAAKyxB,uBAAuBT,EAAYpvB,EAASuoB,aAAauH,aAAcJ,EAAeD,EAAgB,GAEvGL,EAAWnB,KAEX,OAGE,MAAA8B,EAAqB3xB,KAAK4xB,yBAE1BC,EAAmB7xB,KAAK8xB,sBAAsBT,GACpD,IAAIU,EAAU,EACV/Y,EAAU,EAEV2Y,IAEAI,EAAUJ,EAAmBvlB,OAAOiV,KACpCrI,EAAU2Y,EAAmBvlB,OAAOmV,MAGnC,KAAAyQ,sBACDhB,EACAe,EAAS/Y,EACT6Y,EACAV,EAAmBzxB,MACnByxB,EAAmBxxB,QAKvBK,KAAKiyB,qBAAqBjB,EAAY5kB,EAAQxK,EAAU+vB,EAAkB,CA8BvEtH,uBAAAA,CAAwB6H,GAC/B,IAD+B,QAAEnyB,EAAS+pB,QAAAA,GAC1CoI,EAGU,MAAAlB,EAAahxB,KAAKixB,kBAExBjxB,KAAK+wB,kBAAoBC,EACzBA,EAAWnB,MAAO,EAElBmB,EAAWlH,QAAUA,EAErB,MAAMqH,EAAqBpxB,EAAQT,OAE7B+xB,EAAiBF,EAAmBngB,WACpCsgB,EAAgBH,EAAmBI,UAGrC,GAAmB,IAAnBzH,EAAQ9jB,OAID,OAFPgrB,EAAWnB,MAAO,EAEX9vB,EAGX,MAAMqM,EAAS4kB,EAAW5kB,OAU1B,GAJOA,EAAA+lB,QAAQpyB,EAAQuF,OAEvBtF,KAAKyxB,uBAAuBT,EAAY5kB,EAAOgmB,UAAWd,EAAeD,EAAgB,GAErFL,EAAWnB,KAEJ,OAAA9vB,EAGX,MAAM8xB,EAAmBR,EAIpB,KAAAW,sBACDhB,EAJY,EACA,EAKZa,EACAV,EAAmBzxB,MACnByxB,EAAmBxxB,QAOvBqxB,EAAWf,oBAAsBnH,EAAAA,EAAY4C,kBACzCtf,EAAO1M,MACP0M,EAAOzM,OACPqxB,EAAWhgB,WACXggB,EAAWO,WAGfP,EAAWjB,YAAc3wB,EAAAA,EAAQC,MAKjC2xB,EAAWlB,aAAe/vB,EAITC,KAAK4B,SAGbuoB,aAAakI,mBAKjB,KAAAC,uBAAuBtB,GAAY,GAExC,MAAMuB,EAAgBvB,EAAWf,oBAI1B,OAFPsC,EAAcjzB,OAAOmX,UAAY,sBAE1B8b,CAAA,CAIJrD,GAAAA,GAEH,MAAMttB,EAAW5B,KAAK4B,SAEhBovB,EAAahxB,KAAKwyB,iBAGpBxB,EAAWnB,OAKfjuB,EAASmC,eAAemrB,MAExBttB,EAASuoB,aAAakI,mBAEtBryB,KAAK+wB,kBAAoBC,EAEpB,KAAAsB,uBAAuBtB,GAAY,GAGpCA,EAAWhB,eAEClH,EAAAA,EAAAC,cAAciI,EAAWjB,aAI7BjH,EAAAA,EAAAC,cAAciI,EAAWlB,cAAY,CAS9C2C,cAAAA,CAAeC,EAAiCtmB,EAAgBumB,GAE7D,MAAAC,EAAuBF,EAAkBtB,aAAa9xB,OAAO0hB,YAE7D+O,EAAcjH,EAAAA,EAAY4C,kBAC5Btf,EAAO1M,MACP0M,EAAOzM,OACPizB,GACA,GAGJ,IAAI/tB,EAAIuH,EAAOiV,KACXvc,EAAIsH,EAAOmV,KAEXoR,IAEA9tB,GAAK8tB,EAAetR,KACpBvc,GAAK6tB,EAAepR,MAGpB1c,EAAA2P,KAAKqe,MAAMhuB,EAAI+tB,GACf9tB,EAAA0P,KAAKqe,MAAM/tB,EAAI8tB,GAEnB,MAAMlzB,EAAQ8U,KAAKC,KAAKrI,EAAO1M,MAAQkzB,GACjCjzB,EAAS6U,KAAKC,KAAKrI,EAAOzM,OAASizB,GAUlC,OARP5yB,KAAK4B,SAASuoB,aAAa2I,cACvBJ,EACA3C,EACA,CAAElrB,IAAGC,KACL,CAAEpF,QAAOC,UACT,CAAEkF,EAAG,EAAGC,EAAG,IAGRirB,CAAA,CAUJgD,WAAAA,CAAY3f,EAAgB4f,EAAgBC,EAAuBzU,GAEtE,MAAM5c,EAAW5B,KAAK4B,SAEhBovB,EAAahxB,KAAK+wB,kBAIlBmC,EAFsBlC,EAAWf,sBAEOgD,EAGxC5B,EAAiBzvB,EAASuoB,aAAagJ,iBAAiB/B,aAAa9xB,OAAO0hB,YAC5EhQ,EAAahR,KAAK8xB,sBAAsBT,GAG9C,IAAIU,EAAU,EACV/Y,EAAU,EAEd,GAAIka,EACJ,CACU,MAAArtB,EAAS7F,KAAKozB,4BAEpBrB,EAAUlsB,EAAOhB,EACjBmU,EAAUnT,EAAOf,CAAA,CAGhB,KAAAuuB,sBAAsBL,EAAOC,EAAQjC,EAAYe,EAAS/Y,EAAShI,EAAYkiB,EAAe1U,GAE9F,KAAA8U,0BAA0BlgB,EAAQ4f,EAAOpxB,EAAQ,CAWnD2xB,qBAAAA,CAAsBC,EAAsBjF,GAE/C,MAAMzmB,EAAO9H,KAAK+wB,kBAEZ0C,EAAeD,EAAanzB,IAC9ByH,EAAKgoB,aAAaxrB,QAAQ5E,MAC1B,EAAG,EACHoI,EAAKgoB,aAAaxrB,QAAQ3E,OAC1BmI,EAAKsE,OAAOiV,KAAMvZ,EAAKsE,OAAOmV,MAG5BmS,EAAiBnF,EAAOmF,eAAevlB,OAAO5P,EAAAA,EAAOiH,QAErD0b,EAAcqN,EAAOrN,aAAeqN,EAAOpN,kBAiB1C,OAfHD,GAAeA,EAAYyS,uBAGZD,EAAAE,QAAQ1S,EAAYyS,uBAGvCD,EAAe9yB,SACf6yB,EAAaG,QAAQF,GACRD,EAAA/tB,MACT,EAAM6oB,EAAOxuB,QAAQuF,MAAM5F,MAC3B,EAAM6uB,EAAOxuB,QAAQuF,MAAM3F,QAG/B8zB,EAAa7U,UAAU2P,EAAO3pB,OAAOC,EAAG0pB,EAAO3pB,OAAOE,GAE/C2uB,CAAA,CAGJhyB,OAAAA,GACP,CAUQ6xB,yBAAAA,CAA0BlgB,EAAgB4f,EAAgBpxB,GAGzD,GAAAA,EAA4BkB,YAAY+wB,aAC7C,CACI,MAAMC,EAAiBlyB,EAA4BkB,YAAY+wB,aAC1DE,eAAe/zB,KAAKswB,uBAEpB,KAAAO,uBAAuBmD,YAAYF,EAAe,EAAC,MAIxD9zB,KAAK6wB,uBAAuBmD,YAAYh0B,KAAKswB,sBAAuB,GAMxEtwB,KAAK6wB,uBAAuBmD,YAAYhB,EAAM1zB,OAAQ,GACtDU,KAAK6wB,uBAAuBmD,YAAYhB,EAAM1zB,OAAOE,MAAO,GAErD4T,EAAAtP,OAAO,GAAK9D,KAAK6wB,uBAExBjvB,EAAS2C,QAAQC,KAAK,CAClBjD,SAAU+tB,EACV5tB,OAAQ0R,EACR3O,MAAO2O,EAAOvR,OACd4F,SAAU,kBAIV7F,EAASpD,OAAS6H,EAAAA,EAAaC,OAE/B1E,EAASuoB,aAAakI,kBAC1B,CAUIJ,oBAAAA,CACJjB,EACA5kB,EACAxK,EACA+vB,GAMA,GAFAX,EAAWjB,YAAc3wB,EAAAA,EAAQC,MAE7B2xB,EAAWhB,cACf,CACIpuB,EAASuoB,aAAakI,mBAGtB,MAAMlI,EAAevoB,EAASuoB,aAAa8J,gBAAgBjD,EAAWf,qBAEtEe,EAAWjB,YAAc/vB,KAAKyyB,eAAetI,EAAc/d,EAAQulB,GAAoBvlB,OAAM,CAMjG4kB,EAAWlB,aAAehH,EAAAA,EAAY4C,kBAClCtf,EAAO1M,MACP0M,EAAOzM,OACPqxB,EAAWhgB,WACXggB,EAAWO,WAGf3vB,EAASuoB,aAAaG,KAAK0G,EAAWlB,cAAc,GAGpDluB,EAASmC,eAAe8V,KAAK,CACzBhU,OAAQuG,GACX,CAYG4lB,qBAAAA,CACJhB,EACAe,EACA/Y,EACA6Y,EACAqC,EACAC,GAGA,MAAMjE,EAAcc,EAAWd,YAE/BA,EAAYrrB,EAAIktB,EAAUF,EAC1B3B,EAAYprB,EAAIkU,EAAU6Y,EAC1B3B,EAAYxwB,MAAQw0B,EAAcrC,EAClC3B,EAAYvwB,OAASw0B,EAAetC,CAAA,CAchCwB,qBAAAA,CACJL,EACAC,EACAjC,EACAe,EACA/Y,EACAhI,EACAkiB,EACA1U,GAGM,MAAApe,EAAWJ,KAAKswB,sBAAsBlwB,SACtCg0B,EAAch0B,EAASswB,aACvB2D,EAAYj0B,EAASmwB,WACrB+D,EAAal0B,EAASowB,YACtB+D,EAAan0B,EAASqwB,YACtBP,EAAc9vB,EAASuwB,aACvB4B,EAAgBnyB,EAASwwB,eAG3BsC,GAEAkB,EAAY,GAAKpD,EAAW5kB,OAAOiV,KAAO0Q,EAC1CqC,EAAY,GAAKpD,EAAW5kB,OAAOmV,KAAOvI,IAI1Cob,EAAY,GAAK,EACjBA,EAAY,GAAK,GAGTA,EAAA,GAAKpB,EAAM1tB,MAAM5F,MACjB00B,EAAA,GAAKpB,EAAM1tB,MAAM3F,OAEnB00B,EAAA,GAAKrB,EAAM1zB,OAAOI,MAClB20B,EAAA,GAAKrB,EAAM1zB,OAAOK,OAC5B00B,EAAU,GAAK,EAAIA,EAAU,GAC7BA,EAAU,GAAK,EAAIA,EAAU,GAElBC,EAAA,GAAKtB,EAAM1zB,OAAOk1B,WAClBF,EAAA,GAAKtB,EAAM1zB,OAAOm1B,YAC7BH,EAAW,GAAK,EAAMA,EAAW,GACjCA,EAAW,GAAK,EAAMA,EAAW,GAEjCC,EAAW,GAAK,GAAMD,EAAW,GACjCC,EAAW,GAAK,GAAMD,EAAW,GACtBC,EAAA,GAAMvB,EAAM1tB,MAAM5F,MAAQ20B,EAAU,GAAO,GAAMC,EAAW,GAC5DC,EAAA,GAAMvB,EAAM1tB,MAAM3F,OAAS00B,EAAU,GAAO,GAAMC,EAAW,GAExE,MAAMI,EAAc10B,KAAK4B,SAASuoB,aAAagJ,iBAAiB/B,aAEpDlB,EAAA,GAAK6B,EAAU/gB,EACfkf,EAAA,GAAKlX,EAAUhI,EAC3Bkf,EAAY,GAAKwE,EAAYp1B,OAAOI,MAAQsR,EAC5Ckf,EAAY,GAAKwE,EAAYp1B,OAAOK,OAASqR,EAGzCiiB,aAAkB7zB,EAAAA,IAAS6zB,EAAO3zB,OAAOkX,SAAW,MAGxD,MAAM2T,EAAenqB,KAAK4B,SAASuoB,aAAa8J,gBAAgBhB,GAEhEjzB,KAAK4B,SAASuoB,aAAaG,KAAK2I,IAAUzU,GAEtCyU,aAAkB7zB,EAAAA,GAEJmzB,EAAA,GAAKU,EAAO3tB,MAAM5F,MAClB6yB,EAAA,GAAKU,EAAO3tB,MAAM3F,SAKlB4yB,EAAA,GAAKpI,EAAazqB,MAClB6yB,EAAA,GAAKpI,EAAaxqB,QAGpC4yB,EAAc,GAAKpI,EAAawK,QAAc,IAE9C30B,KAAKswB,sBAAsBjrB,QAAO,CAQ9BysB,qBAAAA,CAAsBT,GAEtB,IAAAuD,EAAe50B,KAAKowB,kBAAoB,EAE5C,KAAOwE,EAAe,GAAK50B,KAAKqwB,aAAauE,GAAc/E,QAErD+E,EAGN,OAAOA,EAAe,GAAK50B,KAAKqwB,aAAauE,GAAc9E,aACrD9vB,KAAKqwB,aAAauE,GAAc9E,aAAaxwB,OAAO0hB,YACpDqQ,CAAA,CAOF+B,yBAAAA,GAEJ,IAAIrB,EAAU,EACV/Y,EAAU,EACV6b,EAAY70B,KAAKowB,kBAErB,KAAOyE,EAAY,GACnB,CACIA,IACM,MAAAC,EAAiB90B,KAAKqwB,aAAawE,GAErC,IAACC,EAAejF,KACpB,CACIkC,EAAU+C,EAAe1oB,OAAOiV,KAChCrI,EAAU8b,EAAe1oB,OAAOmV,KAChC,MACJ,CAGJ,MAAO,CAAE1c,EAAGktB,EAASjtB,EAAGkU,EAAQ,CAQ5BwY,oBAAAA,CAAqBnC,EAAgCjjB,GA6BzD,GAxBIijB,EAAY0F,YCjxBR,SAA0BA,EAA2B3oB,GAEjEA,EAAOoS,QAMP,MAAMwW,EAAa5oB,EAAOxM,OAE1B,IAAK,IAAI6N,EAAI,EAAGA,EAAIsnB,EAAY/uB,OAAQyH,IACxC,CACU,MAAAvL,EAAa6yB,EAAYtnB,GAE3BvL,EAAW0d,oBAAsB,IAKrCxT,EAAOxM,OAASsC,EAAWwxB,eACpBtnB,EAAA6oB,UAAU/yB,EAAWkK,QAAM,CAGtCA,EAAOxM,OAASo1B,CAGpB,CDyvBsCE,CAAA7F,EAAY0F,YAAa3oB,GAG9CijB,EAAYP,aAAaqG,YAE9B/oB,EAAOoS,QAGApS,EAAA+lB,QAAQ9C,EAAYP,aAAaqG,YAGjC/oB,EAAAnG,YAAYopB,EAAY5P,UAAUiU,iBAQ7BrE,EAAA5P,UAAU2V,qBAAoB,EAAMhpB,GAGhDijB,EAAY5P,UAChB,CAII,MACM4V,GADchG,EAAY5P,UAAUyB,aAAemO,EAAY5P,UAAU0B,mBACtCwS,sBAErC0B,GAEAjpB,EAAOnG,YAAYovB,EACvB,CACJ,CAGI/C,sBAAAA,CAAuBtB,EAAwBxS,GAEnD,MAAMsR,EAAekB,EAAWlB,aAE1B1jB,EAAS4kB,EAAW5kB,OAEpB0d,EAAUkH,EAAWlH,QAUvB,GAHJ9pB,KAAK6wB,uBAAuBmD,YAAYlE,EAAaxwB,OAAOE,MAAO,GACnEQ,KAAK6wB,uBAAuBmD,YAAYhD,EAAWjB,YAAYzwB,OAAQ,GAEhD,IAAnBwqB,EAAQ9jB,OAGR8jB,EAAQ,GAAGwL,MAAMt1B,KAAM8vB,EAAckB,EAAWf,oBAAqBzR,OAGzE,CACI,IAAI+W,EAAOvE,EAAWlB,aAEtB,MAAM0F,EAAc1M,EAAAA,EAAY4C,kBAC5Btf,EAAO1M,MACP0M,EAAOzM,OACP41B,EAAKj2B,OAAO0hB,aACZ,GAIJ,IAAIyU,EAAOD,EAEP/nB,EAAI,EAGR,IAAKA,EAAI,EAAGA,EAAIqc,EAAQ9jB,OAAS,IAAKyH,EACtC,CACmBqc,EAAQrc,GAEhB6nB,MAAMt1B,KAAMu1B,EAAME,GAAM,GAC/B,MAAMC,EAAIH,EAEHA,EAAAE,EACAA,EAAAC,CAAA,CAGX5L,EAAQrc,GAAG6nB,MAAMt1B,KAAMu1B,EAAMvE,EAAWf,oBAAqBzR,GAG7DsK,EAAAA,EAAYC,cAAcyM,EAAW,CACzC,CAGI/D,sBAAAA,CACJT,EACA2E,EACArE,EACAD,EAKAuE,GAGA,MAAMh0B,EAAW5B,KAAK4B,SAEhBwK,EAAS4kB,EAAW5kB,OACpB0d,EAAUkH,EAAWlH,QAM3B,IAAI9Y,EAAa6kB,IAEbljB,EAAU,EAEV4e,GAAY,EAEZvB,GAAgB,EAEhB8F,GAAU,EAEVC,GAAiB,EAErB,IAAK,IAAItoB,EAAI,EAAGA,EAAIqc,EAAQ9jB,OAAQyH,IACpC,CACU,MAAA2F,EAAS0W,EAAQrc,GAEVuD,EAAAwD,KAAK5L,IAAIoI,EAAkC,YAAtBoC,EAAOpC,WACnCqgB,EAAiBje,EAAOpC,YAC9B2B,GAAWS,EAAOT,QAEO,QAArBS,EAAOme,UAEKA,GAAA,EAEc,YAArBne,EAAOme,WAEEA,IAAAA,EAAAD,GAGble,EAAO2iB,iBAESA,GAAA,GAKrB,OAFwB3iB,EAAO4iB,oBAAsBp0B,EAASpD,MAG9D,CACcs3B,GAAA,EACV,MAGJ,GAAI1iB,EAAO4c,iBAAoBpuB,EAA2Bq0B,YAAYC,eAAiB,GACvF,EAGI/Z,EAAAA,EAAAA,GAAK,wHAGK2Z,GAAA,EACV,MAGJA,EAAU1iB,EAAO0iB,SAAWA,EAC5B9F,IAAAA,EAAkB5c,EAAO4c,cAAA,CAIxB8F,GAUDC,GAEO3pB,EAAA+pB,UAAU,EAAGR,EAASj2B,MAAQ2xB,EAAgB,EAAGsE,EAASh2B,OAAS0xB,GAI9EjlB,EACK1G,MAAMsL,GACNyD,OACA/O,MAAM,EAAIsL,GACV4Y,KAAe,EAAVjX,GAAeijB,GAIpBxpB,EAAOgqB,YAeZpF,EAAWO,UAAYA,EACvBP,EAAWhgB,WAAaA,EACxBggB,EAAWhB,cAAgBA,GAfvBgB,EAAWnB,MAAO,GAxBlBmB,EAAWnB,MAAO,CAuCK,CAGvB2C,cAAAA,GAIG,OAFF,KAAApC,oBAEEpwB,KAAKqwB,aAAarwB,KAAKowB,kBAAiB,CAG3CwB,sBAAAA,GAEA,IAAAD,EAEA7rB,EAAQ9F,KAAKowB,kBAAoB,EAErC,KAAOtqB,EAAQ,IAEXA,IACqB6rB,EAAA3xB,KAAKqwB,aAAavqB,GAElC6rB,EAAmB9B,QAMrB,OAAA8B,CAAA,CAGHV,eAAAA,GAEJ,IAAID,EAAahxB,KAAKqwB,aAAarwB,KAAKowB,mBASjC,OAPFY,IAEDA,EAAahxB,KAAKqwB,aAAarwB,KAAKowB,mBAAqB,IAAIR,GAG5D,KAAAQ,oBAEEY,CAAA,EAt4BFb,EAGKvpB,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcoiB,YACdpiB,EAAAA,GAAcqiB,cAElBpsB,KAAM,UEvJdmK,EAAAA,GAAWrD,IAAIusB,GACflpB,EAAAA,GAAWrD,IAAIirB,E,+BCAR,MAAMwH,EAEFxyB,OAAAA,CAAQyyB,EAA8C7W,GAEzD,MAAMhb,EAAQ6xB,EAAsB7xB,MAC9B7C,EAAW00B,EAAsB10B,SACjCF,EAAS+d,EAAU/d,QAAU40B,EAAsBC,cAElD70B,EAAA5C,UAAUK,SAAWsgB,EAAU1f,QAAQuE,QACvC5C,EAAA5C,UAAUsB,SAAWk2B,EAAsBv3B,cAElD,MAAMy3B,EAAK50B,EAAS40B,GAEd9G,EAAS4G,EAAsBG,WAAWhX,GAGvC7d,EAAAF,OAAO4oB,KAAK5oB,GACZE,EAAA6C,MAAMpE,IAAIoE,GACnB7C,EAASL,SAAS+oB,KAAKoF,EAAOnuB,SAAUG,EAAOhE,WAE/C,MACMg5B,EAAsB,IADXhH,EAAOnuB,SAASkrB,YAAY3kB,KAAK6uB,kBAClBH,EAAGI,eAAiBJ,EAAGK,aAEpDL,EAAAM,aAAaN,EAAGO,UAA+C,EAApCtX,EAAUuX,iBAAiBhxB,OAAY0wB,EAAQ,EAAC,E,uGCpBtE,SAAAO,EACZlxB,GAGJ,IAFImxB,EAAA9nB,UAAApJ,OAAA,QAAA2K,IAAAvB,UAAA,GAAAA,UAAA,GAA8C,KAI9C,MAAM+nB,EAAsB,EAAPpxB,EAYjB,GATAoxB,EAAe,MAEDD,IAAAA,EAAA,IAAI/1B,YAAYg2B,IAIhBD,IAAAA,EAAA,IAAIE,YAAYD,IAG9BD,EAAUlxB,SAAWmxB,EAErB,MAAM,IAAI1a,MAAM,uCAAuCya,EAAUlxB,uBAAuBmxB,KAInF,QAAA1pB,EAAI,EAAGoI,EAAI,EAAGpI,EAAI0pB,EAAc1pB,GAAK,EAAGoI,GAAK,EAExCqhB,EAAAzpB,EAAI,GAAKoI,EAAI,EACbqhB,EAAAzpB,EAAI,GAAKoI,EAAI,EACbqhB,EAAAzpB,EAAI,GAAKoI,EAAI,EACbqhB,EAAAzpB,EAAI,GAAKoI,EAAI,EACbqhB,EAAAzpB,EAAI,GAAKoI,EAAI,EACbqhB,EAAAzpB,EAAI,GAAKoI,EAAI,EAGpB,OAAAqhB,CACX,CCpBA,SAASG,EACLC,EACAC,GAGA,MAAMC,EAA0B,GAEhCA,EAAc3d,KAAK,sIAUnB,IAAIhU,EAAS,EAEb,IAAK,MAAM4H,KAAK6pB,EAChB,CACU,MAAAG,EAAWH,EAAW7pB,GAE5B,GAAI8pB,IAAYE,EAASF,QAAS,SAEpBC,EAAA3d,KAAK,oBAAoBhU,KAEzB2xB,EAAA3d,KAAK4d,EAASC,MAI5B7xB,IAFsB8xB,EAAAA,EAAAA,GAA2BF,EAAS9H,QAElC/pB,OAAS,EAGrC4xB,EAAc3d,KAAK,uDAMnB2d,EAAcI,QAAQ,0BACH/xB,YAGb,MAAAgyB,EAAiBL,EAAcxgB,KAAK,MAG1C,OAAO,IAAI8gB,SAAS,KAAM,OAAQ,OAAQD,EAC9C,CCzCO,MAAME,EA2BTl6B,WAAAA,CAAYiM,GARZ,KAAQkuB,MAAQ,EAGhB,KAAiBC,6BAGZ,CAAC,EAKF,MAAMlyB,EAAO/F,KAAKg4B,MAAQluB,EAAQ/D,MAAQ,IAGpCuxB,EAAaxtB,EAAQwtB,WAG3B,IAAIY,EAAmB,EACnBC,EAAoB,EAExB,IAAK,MAAM1qB,KAAK6pB,EAChB,CACU,MAAAG,EAAWH,EAAW7pB,GACtB2qB,GAAgBT,EAAAA,EAAAA,GAA2BF,EAAS9H,QAEtD8H,EAASF,QAGTY,GAAqBC,EAAcxyB,OAKnCsyB,GAAoBE,EAAcxyB,MACtC,CAGJ5F,KAAKq4B,eAAiBF,EAAoB,EAC1Cn4B,KAAKs4B,cAAgBJ,EAAmB,EAExCl4B,KAAKu4B,sBAAwB,IAAIC,EAAAA,EAAsB,EAAPzyB,EAAWmyB,GAC3Dl4B,KAAKy4B,uBAAyB,IAAID,EAAAA,EAAsB,EAAPzyB,EAAWoyB,GAEvD,KAAA1L,YAAcwK,EAAsBlxB,GAInC,MAAAxE,EAAW,IAAIguB,EAAAA,EAErB,IAAImJ,EAAgB,EAChBC,EAAe,EAEd,KAAAC,cAAgB,IAAIC,EAAAA,EAAO,CAC5B/wB,KAAM,IAAIpJ,aAAa,GACvBo6B,MAAO,yBACPC,aAAa,EACbC,MAAOC,EAAAA,EAAYC,OAASD,EAAAA,EAAYE,WAGvC,KAAAC,eAAiB,IAAIP,EAAAA,EAAO,CAC7B/wB,KAAM,IAAIpJ,aAAa,GACvBo6B,MAAO,0BACPC,aAAa,EACbC,MAAOC,EAAAA,EAAYC,OAASD,EAAAA,EAAYE,WAG5C,IAAK,MAAM1rB,KAAK6pB,EAChB,CACU,MAAAG,EAAWH,EAAW7pB,GACtB2qB,GAAgBT,EAAAA,EAAAA,GAA2BF,EAAS9H,QAEtD8H,EAASF,SAEAh2B,EAAA83B,aAAa5B,EAAS6B,cAAe,CAC1C5J,OAAQ1vB,KAAKo5B,eACbxzB,OAA8B,EAAtB5F,KAAKq4B,eACbxyB,OAAwB,EAAhB6yB,EACR/I,OAAQ8H,EAAS9H,SAErB+I,GAAiBN,EAAcryB,OAItBxE,EAAA83B,aAAa5B,EAAS6B,cAAe,CAC1C5J,OAAQ1vB,KAAK44B,cACbhzB,OAA6B,EAArB5F,KAAKs4B,cACbzyB,OAAuB,EAAf8yB,EACRhJ,OAAQ8H,EAAS9H,SAErBgJ,GAAgBP,EAAcryB,KAClC,CAGKxE,EAAAg4B,SAASv5B,KAAKysB,aAEjB,MAAA+M,EAAiBx5B,KAAKy5B,kBAAkBnC,GAE9Ct3B,KAAK05B,eAAiBF,EAAeG,cACrC35B,KAAK45B,cAAgBJ,EAAeK,aAEpC75B,KAAKuB,SAAWA,CAAA,CAGbk4B,iBAAAA,CAAkBnC,GAEf,MAAAzb,EA6Dd,SAA4Byb,GAExB,MAAMwC,EAAmB,GAEzB,IAAK,MAAMje,KAAOyb,EAClB,CACU,MAAAG,EAAWH,EAAWzb,GAE5Bie,EAAOjgB,KAAKgC,EAAK4b,EAASC,KAAMD,EAASF,QAAU,IAAM,IAAG,CAGzD,OAAAuC,EAAO9iB,KAAK,IACvB,CAzEoB+iB,CAAmBzC,GAE3B,OAAAt3B,KAAKi4B,6BAA6Bpc,KAKtC7b,KAAKi4B,6BAA6Bpc,GAAO7b,KAAKg6B,uBAAuB1C,IAH1Dt3B,KAAKi4B,6BAA6Bpc,EAKD,CAGzCme,sBAAAA,CAAuB1C,GAE1B,ODzJD,SAAwCA,GAEpC,OACHqC,cAAetC,EAAuBC,GAAY,GAClDuC,aAAcxC,EAAuBC,GAAY,GAEzD,CCmJe2C,CAA+B3C,EAAU,CAG7CjyB,MAAAA,CAAO60B,EAAwBC,GAI9BD,EAAUl0B,OAAShG,KAAKg4B,QAETmC,GAAA,EAEV,KAAAnC,MAAQxjB,KAAK3L,IAAIqxB,EAAUl0B,OAAsB,IAAbhG,KAAKg4B,MAAe,GAExD,KAAAO,sBAAwB,IAAIC,EAAAA,EAAex4B,KAAKg4B,MAAQh4B,KAAKs4B,cAAgB,EAAI,GACjF,KAAAG,uBAAyB,IAAID,EAAAA,EAAex4B,KAAKg4B,MAAQh4B,KAAKq4B,eAAiB,EAAI,GACnF,KAAA5L,YAAcwK,EAAsBj3B,KAAKg4B,OAE9Ch4B,KAAKuB,SAASkrB,YAAY2N,gBACtBp6B,KAAKysB,YAAazsB,KAAKysB,YAAY4N,YAAY,IAGvD,MAAM5B,EAAyBz4B,KAAKy4B,uBAOpC,GALAz4B,KAAK05B,eAAeQ,EAAWzB,EAAuB6B,YAAa7B,EAAuB8B,YAE1Fv6B,KAAKo5B,eAAegB,gBAChBp6B,KAAKy4B,uBAAuB6B,YAAaJ,EAAUl0B,OAAShG,KAAKq4B,eAAiB,GAAG,GAErF8B,EACJ,CACI,MAAM5B,EAAwBv4B,KAAKu4B,sBAEnCv4B,KAAK45B,cAAcM,EAAW3B,EAAsB+B,YAAa/B,EAAsBgC,YAEvFv6B,KAAK44B,cAAcwB,gBACf7B,EAAsB+B,YAAaJ,EAAUl0B,OAAShG,KAAKs4B,cAAgB,GAAG,EAAI,CAC1F,CAGG72B,OAAAA,GAEHzB,KAAK44B,cAAcn3B,UACnBzB,KAAKo5B,eAAe33B,UACpBzB,KAAKuB,SAASE,SAAQ,E,+2CCvMvB,MAAM+4B,UAAuB58B,EAAAA,EAEhCC,WAAAA,GAkBU,OACFH,UAjBc+8B,EAAAA,EAAUld,KAAK,CAC7BxgB,O,89BACAQ,S,kLAgBAE,WAbei9B,EAAAA,EAAWnd,KAAK,CAC/BhgB,SAAU,CACN+B,OAAQq7B,EACRC,WAAY,gBAEhB79B,OAAQ,CACJuC,OAAQq7B,EACRC,WAAY,gBAOhB97B,UAAW,CAEPK,SAAUC,EAAAA,EAAQ+S,MAAM7S,OAExBC,SAAU,IAAIuT,EAAAA,EAAa,IAE3B1S,SAAU,CACNy6B,mBAAoB,CAAEv8B,MAAO,IAAIC,EAAAA,EAAUC,KAAM,eACjDS,OAAQ,CAAEX,MAAO,IAAIiZ,EAAAA,EAAM,UAAW/Y,KAAM,aAC5CU,OAAQ,CAAEZ,MAAO,EAAGE,KAAM,OAC1Bs8B,YAAa,CAAEx8B,MAAO,CAAC,EAAG,GAAIE,KAAM,gBAG/C,ECvBF,MAAMu8B,EAwBTl9B,WAAAA,CAAY+D,EAAoBgL,GAhBhB,KAAAnI,MAAQ3C,EAAAA,EAAM6H,QAKd,KAAA5K,cAAgB,IAAIX,EAAAA,EAAa,CAC7Cy8B,mBAAoB,CAAEv8B,MAAO,IAAIC,EAAAA,EAAUC,KAAM,eACjDS,OAAQ,CAAEX,MAAO,IAAII,aAAa,GAAIF,KAAM,aAC5CU,OAAQ,CAAEZ,MAAO,EAAGE,KAAM,OAC1Bs8B,YAAa,CAAEx8B,MAAO,CAAC,EAAG,GAAIE,KAAM,eASpCwB,KAAK4B,SAAWA,EAEhB5B,KAAK4M,QAAUA,EAEV,KAAA2pB,cAAgB,IAAIiE,EAEpB,KAAA/1B,MAAQ3C,EAAAA,EAAM6H,OAAM,CAGtB1H,kBAAAA,CAAmB+4B,GAGf,SAGJt4B,aAAAA,CAAcR,EAA+BU,GAEhD5C,KAAK4B,SAASkB,YAAYC,MAAMW,MAAMd,GACtCA,EAAegB,IAAI1B,EAAU,CAG1Bu0B,UAAAA,CAAWv0B,GAEP,OAAAA,EAAW6C,SAAS/E,KAAK4B,SAASoD,MAAQhF,KAAKi7B,YAAY/4B,EAAU,CAGxE+4B,WAAAA,CAAY/4B,GAOhB,OALAA,EAAW6C,SAAS/E,KAAK4B,SAASoD,KAAO,IAAI+yB,EAAe,CACxDhyB,KAAM7D,EAAW80B,iBAAiBhxB,OAClCsxB,WAAYp1B,EAAWg5B,cAGpBh5B,EAAW6C,SAAS/E,KAAK4B,SAASoD,IAAG,CAGzCrB,gBAAAA,CAAiBq3B,GACxB,CAKOn3B,OAAAA,CAAQ4b,GAEX,MAAM0b,EAAW1b,EAAUuX,iBAEvB,GAAoB,IAApBmE,EAASn1B,OAET,OAGJ,MAAMpE,EAAW5B,KAAK4B,SAChB8tB,EAAS1vB,KAAKy2B,WAAWhX,GAE/BA,EAAU1f,UAAV0f,EAAU1f,QAAYo7B,EAAS,GAAGp7B,SAElC,MAAM0E,EAAQzE,KAAKyE,MAEZirB,EAAArqB,OAAO81B,EAAU1b,EAAU2b,gBAClC3b,EAAU2b,gBAAiB,EAE3B32B,EAAMN,WAAYC,EAAAA,EAAAA,GAA0Bqb,EAAUtb,UAAWsb,EAAU1f,QAAQuE,SAE7E,MAAAlE,EAAWJ,KAAKjB,cAAcqB,SAE9Bi7B,EAAuBj7B,EAASy6B,mBAE5Bpb,EAAAiU,eAAevlB,OAAOktB,GAEhCA,EAAqBzH,QAAQhyB,EAASmC,eAAeu3B,kBAAkBC,kBAE9Dn7B,EAAA06B,YAAcl5B,EAASmC,eAAeu3B,kBAAkBtqB,WACxD5Q,EAAAlB,OAAS0C,EAAS4B,aAAeic,EAAUjc,cAEpDS,EAAAA,EAAAA,GACIwb,EAAUvb,gBACV9D,EAASnB,OACT,GAGC,KAAA2N,QAAQ/I,QAAQ7D,KAAMyf,EAAS,CAIjChe,OAAAA,GAECzB,KAAKu2B,gBAELv2B,KAAKu2B,cAAc90B,UACnBzB,KAAKu2B,cAAgB,KACzB,EClID,MAAMiF,UAAgCT,EAUzCl9B,WAAAA,CAAY+D,GAEF,MAAAA,EAAU,IAAIy0B,EAA4B,EAZ3CmF,EAGK50B,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcC,YAElBhK,KAAM,YCbP,MAAM2+B,EAEF53B,OAAAA,CAAQyyB,EAA8C7W,GAEzD,MAAM7d,EAAW00B,EAAsB10B,SAEjCF,EAAS+d,EAAU/d,QAAU40B,EAAsBC,cAElD70B,EAAAoC,OAAO,GAAKlC,EAASkB,YAAY+wB,aAAa6H,oBAAoBpF,EAAsBv3B,eAAe,GAE9G2C,EAAOoC,OAAO,GAAKlC,EAAS7B,QAAQ47B,oBAAoBlc,EAAU1f,SAElE,MAAM0E,EAAQ6xB,EAAsB7xB,MAE9BirB,EAAS4G,EAAsBG,WAAWhX,GAEhD7d,EAAS2C,QAAQC,KAAK,CAClBjD,SAAUmuB,EAAOnuB,SACjBG,OAAQ+d,EAAU/d,QAAU40B,EAAsBC,cAClD9xB,QACAsB,KAA0C,EAApC0Z,EAAUuX,iBAAiBhxB,QACpC,ECfF,MAAM41B,UAAiCb,EAU1Cl9B,WAAAA,CAAY+D,GAEF,MAAAA,EAAU,IAAI65B,EAA6B,EAZ5CG,EAGKh1B,UAAY,CACtBpI,KAAM,CACFqI,EAAAA,GAAcE,aAElBjK,KAAM,YCXdmK,EAAAA,GAAWrD,IAAI43B,GACfv0B,EAAAA,GAAWrD,IAAIg4B,E,gDCOC,SAAA7a,EAAiB4N,EAAkCvW,GAEzD,cAAErY,EAASqM,OAAAA,GAAWuiB,EACtBhc,EAAUyF,EAAK3F,OAAOopB,oBAQXC,EAAAA,EAAAA,GAAA1vB,EAAQgM,EAAKyG,QAAS9e,GAKvC,MAAMg8B,EAAgB3jB,EAAKyG,QAAQC,GAAKnM,EAAU,EAC5CqpB,EAAiB5jB,EAAKyG,QAAQE,GAAKpM,EAAU,EAEnDvG,EAAOiV,MAAQ1O,EAAUopB,EACzB3vB,EAAOmV,MAAQ5O,EAAUqpB,EACzB5vB,EAAOkV,MAAQ3O,EAAUopB,EACzB3vB,EAAOoV,MAAQ7O,EAAUqpB,CAC7B,C,iBChBgB,SAAA/3B,EAAoBg4B,EAAchZ,EAAmBpd,GAE3D,MAAAqM,GAAU+pB,GAAQ,GAAM,KAAQ,IAEtChZ,EAAIpd,MAAqB,IAAPo2B,GAAe,IAAO/pB,EACxC+Q,EAAIpd,MAAeo2B,GAAQ,EAAK,KAAQ,IAAO/pB,EAC/C+Q,EAAIpd,MAAeo2B,GAAQ,GAAM,KAAQ,IAAO/pB,EAChD+Q,EAAIpd,KAAYqM,CACpB,C,8FCEO,MAAMgqB,EAAN,MAAMA,UAAqB3M,EAAAA,EAe9B1xB,WAAAA,GAEI,IAAIiM,GAAUsF,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,KAAW,CAAC,EAEtBtF,aAAmBpL,gBAGnB2R,EAAAA,EAAAA,IAAYC,EAAAA,GAAQ,6DAGVxG,EAAA,CACN9I,UAAW8I,EACX7I,IAAAmO,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,GACAlO,QAAAkO,UAAApJ,QAAA,OAAA2K,EAAAvB,UAAA,KAIRtF,EAAU,IAAKoyB,EAAaxqB,kBAAmB5H,GAE/C,MAAM9I,EAAY8I,EAAQ9I,WAAa,IAAItC,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAE9E,IAAIuC,EAAM6I,EAAQ7I,IAEbA,IAISA,EAFN6I,EAAQ9I,UAEF,IAAItC,aAAasC,EAAUgF,QAI3B,IAAItH,aAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KAIrD,MAAMwC,EAAU4I,EAAQ5I,SAAW,IAAIC,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,IAE7D43B,EAAcjvB,EAAQqyB,mBAuBtB,OACF3M,WAAY,CACRC,UAAW,CACPC,OAxBW,IAAImJ,EAAAA,EAAO,CAC9B/wB,KAAM9G,EACN83B,MAAO,2BACPC,cACAC,MAAOC,EAAAA,EAAYC,OAASD,EAAAA,EAAYE,WAqBhCxJ,OAAQ,YACR/pB,OAAQ,EACRC,OAAQ,GAEZu2B,IAAK,CACD1M,OAvBK,IAAImJ,EAAAA,EAAO,CACxB/wB,KAAM7G,EACN63B,MAAO,qBACPC,cACAC,MAAOC,EAAAA,EAAYC,OAASD,EAAAA,EAAYE,WAoBhCxJ,OAAQ,YACR/pB,OAAQ,EACRC,OAAQ,IAGhB4mB,YAtBgB,IAAIoM,EAAAA,EAAO,CAC3B/wB,KAAM5G,EACN43B,MAAO,oBACPC,cACAC,MAAOC,EAAAA,EAAYoD,MAAQpD,EAAAA,EAAYE,WAmBvC1xB,SAAUqC,EAAQrC,WApF1B,KAAO60B,UAAuB,OAyF9B,aAAIt7B,GAEO,OAAAhB,KAAKwvB,WAAWC,UAAUC,OAAO5nB,IAAA,CAS5C,aAAI9G,CAAU1C,GAEL,KAAAkxB,WAAWC,UAAUC,OAAO5nB,KAAOxJ,CAAA,CAI5C,OAAI2C,GAEO,OAAAjB,KAAKwvB,WAAW4M,IAAI1M,OAAO5nB,IAAA,CAStC,OAAI7G,CAAI3C,GAEC,KAAAkxB,WAAW4M,IAAI1M,OAAO5nB,KAAOxJ,CAAA,CAItC,WAAI4C,GAEA,OAAOlB,KAAKysB,YAAY3kB,IAAA,CAG5B,WAAI5G,CAAQ5C,GAER0B,KAAKysB,YAAY3kB,KAAOxJ,CAAA,GAzInB49B,EAEKxqB,eAAsC,CAChDjK,SAAU,gBACV00B,oBAAoB,GAJrB,IAAMp7B,EAANm7B,C","sources":["../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/tilingBit.ts","../node_modules/pixi.js/src/scene/sprite-tiling/shader/TilingSpriteShader.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/QuadGeometry.ts","../node_modules/pixi.js/src/scene/sprite-tiling/TilingSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setUvs.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/applyMatrix.ts","../node_modules/pixi.js/src/scene/sprite-tiling/utils/setPositions.ts","../node_modules/pixi.js/src/scene/sprite-tiling/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/BatchableMesh.ts","../node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts","../node_modules/pixi.js/src/app/ResizePlugin.ts","../node_modules/pixi.js/src/app/TickerPlugin.ts","../node_modules/pixi.js/src/app/init.ts","../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts","../node_modules/pixi.js/src/scene/graphics/shared/GraphicsPipe.ts","../node_modules/pixi.js/src/scene/graphics/init.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/shader-bits/mSDFBit.ts","../node_modules/pixi.js/src/scene/text/sdfShader/SdfShader.ts","../node_modules/pixi.js/src/scene/text-bitmap/AbstractBitmapFont.ts","../node_modules/pixi.js/src/scene/text-bitmap/DynamicBitmapFont.ts","../node_modules/pixi.js/src/scene/text-bitmap/utils/getBitmapTextLayout.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapFontManager.ts","../node_modules/pixi.js/src/scene/text-bitmap/utils/resolveCharacters.ts","../node_modules/pixi.js/src/scene/text-bitmap/BitmapTextPipe.ts","../node_modules/pixi.js/src/scene/text-bitmap/init.ts","../node_modules/pixi.js/src/scene/text-html/BatchableHTMLText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextPipe.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextRenderData.ts","../node_modules/pixi.js/src/scene/text-html/utils/textStyleToCSS.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextStyle.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontCSS.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadFontAsBase64.ts","../node_modules/pixi.js/src/scene/text-html/utils/getFontCss.ts","../node_modules/pixi.js/src/scene/text-html/utils/measureHtmlText.ts","../node_modules/pixi.js/src/scene/text-html/HTMLTextSystem.ts","../node_modules/pixi.js/src/scene/text-html/utils/extractFontFamilies.ts","../node_modules/pixi.js/src/scene/text-html/utils/getSVGUrl.ts","../node_modules/pixi.js/src/scene/text-html/utils/loadSVGImage.ts","../node_modules/pixi.js/src/utils/browser/isSafari.ts","../node_modules/pixi.js/src/scene/text-html/utils/getTemporaryCanvasFromImage.ts","../node_modules/pixi.js/src/scene/text-html/init.ts","../node_modules/pixi.js/src/scene/text/canvas/BatchableText.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextPipe.ts","../node_modules/pixi.js/src/scene/text/canvas/CanvasTextSystem.ts","../node_modules/pixi.js/src/scene/text/init.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshPipe.ts","../node_modules/pixi.js/src/scene/mesh/init.ts","../node_modules/pixi.js/src/scene/text/utils/getPo2TextureFromSource.ts","../node_modules/pixi.js/src/scene/mesh-plane/PlaneGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceGeometry.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/NineSliceSpritePipe.ts","../node_modules/pixi.js/src/scene/sprite-nine-slice/init.ts","../node_modules/pixi.js/src/filters/FilterPipe.ts","../node_modules/pixi.js/src/filters/FilterSystem.ts","../node_modules/pixi.js/src/scene/container/bounds/getRenderableBounds.ts","../node_modules/pixi.js/src/filters/init.ts","../node_modules/pixi.js/src/scene/particle-container/gl/GlParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/createIndicesForQuads.ts","../node_modules/pixi.js/src/scene/particle-container/shared/utils/generateParticleUpdateFunction.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleBuffer.ts","../node_modules/pixi.js/src/scene/particle-container/shared/shader/ParticleShader.ts","../node_modules/pixi.js/src/scene/particle-container/shared/ParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GlParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/gpu/GpuParticleContainerAdaptor.ts","../node_modules/pixi.js/src/scene/particle-container/shared/GpuParticleContainerPipe.ts","../node_modules/pixi.js/src/scene/particle-container/init.ts","../node_modules/pixi.js/src/scene/text/utils/updateTextBounds.ts","../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts","../node_modules/pixi.js/src/scene/mesh/shared/MeshGeometry.ts"],"sourcesContent":["/** @internal */\nexport const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\n/** @internal */\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\n/** @internal */\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n","/** @internal */\nexport const tilingBit = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;\n\n            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct TilingUniforms {\n                uMapCoord:mat3x3<f32>,\n                uClampFrame:vec4<f32>,\n                uClampOffset:vec2<f32>,\n                uTextureTransform:mat3x3<f32>,\n                uSizeAnchor:vec4<f32>\n            };\n\n            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;\n            @group(2) @binding(1) var uTexture: texture_2d<f32>;\n            @group(2) @binding(2) var uSampler: sampler;\n        `,\n        main: /* wgsl */`\n\n            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);\n            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;\n            var unclamped = coord;\n            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);\n\n            var bias = 0.;\n\n            if(unclamped.x == coord.x && unclamped.y == coord.y)\n            {\n                bias = -32.;\n            }\n\n            outColor = textureSampleBias(uTexture, uSampler, coord, bias);\n        `\n    }\n\n};\n\n/** @internal */\nexport const tilingBitGl = {\n    name: 'tiling-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureTransform;\n            uniform vec4 uSizeAnchor;\n\n        `,\n        main: /* glsl */`\n            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;\n\n            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;\n        `\n\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform sampler2D uTexture;\n            uniform mat3 uMapCoord;\n            uniform vec4 uClampFrame;\n            uniform vec2 uClampOffset;\n        `,\n        main: /* glsl */`\n\n        vec2 coord = vUV + ceil(uClampOffset - vUV);\n        coord = (uMapCoord * vec3(coord, 1.0)).xy;\n        vec2 unclamped = coord;\n        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0\n\n        `\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit, localUniformBitGl } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { tilingBit, tilingBitGl } from './tilingBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/**\n * The shader used by the TilingSprite.\n * @internal\n */\nexport class TilingSpriteShader extends Shader\n{\n    constructor()\n    {\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBit,\n                tilingBit,\n                roundPixelsBit,\n            ],\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'tiling-sprite-shader',\n            bits: [\n                localUniformBitGl,\n                tilingBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        const tilingUniforms = new UniformGroup({\n            uMapCoord: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uClampFrame: { value: new Float32Array([0, 0, 1, 1]), type: 'vec4<f32>' },\n            uClampOffset: { value: new Float32Array([0, 0]), type: 'vec2<f32>' },\n            uTextureTransform: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uSizeAnchor: { value: new Float32Array([100, 100, 0.5, 0.5]), type: 'vec4<f32>' },\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: new UniformGroup({\n                    uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n                    uRound: { value: 0, type: 'f32' },\n                }),\n                tilingUniforms,\n                uTexture: Texture.EMPTY.source,\n                uSampler: Texture.EMPTY.source.style,\n            }\n        });\n    }\n\n    public updateUniforms(\n        width: number, height: number,\n        matrix: Matrix,\n        anchorX: number, anchorY: number,\n        texture: Texture\n    ): void\n    {\n        const tilingUniforms = this.resources.tilingUniforms;\n\n        const textureWidth = texture.width;\n        const textureHeight = texture.height;\n        const textureMatrix = texture.textureMatrix;\n\n        const uTextureTransform = tilingUniforms.uniforms.uTextureTransform;\n\n        uTextureTransform.set(\n            matrix.a * textureWidth / width,\n            matrix.b * textureWidth / height,\n            matrix.c * textureHeight / width,\n            matrix.d * textureHeight / height,\n            matrix.tx / width,\n            matrix.ty / height);\n\n        uTextureTransform.invert();\n\n        tilingUniforms.uniforms.uMapCoord = textureMatrix.mapCoord;\n        tilingUniforms.uniforms.uClampFrame = textureMatrix.uClampFrame;\n        tilingUniforms.uniforms.uClampOffset = textureMatrix.uClampOffset;\n        tilingUniforms.uniforms.uTextureTransform = uTextureTransform;\n        tilingUniforms.uniforms.uSizeAnchor[0] = width;\n        tilingUniforms.uniforms.uSizeAnchor[1] = height;\n        tilingUniforms.uniforms.uSizeAnchor[2] = anchorX;\n        tilingUniforms.uniforms.uSizeAnchor[3] = anchorY;\n\n        if (texture)\n        {\n            this.resources.uTexture = texture.source;\n            this.resources.uSampler = texture.source.style;\n        }\n    }\n}\n","import { MeshGeometry } from '../../mesh/shared/MeshGeometry';\n\n/** @internal */\nexport class QuadGeometry extends MeshGeometry\n{\n    constructor()\n    {\n        super({\n            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            indices: new Uint32Array([0, 1, 2, 0, 2, 3]),\n        });\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { getAdjustedBlendModeBlend } from '../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../rendering/renderers/shared/state/State';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { color32BitToUniform } from '../graphics/gpu/colorToUniform';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\nimport { TilingSpriteShader } from './shader/TilingSpriteShader';\nimport { QuadGeometry } from './utils/QuadGeometry';\nimport { setPositions } from './utils/setPositions';\nimport { setUvs } from './utils/setUvs';\n\nimport type { WebGLRenderer } from '../../rendering/renderers/gl/WebGLRenderer';\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { TilingSprite } from './TilingSprite';\n\nconst sharedQuad = new QuadGeometry();\n\n/** @internal */\nexport class TilingSpriteGpuData\n{\n    public canBatch: boolean = true;\n    public renderable: TilingSprite;\n    public batchableMesh?: BatchableMesh;\n    public geometry?: MeshGeometry;\n    public shader?: TilingSpriteShader;\n\n    constructor()\n    {\n        this.geometry = new MeshGeometry({\n            indices: sharedQuad.indices.slice(),\n            positions: sharedQuad.positions.slice(),\n            uvs: sharedQuad.uvs.slice(),\n        });\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n        this.shader?.destroy();\n    }\n}\n\n/**\n * The TilingSpritePipe is a render pipe for rendering TilingSprites.\n * It handles the batching and rendering of TilingSprites using a shader.\n * @internal\n */\nexport class TilingSpritePipe implements RenderPipe<TilingSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'tilingSprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _state: State = State.default2d;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(renderable: TilingSprite): boolean\n    {\n        const tilingSpriteData = this._getTilingSpriteData(renderable);\n\n        const couldBatch = tilingSpriteData.canBatch;\n\n        this._updateCanBatch(renderable);\n\n        const canBatch = tilingSpriteData.canBatch;\n\n        if (canBatch && canBatch === couldBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                renderable.texture\n            );\n        }\n\n        return (couldBatch !== canBatch);\n\n        // // TODO - only update if required?\n        // // only texture\n        // // only uvs\n        // // only positions?\n    }\n\n    public addRenderable(tilingSprite: TilingSprite, instructionSet: InstructionSet)\n    {\n        const batcher = this._renderer.renderPipes.batch;\n\n        // init\n        this._updateCanBatch(tilingSprite);\n\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry, canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            tilingSpriteData.batchableMesh ||= new BatchableMesh();\n\n            const batchableMesh = tilingSpriteData.batchableMesh;\n\n            if (tilingSprite.didViewUpdate)\n            {\n                this._updateBatchableMesh(tilingSprite);\n\n                batchableMesh.geometry = geometry;\n                batchableMesh.renderable = tilingSprite;\n                batchableMesh.transform = tilingSprite.groupTransform;\n                batchableMesh.setTexture(tilingSprite._texture);\n            }\n\n            batchableMesh.roundPixels = (this._renderer._roundPixels | tilingSprite._roundPixels) as 0 | 1;\n\n            batcher.addToBatch(batchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            tilingSpriteData.shader ||= new TilingSpriteShader();\n\n            this.updateRenderable(tilingSprite);\n\n            instructionSet.add(tilingSprite);\n        }\n    }\n\n    public execute(tilingSprite: TilingSprite)\n    {\n        const { shader } = this._getTilingSpriteData(tilingSprite);\n\n        shader.groups[0] = this._renderer.globalUniforms.bindGroup;\n\n        // deal with local uniforms...\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = tilingSprite.groupTransform;\n        localUniforms.uRound = this._renderer._roundPixels | tilingSprite._roundPixels;\n\n        color32BitToUniform(\n            tilingSprite.groupColorAlpha,\n            localUniforms.uColor,\n            0\n        );\n\n        this._state.blendMode = getAdjustedBlendModeBlend(tilingSprite.groupBlendMode, tilingSprite.texture._source);\n\n        this._renderer.encoder.draw({\n            geometry: sharedQuad,\n            shader,\n            state: this._state,\n        });\n    }\n\n    public updateRenderable(tilingSprite: TilingSprite)\n    {\n        const tilingSpriteData = this._getTilingSpriteData(tilingSprite);\n\n        const { canBatch } = tilingSpriteData;\n\n        if (canBatch)\n        {\n            const { batchableMesh } = tilingSpriteData;\n\n            if (tilingSprite.didViewUpdate) this._updateBatchableMesh(tilingSprite);\n\n            batchableMesh._batcher.updateElement(batchableMesh);\n        }\n        else if (tilingSprite.didViewUpdate)\n        {\n            const { shader } = tilingSpriteData;\n            // now update uniforms...\n\n            shader.updateUniforms(\n                tilingSprite.width,\n                tilingSprite.height,\n                tilingSprite._tileTransform.matrix,\n                tilingSprite.anchor.x,\n                tilingSprite.anchor.y,\n                tilingSprite.texture,\n            );\n        }\n    }\n\n    private _getTilingSpriteData(renderable: TilingSprite): TilingSpriteGpuData\n    {\n        return renderable._gpuData[this._renderer.uid] || this._initTilingSpriteData(renderable);\n    }\n\n    private _initTilingSpriteData(tilingSprite: TilingSprite): TilingSpriteGpuData\n    {\n        const gpuData = new TilingSpriteGpuData();\n\n        gpuData.renderable = tilingSprite;\n        tilingSprite._gpuData[this._renderer.uid] = gpuData;\n\n        return gpuData;\n    }\n\n    private _updateBatchableMesh(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n\n        const { geometry } = renderableData;\n\n        const style = tilingSprite.texture.source.style;\n\n        if (style.addressMode !== 'repeat')\n        {\n            style.addressMode = 'repeat';\n            style.update();\n        }\n\n        setUvs(tilingSprite, geometry.uvs);\n        setPositions(tilingSprite, geometry.positions);\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n\n    private _updateCanBatch(tilingSprite: TilingSprite)\n    {\n        const renderableData = this._getTilingSpriteData(tilingSprite);\n        const texture = tilingSprite.texture;\n\n        let _nonPowOf2wrapping = true;\n\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            _nonPowOf2wrapping = (this._renderer as WebGLRenderer).context.supports.nonPowOf2wrapping;\n        }\n\n        renderableData.canBatch = texture.textureMatrix.isSimple && (_nonPowOf2wrapping || texture.source.isPowerOfTwo);\n\n        return renderableData.canBatch;\n    }\n}\n\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { applyMatrix } from './applyMatrix';\n\nimport type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param uvs\n * @internal\n */\nexport function setUvs(tilingSprite: TilingSprite, uvs: Float32Array)\n{\n    const texture = tilingSprite.texture;\n\n    const width = texture.frame.width;\n    const height = texture.frame.height;\n\n    let anchorX = 0;\n    let anchorY = 0;\n\n    if (tilingSprite.applyAnchorToTexture)\n    {\n        anchorX = tilingSprite.anchor.x;\n        anchorY = tilingSprite.anchor.y;\n    }\n\n    uvs[0] = uvs[6] = -anchorX;\n    uvs[2] = uvs[4] = 1 - anchorX;\n    uvs[1] = uvs[3] = -anchorY;\n    uvs[5] = uvs[7] = 1 - anchorY;\n\n    const textureMatrix = Matrix.shared;\n\n    textureMatrix.copyFrom(tilingSprite._tileTransform.matrix);\n\n    textureMatrix.tx /= tilingSprite.width;\n    textureMatrix.ty /= tilingSprite.height;\n\n    textureMatrix.invert();\n\n    textureMatrix.scale(tilingSprite.width / width, tilingSprite.height / height);\n\n    applyMatrix(uvs, 2, 0, textureMatrix);\n}\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { TypedArray } from '../../../rendering/renderers/shared/buffer/Buffer';\n\n/**\n * @param array\n * @param stride\n * @param offset\n * @param matrix\n * @internal\n */\nexport function applyMatrix(array: TypedArray, stride: number, offset: number, matrix: Matrix)\n{\n    let index = 0;\n    const size = array.length / (stride || 2);\n\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n\n    offset *= stride;\n\n    while (index < size)\n    {\n        const x = array[offset];\n        const y = array[offset + 1];\n\n        array[offset] = (a * x) + (c * y) + tx;\n        array[offset + 1] = (b * x) + (d * y) + ty;\n\n        offset += stride;\n\n        index++;\n    }\n}\n","import type { TilingSprite } from '../TilingSprite';\n\n/**\n * @param tilingSprite\n * @param positions\n * @internal\n */\nexport function setPositions(tilingSprite: TilingSprite, positions: Float32Array)\n{\n    const anchorX = tilingSprite.anchor.x;\n    const anchorY = tilingSprite.anchor.y;\n\n    positions[0] = -anchorX * tilingSprite.width;\n    positions[1] = -anchorY * tilingSprite.height;\n    positions[2] = (1 - anchorX) * tilingSprite.width;\n    positions[3] = -anchorY * tilingSprite.height;\n    positions[4] = (1 - anchorX) * tilingSprite.width;\n    positions[5] = (1 - anchorY) * tilingSprite.height;\n    positions[6] = -anchorX * tilingSprite.width;\n    positions[7] = (1 - anchorY) * tilingSprite.height;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { TilingSpritePipe } from './TilingSpritePipe';\n\nextensions.add(TilingSpritePipe);\n","import type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableMeshElement } from '../../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { MeshGeometry } from './MeshGeometry';\n\n/**\n * A batchable mesh object.\n * @ignore\n */\nexport class BatchableMesh implements DefaultBatchableMeshElement\n{\n    public batcherName = 'default';\n\n    public _topology: Topology;\n\n    public readonly packAsQuad = false;\n    public location: number;\n\n    public renderable: ViewContainer;\n\n    public indexOffset = 0;\n    public attributeOffset = 0;\n\n    public texture: Texture;\n    public geometry: MeshGeometry;\n    public transform: Matrix;\n    public roundPixels: 0 | 1 = 0;\n\n    public _attributeStart: number;\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n    public _indexStart: number;\n    public _textureId: number;\n    public _textureMatrixUpdateId: number = -1;\n\n    private _transformedUvs: Float32Array;\n    private _uvUpdateId: number = -1;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n\n    get topology() { return this._topology || this.geometry.topology; }\n    set topology(value: Topology) { this._topology = value; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.geometry = null;\n        this._uvUpdateId = -1;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    /**\n     * Sets the texture for the batchable mesh.\n     * As it does so, it resets the texture matrix update ID.\n     * this is to ensure that the texture matrix is recalculated when the uvs are referenced\n     * @param value - The texture to set.\n     */\n    public setTexture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this.texture = value;\n        this._textureMatrixUpdateId = -1;\n    }\n\n    get uvs()\n    {\n        const geometry = this.geometry;\n\n        const uvBuffer = geometry.getBuffer('aUV');\n\n        const uvs = uvBuffer.data;\n\n        let transformedUvs = uvs;\n        const textureMatrix = this.texture.textureMatrix;\n\n        if (!textureMatrix.isSimple)\n        {\n            transformedUvs = this._transformedUvs;\n\n            if (this._textureMatrixUpdateId !== textureMatrix._updateID || this._uvUpdateId !== uvBuffer._updateID)\n            {\n                if (!transformedUvs || transformedUvs.length < uvs.length)\n                {\n                    transformedUvs = this._transformedUvs = new Float32Array(uvs.length);\n                }\n\n                this._textureMatrixUpdateId = textureMatrix._updateID;\n                this._uvUpdateId = uvBuffer._updateID;\n\n                textureMatrix.multiplyUvs(uvs as Float32Array, transformedUvs);\n            }\n        }\n\n        return transformedUvs as Float32Array;\n    }\n\n    get positions()\n    {\n        return this.geometry.positions;\n    }\n\n    get indices()\n    {\n        return this.geometry.indices;\n    }\n\n    get color()\n    {\n        return this.renderable.groupColorAlpha;\n    }\n\n    get groupTransform()\n    {\n        return this.renderable.groupTransform;\n    }\n\n    get attributeSize()\n    {\n        return this.geometry.positions.length / 2;\n    }\n\n    get indexSize()\n    {\n        return this.geometry.indices.length;\n    }\n}\n","import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link GlStateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @category rendering\n * @advanced\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    /** @internal */\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { Renderer } from '../rendering/renderers/types';\n\ntype ResizeableRenderer = Pick<Renderer, 'resize'>;\n\n/**\n * Application options for the {@link ResizePlugin}.\n * These options control how your application handles window and element resizing.\n * @example\n * ```ts\n * // Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Auto-resize to container element\n * await app.init({ resizeTo: document.querySelector('#game') });\n * ```\n * @category app\n * @standard\n */\nexport interface ResizePluginOptions\n{\n    /**\n     * Element to automatically resize the renderer to.\n     * @example\n     * ```ts\n     * const app = new Application();\n     * await app.init({\n     *     resizeTo: window, // Resize to the entire window\n     *     // or\n     *     resizeTo: document.querySelector('#game-container'), // Resize to a specific element\n     *     // or\n     *     resizeTo: null, // Disable auto-resize\n     * });\n     * ```\n     * @default null\n     */\n    resizeTo?: Window | HTMLElement;\n}\n\n/**\n * Middleware for Application's resize functionality. This plugin handles automatic\n * and manual resizing of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `resizeTo`: Set an element to automatically resize to\n * - `resize`: Manually trigger a resize\n * - `queueResize`: Queue a resize for the next animation frame\n * - `cancelResize`: Cancel a queued resize\n * @example\n * ```ts\n * import { Application, ResizePlugin } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Auto-resize to window\n * await app.init({ resizeTo: window });\n *\n * // Example 2: Auto-resize to specific element\n * const container = document.querySelector('#game-container');\n * await app.init({ resizeTo: container });\n *\n * // Example 3: Change resize target at runtime\n * app.resizeTo = window;                    // Enable auto-resize to window\n * app.resizeTo = null;                      // Disable auto-resize\n * ```\n * @category app\n * @standard\n */\nexport class ResizePlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    /** @internal */\n    public static resizeTo: Window | HTMLElement;\n    /** @internal */\n    public static resize: () => void;\n    /** @internal */\n    public static renderer: ResizeableRenderer;\n    /** @internal */\n    public static queueResize: () => void;\n    /** @internal */\n    public static render: () => void;\n    /** @internal */\n    private static _resizeId: number;\n    /** @internal */\n    private static _resizeTo: Window | HTMLElement;\n    /** @internal */\n    private static _cancelResize: () => void;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options: ResizePluginOptions): void\n    {\n        Object.defineProperty(this, 'resizeTo',\n            {\n                set(dom: Window | HTMLElement)\n                {\n                    globalThis.removeEventListener('resize', this.queueResize);\n                    this._resizeTo = dom;\n                    if (dom)\n                    {\n                        globalThis.addEventListener('resize', this.queueResize);\n                        this.resize();\n                    }\n                },\n                get()\n                {\n                    return this._resizeTo;\n                },\n            });\n\n        this.queueResize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            this._cancelResize();\n\n            // // Throttle resize events per raf\n            this._resizeId = requestAnimationFrame(() => this.resize());\n        };\n\n        this._cancelResize = (): void =>\n        {\n            if (this._resizeId)\n            {\n                cancelAnimationFrame(this._resizeId);\n                this._resizeId = null;\n            }\n        };\n\n        this.resize = (): void =>\n        {\n            if (!this._resizeTo)\n            {\n                return;\n            }\n\n            // clear queue resize\n            this._cancelResize();\n\n            let width: number;\n            let height: number;\n\n            // Resize to the window\n            if (this._resizeTo === globalThis.window)\n            {\n                width = globalThis.innerWidth;\n                height = globalThis.innerHeight;\n            }\n            // Resize to other HTML entities\n            else\n            {\n                const { clientWidth, clientHeight } = this._resizeTo as HTMLElement;\n\n                width = clientWidth;\n                height = clientHeight;\n            }\n\n            this.renderer.resize(width, height);\n            this.render();\n        };\n\n        // On resize\n        this._resizeId = null;\n        this._resizeTo = null;\n        this.resizeTo = options.resizeTo || null;\n    }\n\n    /**\n     * Clean up the ticker, scoped to application\n     * @private\n     */\n    public static destroy(): void\n    {\n        globalThis.removeEventListener('resize', this.queueResize);\n        this._cancelResize();\n        this._cancelResize = null;\n        this.queueResize = null;\n        this.resizeTo = null;\n        this.resize = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Application options for the {@link TickerPlugin}.\n * These options control the animation loop and update cycle of your PixiJS application.\n * @example\n * ```ts\n * import { Application } from 'pixi.js';\n *\n * // Basic setup with default options\n * const app = new Application();\n * await app.init({\n *     autoStart: true,     // Start animation loop automatically\n *     sharedTicker: false  // Use dedicated ticker instance\n * });\n *\n * // Advanced setup with shared ticker\n * const app2 = new Application();\n * await app2.init({\n *     autoStart: false,    // Don't start automatically\n *     sharedTicker: true   // Use global shared ticker\n * });\n *\n * // Start animation when ready\n * app2.start();\n * ```\n * @remarks\n * The ticker is the heart of your application's animation system. It:\n * - Manages the render loop\n * - Provides accurate timing information\n * - Handles frame-based updates\n * - Supports priority-based execution order\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For update priority constants\n * @category app\n * @standard\n */\nexport interface TickerPluginOptions\n{\n    /**\n     * Controls whether the animation loop starts automatically after initialization.\n     * > [!IMPORTANT]\n     * > Setting this to `false` does NOT stop the shared ticker even if `sharedTicker` is `true`.\n     * > You must stop the shared ticker manually if needed.\n     * @example\n     * ```ts\n     * // Auto-start (default behavior)\n     * await app.init({ autoStart: true });\n     *\n     * // Manual start\n     * await app.init({ autoStart: false });\n     * app.start(); // Start when ready\n     * ```\n     * @default true\n     */\n    autoStart?: boolean;\n\n    /**\n     * Controls whether to use the shared global ticker or create a new instance.\n     *\n     * The shared ticker is useful when you have multiple instances that should sync their updates.\n     * However, it has some limitations regarding update order control.\n     *\n     * Update Order:\n     * 1. System ticker (always runs first)\n     * 2. Shared ticker (if enabled)\n     * 3. App ticker (if using own ticker)\n     * @example\n     * ```ts\n     * // Use shared ticker (global instance)\n     * await app.init({ sharedTicker: true });\n     *\n     * // Use dedicated ticker (default)\n     * await app.init({ sharedTicker: false });\n     *\n     * // Access ticker properties\n     * console.log(app.ticker.FPS);    // Current FPS\n     * console.log(app.ticker.deltaMS); // MS since last update\n     * ```\n     * @default false\n     */\n    sharedTicker?: boolean;\n}\n\n/**\n * Middleware for Application's {@link Ticker} functionality. This plugin manages the\n * animation loop and update cycle of your PixiJS application.\n *\n * Adds the following features to {@link Application}:\n * - `ticker`: Access to the application's ticker\n * - `start`: Start the animation loop\n * - `stop`: Stop the animation loop\n * @example\n * ```ts\n * import { Application, TickerPlugin, extensions } from 'pixi.js';\n *\n * // Create application\n * const app = new Application();\n *\n * // Example 1: Basic ticker usage (default autoStart)\n * await app.init({ autoStart: true });      // Starts ticker automatically\n *\n * // Example 2: Manual ticker control\n * await app.init({ autoStart: false });     // Don't start automatically\n * app.start();                              // Start manually\n * app.stop();                               // Stop manually\n *\n * // Example 3: Add custom update logic\n * app.ticker.add((ticker) => {\n *     // Run every frame, delta is the time since last update\n *     sprite.rotation += 0.1 * ticker.deltaTime;\n * });\n *\n * // Example 4: Control update priority\n * import { UPDATE_PRIORITY } from 'pixi.js';\n *\n * app.ticker.add(\n *     (ticker) => {\n *         // Run before normal priority updates\n *     },\n *     null,\n *     UPDATE_PRIORITY.HIGH\n * );\n *\n * // Example 5: One-time update\n * app.ticker.addOnce(() => {\n *     console.log('Runs next frame only');\n * });\n * ```\n * @see {@link Ticker} For detailed ticker functionality\n * @see {@link UPDATE_PRIORITY} For priority constants\n * @category app\n * @standard\n */\nexport class TickerPlugin\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n\n    /** @internal */\n    public static start: () => void;\n    /** @internal */\n    public static stop: () => void;\n    /** @internal */\n    private static _ticker: Ticker;\n    /** @internal */\n    public static ticker: Ticker;\n\n    /**\n     * Initialize the plugin with scope of application instance\n     * @private\n     * @param {object} [options] - See application options\n     */\n    public static init(options?: PixiMixins.ApplicationOptions): void\n    {\n        // Set default\n        options = Object.assign({\n            autoStart: true,\n            sharedTicker: false,\n        }, options);\n\n        // Create ticker setter\n        Object.defineProperty(this, 'ticker',\n            {\n                set(ticker)\n                {\n                    if (this._ticker)\n                    {\n                        this._ticker.remove(this.render, this);\n                    }\n                    this._ticker = ticker;\n                    if (ticker)\n                    {\n                        ticker.add(this.render, this, UPDATE_PRIORITY.LOW);\n                    }\n                },\n                get()\n                {\n                    return this._ticker;\n                },\n            });\n\n        this.stop = (): void =>\n        {\n            this._ticker.stop();\n        };\n\n        this.start = (): void =>\n        {\n            this._ticker.start();\n        };\n\n        this._ticker = null;\n        this.ticker = options.sharedTicker ? Ticker.shared : new Ticker();\n\n        // Start the rendering\n        if (options.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up the ticker, scoped to application.\n     * @private\n     */\n    public static destroy(): void\n    {\n        if (this._ticker)\n        {\n            const oldTicker = this._ticker;\n\n            this.ticker = null;\n            oldTicker.destroy();\n        }\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { ResizePlugin } from './ResizePlugin';\nimport { TickerPlugin } from './TickerPlugin';\n\nextensions.add(ResizePlugin);\nextensions.add(TickerPlugin);\n","import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @internal\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { type Renderer } from '../../../rendering/renderers/types';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { color32BitToUniform } from '../gpu/colorToUniform';\nimport { BatchableGraphics } from './BatchableGraphics';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Graphics } from './Graphics';\nimport type { GpuGraphicsContext } from './GraphicsContextSystem';\n\n/** @internal */\nexport interface GraphicsAdaptor\n{\n    shader: Shader;\n    contextChange(renderer: Renderer): void;\n    execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void;\n    destroy(): void;\n}\n\n/** @internal */\nexport class GraphicsGpuData\n{\n    public batches: BatchableGraphics[] = [];\n    public batched = false;\n    public destroy()\n    {\n        this.batches.forEach((batch) =>\n        {\n            BigPool.return(batch as PoolItem);\n        });\n\n        this.batches.length = 0;\n    }\n}\n\n/** @internal */\nexport class GraphicsPipe implements RenderPipe<Graphics>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public renderer: Renderer;\n    public state: State = State.for2d();\n\n    private _adaptor: GraphicsAdaptor;\n\n    constructor(renderer: Renderer, adaptor: GraphicsAdaptor)\n    {\n        this.renderer = renderer;\n\n        this._adaptor = adaptor;\n\n        this.renderer.runners.contextChange.add(this);\n    }\n\n    public contextChange(): void\n    {\n        this._adaptor.contextChange(this.renderer);\n    }\n\n    public validateRenderable(graphics: Graphics): boolean\n    {\n        // assume context is dirty..\n        const context = graphics.context;\n\n        const wasBatched = !!graphics._gpuData;\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(context);\n\n        if (gpuContext.isBatchable || wasBatched !== gpuContext.isBatchable)\n        {\n            // TODO what if they are the same size??\n            return true;\n        }\n\n        return false;\n    }\n\n    public addRenderable(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // need to get batches here.. as we need to know if we can batch or not..\n        // this also overrides the current batches..\n        if (graphics.didViewUpdate)\n        {\n            this._rebuild(graphics);\n        }\n\n        if (gpuContext.isBatchable)\n        {\n            this._addToBatcher(graphics, instructionSet);\n        }\n        else\n        {\n            this.renderer.renderPipes.batch.break(instructionSet);\n            instructionSet.add(graphics);\n        }\n    }\n\n    public updateRenderable(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const batches = gpuData.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batch._batcher.updateElement(batch);\n        }\n    }\n\n    public execute(graphics: Graphics)\n    {\n        if (!graphics.isRenderable) return;\n\n        const renderer = this.renderer;\n        const context = graphics.context;\n        const contextSystem = renderer.graphicsContext;\n\n        // early out if there is no actual visual stuff...\n        if (!contextSystem.getGpuContext(context).batches.length)\n        { return; }\n\n        const shader = context.customShader || this._adaptor.shader;\n\n        this.state.blendMode = graphics.groupBlendMode;\n\n        const localUniforms = shader.resources.localUniforms.uniforms;\n\n        localUniforms.uTransformMatrix = graphics.groupTransform;\n        localUniforms.uRound = renderer._roundPixels | graphics._roundPixels;\n\n        color32BitToUniform(\n            graphics.groupColorAlpha,\n            localUniforms.uColor,\n            0,\n        );\n\n        this._adaptor.execute(this, graphics);\n    }\n\n    private _rebuild(graphics: Graphics)\n    {\n        const gpuData = this._getGpuDataForRenderable(graphics);\n\n        const gpuContext = this.renderer.graphicsContext.updateGpuContext(graphics.context);\n\n        // free up the batches..\n        gpuData.destroy();\n\n        if (gpuContext.isBatchable)\n        {\n            this._updateBatchesForRenderable(graphics, gpuData);\n        }\n    }\n\n    private _addToBatcher(graphics: Graphics, instructionSet: InstructionSet)\n    {\n        const batchPipe = this.renderer.renderPipes.batch;\n\n        const batches = this._getGpuDataForRenderable(graphics).batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            const batch = batches[i];\n\n            batchPipe.addToBatch(batch, instructionSet);\n        }\n    }\n\n    private _getGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        return graphics._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(graphics);\n    }\n\n    private _initGpuDataForRenderable(graphics: Graphics): GraphicsGpuData\n    {\n        const gpuData = new GraphicsGpuData();\n\n        graphics._gpuData[this.renderer.uid] = gpuData;\n\n        return gpuData;\n    }\n\n    private _updateBatchesForRenderable(graphics: Graphics, gpuData: GraphicsGpuData)\n    {\n        const context = graphics.context;\n\n        const gpuContext: GpuGraphicsContext = this.renderer.graphicsContext.getGpuContext(context);\n\n        const roundPixels = (this.renderer._roundPixels | graphics._roundPixels) as 0 | 1;\n\n        gpuData.batches = gpuContext.batches.map((batch) =>\n        {\n            const batchClone = BigPool.get(BatchableGraphics);\n\n            batch.copyTo(batchClone);\n\n            batchClone.renderable = graphics;\n\n            batchClone.roundPixels = roundPixels;\n\n            return batchClone;\n        });\n    }\n\n    public destroy()\n    {\n        this.renderer = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n        this.state = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GraphicsContextSystem } from './shared/GraphicsContextSystem';\nimport { GraphicsPipe } from './shared/GraphicsPipe';\n\nextensions.add(GraphicsPipe);\nextensions.add(GraphicsContextSystem);\n","// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\n/** @internal */\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */`\n            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));\n        `\n\n    }\n};\n\n/** @internal */\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */`\n            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));\n        `\n\n    }\n};\n","/** @internal */\nexport const mSDFBit = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* wgsl */`\n            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {\n\n                // MSDF\n                var median = msdfColor.r + msdfColor.g + msdfColor.b -\n                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                var screenPxDistance = distance * (median - 0.5);\n                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));\n                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);\n                var coverage: f32 = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n\n            }\n        `,\n    }\n\n};\n\n/** @internal */\nexport const mSDFBitGl = {\n    name: 'msdf-bit',\n    fragment: {\n        header: /* glsl */`\n            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {\n\n                // MSDF\n                float median = msdfColor.r + msdfColor.g + msdfColor.b -\n                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -\n                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));\n\n                // SDF\n                median = min(median, msdfColor.a);\n\n                float screenPxDistance = distance * (median - 0.5);\n                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\n\n                if (median < 0.01) {\n                    alpha = 0.0;\n                } else if (median > 0.99) {\n                    alpha = 1.0;\n                }\n\n                // Gamma correction for coverage-like alpha\n                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));\n                float gamma = mix(1.0, 1.0 / 2.2, luma);\n                float coverage = pow(shapeColor.a * alpha, gamma);\n\n                return coverage;\n            }\n        `,\n    }\n\n};\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport {\n    compileHighShaderGlProgram,\n    compileHighShaderGpuProgram\n} from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport {\n    generateTextureBatchBit,\n    generateTextureBatchBitGl\n} from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../../rendering/renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { localUniformMSDFBit, localUniformMSDFBitGl } from './shader-bits/localUniformMSDFBit';\nimport { mSDFBit, mSDFBitGl } from './shader-bits/mSDFBit';\n\nimport type { GlProgram } from '../../../rendering/renderers/gl/shader/GlProgram';\nimport type { GpuProgram } from '../../../rendering/renderers/gpu/shader/GpuProgram';\n\nlet gpuProgram: GpuProgram;\nlet glProgram: GlProgram;\n\n/** @internal */\nexport class SdfShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const uniforms = new UniformGroup({\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uDistance: { value: 4, type: 'f32' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        gpuProgram ??= compileHighShaderGpuProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                localUniformMSDFBit,\n                mSDFBit,\n                roundPixelsBit\n            ]\n        });\n\n        glProgram ??= compileHighShaderGlProgram({\n            name: 'sdf-shader',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                localUniformMSDFBitGl,\n                mSDFBitGl,\n                roundPixelsBitGl,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                localUniforms: uniforms,\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n","import EventEmitter from 'eventemitter3';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/**\n * @category text\n * @advanced\n */\nexport interface CharData\n{\n    /** Unique id of character */\n    id: number;\n    /** x-offset to apply when rendering character */\n    xOffset: number;\n    /** y-offset to apply when rendering character. */\n    yOffset: number;\n    /** Advancement to apply to next character. */\n    xAdvance: number;\n    /** The kerning values for this character. */\n    kerning: Record<string, number>;\n    /** The texture of the character. */\n    texture?: Texture;\n}\n\n/**\n * The raw data of a character in a bitmap font.\n * @category text\n * @advanced\n */\nexport interface RawCharData extends Omit<CharData, 'texture'>\n{\n    /** The page of the font texture that the character is on. */\n    page: number;\n    /** The x position of the character in the page. */\n    x: number;\n    /** The y position of the character in the page. */\n    y: number;\n    /** The width of the character in the page. */\n    width: number;\n    /** The height of the character in the page. */\n    height: number;\n    /** The letter of the character. */\n    letter: string;\n}\n\n/**\n * The raw data of a bitmap font.\n * @category text\n * @advanced\n */\nexport interface BitmapFontData\n{\n    /** The offset of the font face from the baseline. */\n    baseLineOffset: number;\n    /** The map of characters by character code. */\n    chars: Record<string, RawCharData>;\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    pages: {\n        /** Unique id for bitmap texture */\n        id: number;\n        /** File name */\n        file: string\n    }[];\n    /** The line-height of the font face in pixels. */\n    lineHeight: number;\n    /** The size of the font face in pixels. */\n    fontSize: number;\n    /** The name of the font face. */\n    fontFamily: string;\n    /** The range and type of the distance field for this font. */\n    distanceField?: {\n        /** Type of distance field */\n        type: 'sdf' | 'msdf' | 'none';\n        /** Range of the distance field in pixels */\n        range: number;\n    };\n}\n\ninterface BitmapFontEvents<Type>\n{\n    destroy: [Type];\n}\n\n/**\n * An abstract representation of a bitmap font.\n * @category text\n * @advanced\n */\nexport abstract class AbstractBitmapFont<FontType>\n    extends EventEmitter<BitmapFontEvents<FontType>>\n    implements Omit<BitmapFontData, 'chars' | 'pages' | 'fontSize'>\n{\n    /** The map of characters by character code. */\n    public readonly chars: Record<string, CharData> = Object.create(null);\n\n    /**\n     * The line-height of the font face in pixels.\n     * @type {number}\n     */\n    public readonly lineHeight: BitmapFontData['lineHeight'] = 0;\n\n    /**\n     * The name of the font face\n     * @type {string}\n     */\n    public readonly fontFamily: BitmapFontData['fontFamily'] = '';\n    /** The metrics of the font face. */\n    public readonly fontMetrics: FontMetrics = { fontSize: 0, ascent: 0, descent: 0 };\n    /**\n     * The offset of the font face from the baseline.\n     * @type {number}\n     */\n    public readonly baseLineOffset: BitmapFontData['baseLineOffset'] = 0;\n    /** The range and type of the distance field for this font. */\n    public readonly distanceField: BitmapFontData['distanceField'] = { type: 'none', range: 0 };\n    /** The map of base page textures (i.e., sheets of glyphs). */\n    public readonly pages: { texture: Texture }[] = [];\n    /** should the fill for this font be applied as a tint to the text. */\n    public applyFillAsTint = true;\n\n    /** The size of the font face in pixels. */\n    public readonly baseMeasurementFontSize: number = 100;\n    protected baseRenderedFontSize = 100;\n\n    /**\n     * The name of the font face.\n     * @deprecated since 8.0.0 Use `fontFamily` instead.\n     */\n    public get font(): BitmapFontData['fontFamily']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead.');\n        // #endif\n\n        return this.fontFamily;\n    }\n\n    /**\n     * The map of base page textures (i.e., sheets of glyphs).\n     * @deprecated since 8.0.0 Use `pages` instead.\n     */\n    public get pageTextures(): AbstractBitmapFont<FontType>['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    /**\n     * The size of the font face in pixels.\n     * @deprecated since 8.0.0 Use `fontMetrics.fontSize` instead.\n     */\n    public get size(): BitmapFontData['fontSize']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead.');\n        // #endif\n\n        return this.fontMetrics.fontSize;\n    }\n\n    /**\n     * The kind of distance field for this font or \"none\".\n     * @deprecated since 8.0.0 Use `distanceField.type` instead.\n     */\n    public get distanceFieldRange(): NonNullable<BitmapFontData['distanceField']>['range']\n    {\n        // #if _DEBUG\n        // eslint-disable-next-line max-len\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead.');\n        // #endif\n\n        return this.distanceField.range;\n    }\n\n    /**\n     * The range of the distance field in pixels.\n     * @deprecated since 8.0.0 Use `distanceField.range` instead.\n     */\n    public get distanceFieldType(): NonNullable<BitmapFontData['distanceField']>['type']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead.');\n        // #endif\n\n        return this.distanceField.type;\n    }\n\n    public destroy(destroyTextures = false): void\n    {\n        this.emit('destroy', this as unknown as FontType);\n\n        this.removeAllListeners();\n\n        for (const i in this.chars)\n        {\n            // texture may not exist if the char is \" \", \\n, \\r, or \\t.\n            this.chars[i].texture?.destroy();\n        }\n\n        (this.chars as null) = null;\n\n        if (destroyTextures)\n        {\n            this.pages.forEach((page) => page.texture.destroy(true));\n            (this.pages as any) = null;\n        }\n    }\n}\n","import { Color } from '../../color/Color';\nimport { Rectangle } from '../../maths/shapes/Rectangle';\nimport { CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { ImageSource } from '../../rendering/renderers/shared/texture/sources/ImageSource';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { fontStringFromTextStyle } from '../text/canvas/utils/fontStringFromTextStyle';\nimport { getCanvasFillStyle } from '../text/canvas/utils/getCanvasFillStyle';\nimport { TextStyle } from '../text/TextStyle';\nimport { AbstractBitmapFont } from './AbstractBitmapFont';\n\nimport type { ICanvasRenderingContext2D } from '../../environment/canvas/ICanvasRenderingContext2D';\nimport type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport type { FontMetrics } from '../text/canvas/CanvasTextMetrics';\n\n/** @internal */\nexport interface DynamicBitmapFontOptions\n{\n    style: TextStyle\n    skipKerning?: boolean\n    resolution?: number\n    padding?: number\n    overrideFill?: boolean\n    overrideSize?: boolean\n    textureSize?: number\n    mipmap?: boolean\n    textureStyle?: TextureStyle | TextureStyleOptions\n}\n\n/**\n * A BitmapFont that generates its glyphs dynamically.\n * @category text\n * @internal\n */\nexport class DynamicBitmapFont extends AbstractBitmapFont<DynamicBitmapFont>\n{\n    public static defaultOptions: DynamicBitmapFontOptions = {\n        textureSize: 512,\n        style: new TextStyle(),\n        mipmap: true,\n    };\n    /**\n     * this is a resolution modifier for the font size..\n     * texture resolution will also be used to scale texture according to its font size also\n     */\n    public resolution = 1;\n    /** The pages of the font. */\n    public override readonly pages: {canvasAndContext?: CanvasAndContext, texture: Texture}[] = [];\n\n    private readonly _padding: number = 0;\n    private readonly _measureCache: Record<string, number> = Object.create(null);\n    private _currentChars: string[] = [];\n    private _currentX = 0;\n    private _currentY = 0;\n    private _currentMaxCharHeight = 0;\n    private _currentPageIndex = -1;\n    private readonly _style: TextStyle;\n    private readonly _skipKerning: boolean = false;\n    private readonly _textureSize: number;\n    private readonly _mipmap: boolean;\n    private readonly _textureStyle?: TextureStyle;\n\n    /**\n     * @param options - The options for the dynamic bitmap font.\n     */\n    constructor(options: DynamicBitmapFontOptions)\n    {\n        super();\n\n        const dynamicOptions = { ...DynamicBitmapFont.defaultOptions, ...options };\n\n        this._textureSize = dynamicOptions.textureSize;\n        this._mipmap = dynamicOptions.mipmap;\n\n        const style = dynamicOptions.style.clone();\n\n        if (dynamicOptions.overrideFill)\n        {\n            // assuming no shape fill..\n            style._fill.color = 0xffffff;\n            style._fill.alpha = 1;\n            style._fill.texture = Texture.WHITE;\n            style._fill.fill = null;\n        }\n\n        this.applyFillAsTint = dynamicOptions.overrideFill;\n\n        const requestedFontSize = style.fontSize;\n\n        // adjust font size to match the base measurement size\n        style.fontSize = this.baseMeasurementFontSize;\n\n        const font = fontStringFromTextStyle(style);\n\n        if (dynamicOptions.overrideSize)\n        {\n            if (style._stroke)\n            {\n                // we want the stroke to fit the size of the requested text, so we need to scale it\n                // accordingly (eg font size 20, with stroke 10 - stroke is 50% of size,\n                // as dynamic font is size 100, the stroke should be adjusted to 50 to make it look right)\n                style._stroke.width *= this.baseRenderedFontSize / requestedFontSize;\n            }\n        }\n        else\n        {\n            style.fontSize = this.baseRenderedFontSize = requestedFontSize;\n        }\n\n        this._style = style;\n        this._skipKerning = dynamicOptions.skipKerning ?? false;\n        this.resolution = dynamicOptions.resolution ?? 1;\n        this._padding = dynamicOptions.padding ?? 4;\n\n        if (dynamicOptions.textureStyle)\n        {\n            this._textureStyle = dynamicOptions.textureStyle instanceof TextureStyle\n                ? dynamicOptions.textureStyle\n                : new TextureStyle(dynamicOptions.textureStyle);\n        }\n\n        (this.fontMetrics as FontMetrics) = CanvasTextMetrics.measureFont(font);\n        (this.lineHeight as number) = style.lineHeight || this.fontMetrics.fontSize || style.fontSize;\n    }\n\n    public ensureCharacters(chars: string): void\n    {\n        const charList = CanvasTextMetrics.graphemeSegmenter(chars)\n            .filter((char) => !this._currentChars.includes(char))\n            .filter((char, index, self) => self.indexOf(char) === index);\n        // filter returns..\n\n        if (!charList.length) return;\n\n        this._currentChars = [...this._currentChars, ...charList];\n\n        let pageData;\n\n        if (this._currentPageIndex === -1)\n        {\n            pageData = this._nextPage();\n        }\n        else\n        {\n            pageData = this.pages[this._currentPageIndex];\n        }\n\n        let { canvas, context } = pageData.canvasAndContext;\n        let textureSource = pageData.texture.source;\n\n        const style = this._style;\n\n        let currentX = this._currentX;\n        let currentY = this._currentY;\n        let currentMaxCharHeight = this._currentMaxCharHeight;\n\n        const fontScale = this.baseRenderedFontSize / this.baseMeasurementFontSize;\n        const padding = this._padding * fontScale;\n\n        let skipTexture = false;\n\n        const maxTextureWidth = canvas.width / this.resolution;\n        const maxTextureHeight = canvas.height / this.resolution;\n\n        for (let i = 0; i < charList.length; i++)\n        {\n            const char = charList[i];\n\n            const metrics = CanvasTextMetrics.measureText(char, style, canvas, false);\n\n            // override the line height.. we want this to be the glyps height\n            // not the user specified one.\n            metrics.lineHeight = metrics.height;\n\n            const width = metrics.width * fontScale;\n            // This is ugly - but italics are given more space so they don't overlap\n            const textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n\n            const height = (metrics.height) * fontScale;\n\n            const paddedWidth = textureGlyphWidth + (padding * 2);\n            const paddedHeight = height + (padding * 2);\n\n            skipTexture = false;\n            // don't let empty characters count towards the maxCharHeight\n            if (char !== '\\n' && char !== '\\r' && char !== '\\t' && char !== ' ')\n            {\n                skipTexture = true;\n                currentMaxCharHeight = Math.ceil(Math.max(paddedHeight, currentMaxCharHeight));\n            }\n\n            if (currentX + paddedWidth > maxTextureWidth)\n            {\n                currentY += currentMaxCharHeight;\n\n                // reset the line x and height..\n                currentMaxCharHeight = paddedHeight;\n                currentX = 0;\n\n                if (currentY + currentMaxCharHeight > maxTextureHeight)\n                {\n                    textureSource.update();\n\n                    const pageData = this._nextPage();\n\n                    canvas = pageData.canvasAndContext.canvas;\n                    context = pageData.canvasAndContext.context;\n                    textureSource = pageData.texture.source;\n\n                    currentX = 0;\n                    currentY = 0;\n                    currentMaxCharHeight = 0;\n                }\n            }\n\n            const xAdvance = (width / fontScale)\n                - (style.dropShadow?.distance ?? 0)\n                - (style._stroke?.width ?? 0);\n\n            // This is in coord space of the measurements.. not the texture\n            this.chars[char] = {\n                id: char.codePointAt(0),\n                xOffset: -this._padding,\n                yOffset: -this._padding,\n                xAdvance,\n                kerning: {},\n            };\n\n            if (skipTexture)\n            {\n                this._drawGlyph(\n                    context,\n                    metrics,\n                    currentX + padding,\n                    currentY + padding,\n                    fontScale,\n                    style,\n                );\n\n                const px = textureSource.width * fontScale;\n                const py = textureSource.height * fontScale;\n\n                const frame = new Rectangle(\n                    ((currentX) / px) * textureSource.width,\n                    ((currentY) / py) * textureSource.height,\n                    ((paddedWidth) / px) * textureSource.width,\n                    ((paddedHeight) / py) * textureSource.height,\n                );\n\n                this.chars[char].texture = new Texture({\n                    source: textureSource,\n                    frame,\n                });\n\n                currentX += Math.ceil(paddedWidth);\n            }\n        }\n\n        textureSource.update();\n\n        this._currentX = currentX;\n        this._currentY = currentY;\n        this._currentMaxCharHeight = currentMaxCharHeight;\n\n        // now apply kerning..\n        this._skipKerning && this._applyKerning(charList, context);\n    }\n\n    /**\n     * @deprecated since 8.0.0\n     * The map of base page textures (i.e., sheets of glyphs).\n     */\n    public override get pageTextures(): DynamicBitmapFont['pages']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead.');\n        // #endif\n\n        return this.pages;\n    }\n\n    private _applyKerning(newChars: string[], context: ICanvasRenderingContext2D): void\n    {\n        const measureCache = this._measureCache;\n\n        for (let i = 0; i < newChars.length; i++)\n        {\n            const first = newChars[i];\n\n            for (let j = 0; j < this._currentChars.length; j++)\n            {\n                // first go through new char being first\n                const second = this._currentChars[j];\n\n                let c1 = measureCache[first];\n\n                if (!c1) c1 = measureCache[first] = context.measureText(first).width;\n\n                let c2 = measureCache[second];\n\n                if (!c2) c2 = measureCache[second] = context.measureText(second).width;\n\n                let total = context.measureText(first + second).width;\n                let amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[first].kerning[second] = amount;\n                }\n\n                // then go through new char being second\n                total = context.measureText(first + second).width;\n                amount = total - (c1 + c2);\n\n                if (amount)\n                {\n                    this.chars[second].kerning[first] = amount;\n                }\n            }\n        }\n    }\n\n    private _nextPage(): {canvasAndContext: CanvasAndContext, texture: Texture}\n    {\n        this._currentPageIndex++;\n\n        const textureResolution = this.resolution;\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n            this._textureSize,\n            this._textureSize,\n            textureResolution\n        );\n\n        this._setupContext(canvasAndContext.context, this._style, textureResolution);\n\n        const resolution = textureResolution * (this.baseRenderedFontSize / this.baseMeasurementFontSize);\n        const texture = new Texture({\n            source: new ImageSource({\n                resource: canvasAndContext.canvas,\n                resolution,\n                alphaMode: 'premultiply-alpha-on-upload',\n                autoGenerateMipmaps: this._mipmap,\n            }),\n\n        });\n\n        if (this._textureStyle)\n        {\n            texture.source.style = this._textureStyle;\n        }\n\n        const pageData = {\n            canvasAndContext,\n            texture,\n        };\n\n        this.pages[this._currentPageIndex] = pageData;\n\n        return pageData;\n    }\n\n    // canvas style!\n    private _setupContext(context: ICanvasRenderingContext2D, style: TextStyle, resolution: number): void\n    {\n        style.fontSize = this.baseRenderedFontSize;\n        context.scale(resolution, resolution);\n        context.font = fontStringFromTextStyle(style);\n        style.fontSize = this.baseMeasurementFontSize;\n        context.textBaseline = style.textBaseline;\n\n        const stroke = style._stroke;\n        const strokeThickness = stroke?.width ?? 0;\n\n        if (stroke)\n        {\n            context.lineWidth = strokeThickness;\n            context.lineJoin = stroke.join;\n            context.miterLimit = stroke.miterLimit;\n\n            // TODO prolly cache this??\n            context.strokeStyle = getCanvasFillStyle(stroke, context);\n        }\n\n        if (style._fill)\n        {\n            // set canvas text styles\n            context.fillStyle = getCanvasFillStyle(style._fill, context);\n        }\n\n        if (style.dropShadow)\n        {\n            const shadowOptions = style.dropShadow;\n            const rgb = Color.shared.setValue(shadowOptions.color).toArray();\n\n            const dropShadowBlur = shadowOptions.blur * resolution;\n            const dropShadowDistance = shadowOptions.distance * resolution;\n\n            context.shadowColor = `rgba(${rgb[0] * 255},${rgb[1] * 255},${rgb[2] * 255},${shadowOptions.alpha})`;\n            context.shadowBlur = dropShadowBlur;\n            context.shadowOffsetX = Math.cos(shadowOptions.angle) * dropShadowDistance;\n            context.shadowOffsetY = Math.sin(shadowOptions.angle) * dropShadowDistance;\n        }\n        else\n        {\n            context.shadowColor = 'black';\n            context.shadowBlur = 0;\n            context.shadowOffsetX = 0;\n            context.shadowOffsetY = 0;\n        }\n    }\n\n    private _drawGlyph(\n        context: ICanvasRenderingContext2D,\n        metrics: CanvasTextMetrics,\n        x: number,\n        y: number,\n        fontScale: number,\n        style: TextStyle\n    ): void\n    {\n        const char = metrics.text;\n        const fontProperties = metrics.fontProperties;\n        const stroke = style._stroke;\n\n        const strokeThickness = (stroke?.width ?? 0) * fontScale;\n\n        const tx = x + (strokeThickness / 2);\n        const ty = y - (strokeThickness / 2);\n\n        const descent = fontProperties.descent * fontScale;\n        const lineHeight = metrics.lineHeight * fontScale;\n\n        let removeShadow = false;\n\n        if (style.stroke && strokeThickness)\n        {\n            removeShadow = true;\n            context.strokeText(char, tx, ty + lineHeight - descent);\n        }\n\n        const { shadowBlur, shadowOffsetX, shadowOffsetY } = context;\n\n        if (style._fill)\n        {\n            if (removeShadow)\n            {\n                context.shadowBlur = 0;\n                context.shadowOffsetX = 0;\n                context.shadowOffsetY = 0;\n            }\n            context.fillText(char, tx, ty + lineHeight - descent);\n        }\n\n        if (removeShadow)\n        {\n            context.shadowBlur = shadowBlur;\n            context.shadowOffsetX = shadowOffsetX;\n            context.shadowOffsetY = shadowOffsetY;\n        }\n    }\n\n    public override destroy(): void\n    {\n        super.destroy();\n\n        for (let i = 0; i < this.pages.length; i++)\n        {\n            const { canvasAndContext, texture } = this.pages[i];\n\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n            texture.destroy(true);\n        }\n\n        (this.pages as null) = null;\n    }\n}\n","import type { TextStyle } from '../../text/TextStyle';\nimport type { AbstractBitmapFont } from '../AbstractBitmapFont';\n\n/**\n * The layout data for a bitmap text.\n * This contains the width, height, scale, offsetY and lines of text.\n * Each line contains its width, character positions, characters, space width and spaces index.\n * @category text\n * @internal\n */\nexport interface BitmapTextLayoutData\n{\n    width: number;\n    height: number;\n    scale: number;\n    offsetY: number;\n    lines: {\n        width: number\n        charPositions: number[],\n        chars: string[],\n        // / spaces: number\n        spaceWidth: number\n        spacesIndex: number[]\n    }[];\n}\n\n/**\n * @param chars\n * @param style\n * @param font\n * @param trimEnd\n * @internal\n */\nexport function getBitmapTextLayout(\n    chars: string[],\n    style: TextStyle,\n    font: AbstractBitmapFont<any>,\n    trimEnd: boolean\n): BitmapTextLayoutData\n{\n    const layoutData: BitmapTextLayoutData = {\n        width: 0,\n        height: 0,\n        offsetY: 0,\n        scale: style.fontSize / font.baseMeasurementFontSize,\n        lines: [{\n            width: 0,\n            charPositions: [] as number[],\n            spaceWidth: 0,\n            spacesIndex: [],\n            chars: [],\n        }]\n    };\n\n    layoutData.offsetY = font.baseLineOffset;\n\n    let currentLine = layoutData.lines[0];\n\n    let previousChar: string = null;\n    let firstWord = true;\n    //    let spaceCount = 0;\n\n    const currentWord = {\n        spaceWord: false,\n        width: 0,\n        start: 0,\n        index: 0, // use index to not modify the array as we use it a lot!\n        positions: [] as number[],\n        chars: [] as string[],\n    };\n\n    const nextWord = (word: typeof currentWord) =>\n    {\n        const start = currentLine.width;\n\n        for (let j = 0; j < currentWord.index; j++)\n        {\n            const position = word.positions[j];\n\n            currentLine.chars.push(word.chars[j]);\n            currentLine.charPositions.push(position + start);\n        }\n\n        currentLine.width += word.width;\n\n        firstWord = false;\n\n        // reset the word..\n        currentWord.width = 0;\n        currentWord.index = 0;\n        currentWord.chars.length = 0;\n\n        // spaceCount = 0;\n    };\n\n    const nextLine = () =>\n    {\n        let index = currentLine.chars.length - 1;\n\n        if (trimEnd)\n        {\n            let lastChar = currentLine.chars[index];\n\n            while (lastChar === ' ')\n            {\n                currentLine.width -= font.chars[lastChar].xAdvance;\n                lastChar = currentLine.chars[--index];\n            }\n        }\n\n        layoutData.width = Math.max(layoutData.width, currentLine.width);\n\n        currentLine = {\n            width: 0,\n            charPositions: [],\n            chars: [],\n            spaceWidth: 0,\n            spacesIndex: [],\n        };\n\n        firstWord = true;\n        layoutData.lines.push(currentLine);\n        layoutData.height += font.lineHeight;\n    };\n\n    const scale = font.baseMeasurementFontSize / style.fontSize;\n\n    const adjustedLetterSpacing = style.letterSpacing * scale;\n    const adjustedWordWrapWidth = style.wordWrapWidth * scale;\n\n    const breakWords = style.wordWrap && style.breakWords;\n\n    const checkIsOverflow = (lineWidth: number) =>\n        lineWidth - adjustedLetterSpacing > adjustedWordWrapWidth;\n\n    // loop an extra time to force a line break..\n    for (let i = 0; i < chars.length + 1; i++)\n    {\n        let char: string;\n\n        const isEnd = i === chars.length;\n\n        if (!isEnd)\n        {\n            char = chars[i];\n        }\n\n        const charData = font.chars[char] || font.chars[' '];\n\n        const isSpace = (/(?:\\s)/).test(char);\n        const isWordBreak = isSpace || char === '\\r' || char === '\\n' || isEnd;\n\n        // spaceCount++;\n        // wasSpace = isSpace;\n\n        if (isWordBreak)\n        {\n            const addWordToNextLine = !firstWord && style.wordWrap && checkIsOverflow(currentLine.width + currentWord.width);\n\n            if (addWordToNextLine)\n            {\n                nextLine();\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n            else\n            {\n                currentWord.start = currentLine.width;\n\n                nextWord(currentWord);\n\n                if (!isEnd)\n                {\n                    currentLine.charPositions.push(0);\n                }\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                if (currentLine.width !== 0)\n                {\n                    nextLine();\n                }\n            }\n            else if (!isEnd)\n            {\n                const spaceWidth = charData.xAdvance + (charData.kerning[previousChar] || 0) + adjustedLetterSpacing;\n\n                currentLine.width += spaceWidth;\n\n                currentLine.spaceWidth = spaceWidth;\n                currentLine.spacesIndex.push(currentLine.charPositions.length);\n                currentLine.chars.push(char);\n\n                // spaceCount++;\n            }\n        }\n        else\n        {\n            const kerning = charData.kerning[previousChar] || 0;\n\n            const nextCharWidth = charData.xAdvance + kerning + adjustedLetterSpacing;\n\n            const addWordToNextLine = breakWords && checkIsOverflow(currentLine.width + currentWord.width + nextCharWidth);\n\n            if (addWordToNextLine)\n            {\n                nextWord(currentWord);\n                nextLine();\n            }\n\n            currentWord.positions[currentWord.index++] = currentWord.width + kerning;\n            currentWord.chars.push(char);\n\n            currentWord.width += nextCharWidth;\n        }\n\n        previousChar = char;\n        // lastChar = char;\n    }\n\n    nextLine();\n\n    if (style.align === 'center')\n    {\n        alignCenter(layoutData);\n    }\n    else if (style.align === 'right')\n    {\n        alignRight(layoutData);\n    }\n    else if (style.align === 'justify')\n    {\n        alignJustify(layoutData);\n    }\n\n    return layoutData;\n}\n\nfunction alignCenter(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width / 2) - (line.width / 2));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignRight(measurementData: BitmapTextLayoutData)\n{\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n        const offset = ((measurementData.width) - (line.width));\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            line.charPositions[j] += offset;\n        }\n    }\n}\n\nfunction alignJustify(measurementData: BitmapTextLayoutData)\n{\n    const width = measurementData.width;\n\n    for (let i = 0; i < measurementData.lines.length; i++)\n    {\n        const line = measurementData.lines[i];\n\n        let indy = 0;\n        let spaceIndex = line.spacesIndex[indy++];\n\n        let offset = 0;\n\n        const totalSpaces = line.spacesIndex.length;\n\n        const newSpaceWidth = (width - line.width) / totalSpaces;\n\n        const spaceWidth = newSpaceWidth;\n\n        for (let j = 0; j < line.charPositions.length; j++)\n        {\n            if (j === spaceIndex)\n            {\n                spaceIndex = line.spacesIndex[indy++];\n\n                offset += spaceWidth;\n            }\n\n            line.charPositions[j] += offset;\n        }\n    }\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { type TextureStyle, type TextureStyleOptions } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { warn } from '../../utils/logging/warn';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { TextStyle } from '../text/TextStyle';\nimport { DynamicBitmapFont } from './DynamicBitmapFont';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\nimport { resolveCharacters } from './utils/resolveCharacters';\n\nimport type { TextStyleOptions } from '../text/TextStyle';\nimport type { BitmapFont } from './BitmapFont';\nimport type { BitmapTextLayoutData } from './utils/getBitmapTextLayout';\n\nlet fontCount = 0;\n\n/**\n * The options for installing a new BitmapFont. Once installed, the font will be available\n * for use in BitmapText objects through the fontFamily property of TextStyle.\n * @example\n * ```ts\n * import { BitmapFont, BitmapText } from 'pixi.js';\n *\n * // Basic font installation\n * BitmapFont.install({\n *     name: 'BasicFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 24,\n *         fill: '#ffffff'\n *     }\n * });\n *\n * // Advanced font installation\n * BitmapFont.install({\n *     name: 'AdvancedFont',\n *     style: {\n *         fontFamily: 'Arial',\n *         fontSize: 32,\n *         fill: '#ff0000',\n *         stroke: { color: '#000000', width: 2 }\n *     },\n *     // Include specific character ranges\n *     chars: [\n *         ['a', 'z'],           // lowercase letters\n *         ['A', 'Z'],           // uppercase letters\n *         ['0', '9'],           // numbers\n *         '!@#$%^&*()_+-=[]{}' // symbols\n *     ],\n *     resolution: 2,            // High-DPI support\n *     padding: 4,              // Glyph padding\n *     skipKerning: false,      // Enable kerning\n *     textureStyle: {\n *         scaleMode: 'linear',\n *     }\n * });\n *\n * // Using the installed font\n * const text = new BitmapText({\n *     text: 'Hello World',\n *     style: {\n *         fontFamily: 'AdvancedFont',\n *         fontSize: 48\n *     }\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface BitmapFontInstallOptions\n{\n    /**\n     * The name of the font. This will be used as the fontFamily in text styles to access this font.\n     * Must be unique across all installed bitmap fonts.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'MyCustomFont',\n     *     style: { fontFamily: 'Arial' }\n     * });\n     * ```\n     */\n    name?: string;\n\n    /**\n     * Characters included in the font set. You can specify individual characters or ranges.\n     * Don't forget to include spaces ' ' in your character set!\n     * @default BitmapFont.ALPHANUMERIC\n     * @example\n     * ```ts\n     * // Different ways to specify characters\n     * BitmapFont.install({\n     *     name: 'RangeFont',\n     *     chars: [\n     *         ['a', 'z'],              // Range of characters\n     *         '0123456789',            // String of characters\n     *         [['0', '9'], ['A', 'Z']] // Multiple ranges\n     *     ]\n     * });\n     * ```\n     */\n    chars?: string | (string | string[])[];\n\n    /**\n     * Render resolution for glyphs. Higher values create sharper text at the cost of memory.\n     * Useful for supporting high-DPI displays.\n     * @default 1\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'HiDPIFont',\n     *     resolution: window.devicePixelRatio || 2\n     * });\n     * ```\n     */\n    resolution?: number;\n\n    /**\n     * Padding between glyphs on texture atlas. Balances visual quality with texture space.\n     * - Lower values: More compact, but may have visual artifacts\n     * - Higher values: Better quality, but uses more texture space\n     * @default 4\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'PaddedFont',\n     *     padding: 8 // More padding for better quality\n     * });\n     * ```\n     */\n    padding?: number;\n\n    /**\n     * Skip generation of kerning information for the BitmapFont.\n     * - true: Faster generation, but text may have inconsistent spacing\n     * - false: Better text appearance, but slower generation\n     * @default false\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'FastFont',\n     *     skipKerning: true // Prioritize performance\n     * });\n     * ```\n     */\n    skipKerning?: boolean;\n\n    /**\n     * Style options to render the BitmapFont with.\n     * Supports all TextStyle properties including fill, stroke, and shadow effects.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'StyledFont',\n     *     style: {\n     *         fontFamily: 'Arial',\n     *         fontSize: 32,\n     *         fill: ['#ff0000', '#00ff00'], // Gradient\n     *         stroke: { color: '#000000', width: 2 },\n     *         dropShadow: {\n     *             color: '#000000',\n     *             blur: 2,\n     *             distance: 3\n     *         }\n     *     }\n     * });\n     * ```\n     */\n    style?: TextStyle | TextStyleOptions;\n\n    /**\n     * Optional texture style to use when creating the font textures.\n     * Controls how the font textures are rendered and filtered.\n     * @example\n     * ```ts\n     * BitmapFont.install({\n     *     name: 'CrispFont',\n     *     textureStyle: {\n     *         scaleMode: 'nearest',\n     *     }\n     * });\n     * ```\n     */\n    textureStyle?: TextureStyle | TextureStyleOptions;\n}\n\n/** @advanced */\nclass BitmapFontManagerClass\n{\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.ALPHA })\n     */\n    public readonly ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @type {string[][]}\n     * @example\n     * BitmapFont.from('ExampleFont', style, { chars: BitmapFont.NUMERIC })\n     */\n    public readonly NUMERIC = [['0', '9']];\n\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @type {string[][]}\n     */\n    public readonly ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n\n    /**\n     * This character set consists of all the ASCII table.\n     * @type {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    public readonly ASCII = [[' ', '~']];\n\n    /** Default options for installing a new BitmapFont. */\n    public defaultOptions: Omit<BitmapFontInstallOptions, 'style'> = {\n        chars: this.ALPHANUMERIC,\n        resolution: 1,\n        padding: 4,\n        skipKerning: false,\n        textureStyle: null,\n    };\n\n    /**\n     * Get a font for the specified text and style.\n     * @param text - The text to get the font for\n     * @param style - The style to use\n     */\n    public getFont(text: string, style: TextStyle): BitmapFont\n    {\n        let fontFamilyKey = `${style.fontFamily as string}-bitmap`;\n        let overrideFill = true;\n\n        // assuming there is no texture we can use a tint!\n        if (style._fill.fill && !style._stroke)\n        {\n            fontFamilyKey += style._fill.fill.styleKey;\n            overrideFill = false;\n        }\n        else if (style._stroke || style.dropShadow)\n        {\n            // if there is a stoke, we need to use the style key as this the font generated cannot be tinted\n            // due to the fact the font has at least two colors.\n            let key = style.styleKey;\n\n            // remove the font size..\n            key = key.substring(0, key.lastIndexOf('-'));\n\n            fontFamilyKey = `${key}-bitmap`;\n            overrideFill = false;\n        }\n\n        // first get us the the right font...\n        if (!Cache.has(fontFamilyKey))\n        {\n            const fnt = new DynamicBitmapFont({\n                style,\n                overrideFill,\n                overrideSize: true,\n                ...this.defaultOptions,\n            });\n\n            fontCount++;\n\n            // warn users if they have created too many dynamic fonts\n            if (fontCount > 50)\n            {\n                // eslint-disable-next-line max-len\n                warn('BitmapText', `You have dynamically created ${fontCount} bitmap fonts, this can be inefficient. Try pre installing your font styles using \\`BitmapFont.install({name:\"style1\", style})\\``);\n            }\n\n            fnt.once('destroy', () =>\n            {\n                fontCount--;\n                Cache.remove(fontFamilyKey);\n            });\n\n            Cache.set(\n                fontFamilyKey as string,\n                fnt\n            );\n        }\n\n        const dynamicFont = Cache.get(fontFamilyKey);\n\n        (dynamicFont as DynamicBitmapFont).ensureCharacters?.(text);\n\n        return dynamicFont;\n    }\n\n    /**\n     * Get the layout of a text for the specified style.\n     * @param text - The text to get the layout for\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public getLayout(text: string, style: TextStyle, trimEnd: boolean = true): BitmapTextLayoutData\n    {\n        const bitmapFont = this.getFont(text, style);\n\n        const segments = CanvasTextMetrics.graphemeSegmenter(text);\n\n        return getBitmapTextLayout(segments, style, bitmapFont, trimEnd);\n    }\n\n    /**\n     * Measure the text using the specified style.\n     * @param text - The text to measure\n     * @param style - The style to use\n     * @param trimEnd - Whether to ignore whitespaces at the end of each line\n     */\n    public measureText(\n        text: string,\n        style: TextStyle,\n        trimEnd: boolean = true\n    ): { width: number; height: number; scale: number; offsetY: number }\n    {\n        return this.getLayout(text, style, trimEnd);\n    }\n\n    /**\n     * Generates a bitmap-font for the given style and character set\n     * @param options - Setup options for font generation.\n     * @returns Font generated by style options.\n     * @example\n     * import { BitmapFontManager, BitmapText } from 'pixi.js';\n     *\n     * BitmapFontManager.install('TitleFont', {\n     *     fontFamily: 'Arial',\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: 'purple',\n     * });\n     *\n     * const title = new BitmapText({ text: 'This is the title', fontFamily: 'TitleFont' });\n     */\n    public install(options: BitmapFontInstallOptions): BitmapFont;\n    /** @deprecated since 7.0.0 */\n    public install(name: string, style?: TextStyle | TextStyleOptions, options?: BitmapFontInstallOptions): BitmapFont;\n    // eslint-disable-next-line max-len\n    public install(...args: [string | BitmapFontInstallOptions, (TextStyle | TextStyleOptions)?, BitmapFontInstallOptions?]): BitmapFont\n    {\n        let options = args[0] as BitmapFontInstallOptions;\n\n        if (typeof options === 'string')\n        {\n            options = {\n                name: options,\n                style: args[1],\n                chars: args[2]?.chars,\n                resolution: args[2]?.resolution,\n                padding: args[2]?.padding,\n                skipKerning: args[2]?.skipKerning,\n            } as BitmapFontInstallOptions;\n\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})');\n            // #endif\n        }\n\n        const name = options?.name;\n\n        if (!name)\n        {\n            throw new Error('[BitmapFontManager] Property `name` is required.');\n        }\n\n        options = { ...this.defaultOptions, ...options };\n\n        const textStyle = options.style;\n\n        const style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        const overrideFill = style._fill.fill !== null && style._fill.fill !== undefined;\n        const font = new DynamicBitmapFont({\n            style,\n            overrideFill,\n            skipKerning: options.skipKerning,\n            padding: options.padding,\n            resolution: options.resolution,\n            overrideSize: false,\n            textureStyle: options.textureStyle,\n        });\n\n        const flatChars = resolveCharacters(options.chars);\n\n        font.ensureCharacters(flatChars.join(''));\n\n        Cache.set(`${name}-bitmap`, font);\n\n        font.once('destroy', () => Cache.remove(`${name}-bitmap`));\n\n        return font;\n    }\n\n    /**\n     * Uninstalls a bitmap font from the cache.\n     * @param {string} name - The name of the bitmap font to uninstall.\n     */\n    public uninstall(name: string)\n    {\n        const cacheKey = `${name}-bitmap`;\n        const font = Cache.get<BitmapFont>(cacheKey);\n\n        if (font)\n        {\n            font.destroy();\n        }\n    }\n}\n\n/**\n * The BitmapFontManager is a helper that exists to install and uninstall fonts\n * into the cache for BitmapText objects.\n * @category text\n * @advanced\n * @class\n * @example\n * import { BitmapFontManager, BitmapText } from 'pixi.js';\n *\n * BitmapFontManager.install({\n *   name: 'TitleFont',\n *   style: {}\n * });\n *\n * const title = new BitmapText({ text: 'This is the title', style: { fontFamily: 'TitleFont' }});\n */\nexport const BitmapFontManager = new BitmapFontManagerClass();\n","/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]} the flattened array of characters\n */\nexport function resolveCharacters(chars: string | (string | string[])[]): string[]\n{\n    // Skip unexpected 'empty set' check at end\n    if (chars === '')\n    {\n        return [];\n    }\n\n    // Split the chars string into individual characters\n    if (typeof chars === 'string')\n    {\n        chars = [chars];\n    }\n\n    // Handle an array of characters+ranges\n    const result: string[] = [];\n\n    for (let i = 0, j = chars.length; i < j; i++)\n    {\n        const item = chars[i];\n\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item))\n        {\n            if (item.length !== 2)\n            {\n                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${item.length}.`);\n            }\n            if (item[0].length === 0 || item[1].length === 0)\n            {\n                throw new Error('[BitmapFont]: Invalid character delimiter.');\n            }\n\n            const startCode = item[0].charCodeAt(0);\n            const endCode = item[1].charCodeAt(0);\n\n            if (endCode < startCode)\n            {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n\n            for (let i = startCode, j = endCode; i <= j; i++)\n            {\n                result.push(String.fromCharCode(i));\n            }\n        }\n        else\n        {\n            result.push(...Array.from(item));\n        }\n    }\n\n    if (result.length === 0)\n    {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n\n    return result;\n}\n","import { Cache } from '../../assets/cache/Cache';\nimport { ExtensionType } from '../../extensions/Extensions';\nimport { Graphics } from '../graphics/shared/Graphics';\nimport { CanvasTextMetrics } from '../text/canvas/CanvasTextMetrics';\nimport { SdfShader } from '../text/sdfShader/SdfShader';\nimport { BitmapFontManager } from './BitmapFontManager';\nimport { getBitmapTextLayout } from './utils/getBitmapTextLayout';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../rendering/renderers/shared/Renderable';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { BitmapText } from './BitmapText';\n\n/** @internal */\nexport class BitmapTextGraphics extends Graphics\n{\n    public destroy()\n    {\n        if (this.context.customShader)\n        {\n            this.context.customShader.destroy();\n        }\n\n        super.destroy();\n    }\n}\n\n/** @internal */\nexport class BitmapTextPipe implements RenderPipe<BitmapText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'bitmapText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuBitmapText');\n    }\n\n    public validateRenderable(bitmapText: BitmapText): boolean\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        return this._renderer.renderPipes.graphics.validateRenderable(graphicsRenderable);\n\n        // TODO - need to shift all the verts in the graphicsData to the new anchor\n\n        // update the anchor...\n    }\n\n    public addRenderable(bitmapText: BitmapText, instructionSet: InstructionSet)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        if (bitmapText._didTextUpdate)\n        {\n            bitmapText._didTextUpdate = false;\n\n            this._updateContext(bitmapText, graphicsRenderable);\n        }\n\n        this._renderer.renderPipes.graphics.addRenderable(graphicsRenderable, instructionSet);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    public updateRenderable(bitmapText: BitmapText)\n    {\n        const graphicsRenderable = this._getGpuBitmapText(bitmapText);\n\n        // sync..\n        syncWithProxy(bitmapText, graphicsRenderable);\n\n        this._renderer.renderPipes.graphics.updateRenderable(graphicsRenderable);\n\n        if (graphicsRenderable.context.customShader)\n        {\n            this._updateDistanceField(bitmapText);\n        }\n    }\n\n    private _updateContext(bitmapText: BitmapText, proxyGraphics: Graphics)\n    {\n        const { context } = proxyGraphics;\n\n        const bitmapFont = BitmapFontManager.getFont(bitmapText.text, bitmapText._style);\n\n        context.clear();\n\n        if (bitmapFont.distanceField.type !== 'none')\n        {\n            if (!context.customShader)\n            {\n                // TODO: Check if this is a WebGL renderer before asserting type\n                context.customShader = new SdfShader(this._renderer.limits.maxBatchableTextures);\n            }\n        }\n\n        const chars = CanvasTextMetrics.graphemeSegmenter(bitmapText.text);\n        const style = bitmapText._style;\n\n        let currentY = bitmapFont.baseLineOffset;\n\n        // measure our text...\n        const bitmapTextLayout = getBitmapTextLayout(chars, style, bitmapFont, true);\n\n        const padding = style.padding;\n        const scale = bitmapTextLayout.scale;\n\n        let tx = bitmapTextLayout.width;\n        let ty = bitmapTextLayout.height + bitmapTextLayout.offsetY;\n\n        if (style._stroke)\n        {\n            tx += style._stroke.width / scale;\n            ty += style._stroke.width / scale;\n        }\n\n        context\n            .translate((-bitmapText._anchor._x * tx) - padding, (-bitmapText._anchor._y * ty) - padding)\n            .scale(scale, scale);\n\n        const tint = bitmapFont.applyFillAsTint ? style._fill.color : 0xFFFFFF;\n\n        for (let i = 0; i < bitmapTextLayout.lines.length; i++)\n        {\n            const line = bitmapTextLayout.lines[i];\n\n            for (let j = 0; j < line.charPositions.length; j++)\n            {\n                const char = line.chars[j];\n\n                const charData = bitmapFont.chars[char];\n\n                if (charData?.texture)\n                {\n                    context.texture(\n                        charData.texture,\n                        tint ? tint : 'black',\n                        Math.round(line.charPositions[j] + charData.xOffset),\n                        Math.round(currentY + charData.yOffset),\n                    );\n                }\n            }\n\n            currentY += bitmapFont.lineHeight;\n        }\n    }\n\n    private _getGpuBitmapText(bitmapText: BitmapText)\n    {\n        return bitmapText._gpuData[this._renderer.uid] || this.initGpuText(bitmapText);\n    }\n\n    public initGpuText(bitmapText: BitmapText)\n    {\n        // TODO we could keep a bunch of contexts around and reuse one that has the same style!\n        const proxyRenderable = new BitmapTextGraphics();\n\n        bitmapText._gpuData[this._renderer.uid] = proxyRenderable;\n\n        this._updateContext(bitmapText, proxyRenderable);\n\n        return proxyRenderable;\n    }\n\n    private _updateDistanceField(bitmapText: BitmapText)\n    {\n        const context = this._getGpuBitmapText(bitmapText).context;\n\n        const fontFamily = bitmapText._style.fontFamily as string;\n        const dynamicFont = Cache.get(`${fontFamily as string}-bitmap`);\n\n        // Inject the shader code with the correct value\n        const { a, b, c, d } = bitmapText.groupTransform;\n\n        const dx = Math.sqrt((a * a) + (b * b));\n        const dy = Math.sqrt((c * c) + (d * d));\n        const worldScale = (Math.abs(dx) + Math.abs(dy)) / 2;\n\n        const fontScale = dynamicFont.baseRenderedFontSize / bitmapText._style.fontSize;\n\n        const distance = worldScale * dynamicFont.distanceField.range * (1 / fontScale);\n\n        context.customShader.resources.localUniforms.uniforms.uDistance = distance;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\nfunction syncWithProxy(container: Renderable, proxy: Renderable)\n{\n    proxy.groupTransform = container.groupTransform;\n    proxy.groupColorAlpha = container.groupColorAlpha;\n    proxy.groupColor = container.groupColor;\n    proxy.groupBlendMode = container.groupBlendMode;\n    proxy.globalDisplayStatus = container.globalDisplayStatus;\n    proxy.groupTransform = container.groupTransform;\n    proxy.localDisplayStatus = container.localDisplayStatus;\n    proxy.groupAlpha = container.groupAlpha;\n    proxy._roundPixels = container._roundPixels;\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { BitmapTextPipe } from './BitmapTextPipe';\n\nextensions.add(BitmapTextPipe);\n","import { type Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\n\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The BatchableHTMLText class extends the BatchableSprite class and is used to handle HTML text rendering.\n * It includes a promise for the texture as generating the HTML texture takes some time.\n * @internal\n */\nexport class BatchableHTMLText extends BatchableSprite\n{\n    private readonly _renderer: Renderer;\n    public texturePromise: Promise<Texture>;\n    public generatingTexture = false;\n\n    /**\n     * Creates an instance of BatchableHTMLText.\n     * @param renderer - The renderer instance to be used.\n     */\n    constructor(renderer: Renderer)\n    {\n        super();\n\n        // Next step is to make canvasTextSystem a GLOBAL object.\n        // so this is ok for now..\n        this._renderer = renderer;\n\n        renderer.runners.resolutionChange.add(this);\n    }\n\n    /** Handles resolution changes for the HTML text. If the text has auto resolution enabled, it triggers a view update. */\n    public resolutionChange()\n    {\n        const text = this.renderable as HTMLText;\n\n        if (text._autoResolution)\n        {\n            text.onViewUpdate();\n        }\n    }\n\n    /** Destroys the BatchableHTMLText instance. Returns the texture promise to the renderer and cleans up references. */\n    public destroy()\n    {\n        this._renderer.htmlText.returnTexturePromise(this.texturePromise);\n\n        this.texturePromise = null;\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateTextBounds } from '../text/utils/updateTextBounds';\nimport { BatchableHTMLText } from './BatchableHTMLText';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { HTMLText } from './HTMLText';\n\n/**\n * The HTMLTextPipe class is responsible for rendering HTML text.\n * @internal\n */\nexport class HTMLTextPipe implements RenderPipe<HTMLText>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(htmlText: HTMLText): boolean\n    {\n        return htmlText._didTextUpdate;\n    }\n\n    public addRenderable(htmlText: HTMLText, instructionSet: InstructionSet)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (htmlText._didTextUpdate)\n        {\n            this._updateGpuText(htmlText).catch((e) =>\n            {\n                console.error(e);\n            });\n\n            htmlText._didTextUpdate = false;\n\n            updateTextBounds(batchableHTMLText, htmlText);\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableHTMLText, instructionSet);\n    }\n\n    public updateRenderable(htmlText: HTMLText)\n    {\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        batchableHTMLText._batcher.updateElement(batchableHTMLText);\n    }\n\n    private async _updateGpuText(htmlText: HTMLText)\n    {\n        htmlText._didTextUpdate = false;\n\n        const batchableHTMLText = this._getGpuText(htmlText);\n\n        if (batchableHTMLText.generatingTexture) return;\n\n        if (batchableHTMLText.texturePromise)\n        {\n            this._renderer.htmlText.returnTexturePromise(batchableHTMLText.texturePromise);\n            batchableHTMLText.texturePromise = null;\n        }\n\n        batchableHTMLText.generatingTexture = true;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n\n        const texturePromise = this._renderer.htmlText.getTexturePromise(htmlText);\n\n        batchableHTMLText.texturePromise = texturePromise;\n\n        batchableHTMLText.texture = await texturePromise;\n\n        // need a rerender...\n        const renderGroup = htmlText.renderGroup || htmlText.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            // need a rebuild of the render group\n            renderGroup.structureDidChange = true;\n        }\n\n        batchableHTMLText.generatingTexture = false;\n\n        updateTextBounds(batchableHTMLText, htmlText);\n    }\n\n    private _getGpuText(htmlText: HTMLText)\n    {\n        return htmlText._gpuData[this._renderer.uid] || this.initGpuText(htmlText);\n    }\n\n    public initGpuText(htmlText: HTMLText)\n    {\n        const batchableHTMLText = new BatchableHTMLText(this._renderer);\n\n        batchableHTMLText.renderable = htmlText;\n        batchableHTMLText.transform = htmlText.groupTransform;\n        batchableHTMLText.texture = Texture.EMPTY;\n        batchableHTMLText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableHTMLText.roundPixels = (this._renderer._roundPixels | htmlText._roundPixels) as 0 | 1;\n\n        htmlText._resolution = htmlText._autoResolution ? this._renderer.resolution : htmlText.resolution;\n        htmlText._gpuData[this._renderer.uid] = batchableHTMLText;\n\n        return batchableHTMLText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n\n","import type { CanvasAndContext } from '../../rendering/renderers/shared/texture/CanvasPool';\n\n/** @internal */\nconst nssvg = 'http://www.w3.org/2000/svg';\n/** @internal */\nconst nsxhtml = 'http://www.w3.org/1999/xhtml';\n\n/** @internal */\nexport class HTMLTextRenderData\n{\n    public svgRoot = document.createElementNS(nssvg, 'svg');\n    public foreignObject = document.createElementNS(nssvg, 'foreignObject');\n    public domElement = document.createElementNS(nsxhtml, 'div');\n    public styleElement = document.createElementNS(nsxhtml, 'style');\n    public image = new Image();\n    public canvasAndContext?: CanvasAndContext;\n\n    constructor()\n    {\n        const { foreignObject, svgRoot, styleElement, domElement } = this;\n        // Arbitrary max size\n\n        foreignObject.setAttribute('width', '10000');\n        foreignObject.setAttribute('height', '10000');\n        foreignObject.style.overflow = 'hidden';\n\n        svgRoot.appendChild(foreignObject);\n\n        foreignObject.appendChild(styleElement);\n        foreignObject.appendChild(domElement);\n    }\n}\n","import { Color } from '../../../color/Color';\n\nimport type { ConvertedStrokeStyle } from '../../graphics/shared/FillTypes';\nimport type { TextStyle } from '../../text/TextStyle';\nimport type { HTMLTextStyle, HTMLTextStyleOptions } from '../HTMLTextStyle';\n\n/**\n * Internally converts all of the style properties into CSS equivalents.\n * @param style\n * @returns The CSS style string, for setting `style` property of root HTMLElement.\n * @internal\n */\nexport function textStyleToCSS(style: HTMLTextStyle): string\n{\n    const stroke = style._stroke;\n    const fill = style._fill;\n\n    const cssStyleString = [\n        `color: ${Color.shared.setValue(fill.color).toHex()}`,\n        `font-size: ${(style.fontSize as number)}px`,\n        `font-family: ${style.fontFamily}`,\n        `font-weight: ${style.fontWeight}`,\n        `font-style: ${style.fontStyle}`,\n        `font-variant: ${style.fontVariant}`,\n        `letter-spacing: ${style.letterSpacing}px`,\n        `text-align: ${style.align}`,\n        `padding: ${style.padding}px`,\n        `white-space: ${(style.whiteSpace === 'pre' && style.wordWrap) ? 'pre-wrap' : style.whiteSpace}`,\n        ...style.lineHeight ? [`line-height: ${style.lineHeight}px`] : [],\n        ...style.wordWrap ? [\n            `word-wrap: ${style.breakWords ? 'break-all' : 'break-word'}`,\n            `max-width: ${style.wordWrapWidth}px`\n        ] : [],\n        ...stroke ? [strokeToCSS(stroke)] : [],\n        ...style.dropShadow ? [dropShadowToCSS(style.dropShadow)] : [],\n        ...style.cssOverrides,\n    ].join(';');\n\n    const cssStyles = [`div { ${cssStyleString} }`];\n\n    tagStyleToCSS(style.tagStyles, cssStyles);\n\n    return cssStyles.join(' ');\n}\n\nfunction dropShadowToCSS(dropShadowStyle: TextStyle['dropShadow']): string\n{\n    const color = Color.shared.setValue(dropShadowStyle.color).setAlpha(dropShadowStyle.alpha).toHexa();\n    const x = Math.round(Math.cos(dropShadowStyle.angle) * dropShadowStyle.distance);\n    const y = Math.round(Math.sin(dropShadowStyle.angle) * dropShadowStyle.distance);\n\n    const position = `${x}px ${y}px`;\n\n    if (dropShadowStyle.blur > 0)\n    {\n        return `text-shadow: ${position} ${dropShadowStyle.blur}px ${color}`;\n    }\n\n    return `text-shadow: ${position} ${color}`;\n}\n\nfunction strokeToCSS(stroke: ConvertedStrokeStyle): string\n{\n    return [\n        `-webkit-text-stroke-width: ${stroke.width}px`,\n        `-webkit-text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        `text-stroke-width: ${stroke.width}px`,\n        `text-stroke-color: ${Color.shared.setValue(stroke.color).toHex()}`,\n        'paint-order: stroke',\n    ].join(';');\n}\n\n/** Converts the tag styles into CSS. */\nconst templates = {\n    fontSize: `font-size: {{VALUE}}px`,\n    fontFamily: `font-family: {{VALUE}}`,\n    fontWeight: `font-weight: {{VALUE}}`,\n    fontStyle: `font-style: {{VALUE}}`,\n    fontVariant: `font-variant: {{VALUE}}`,\n    letterSpacing: `letter-spacing: {{VALUE}}px`,\n    align: `text-align: {{VALUE}}`,\n    padding: `padding: {{VALUE}}px`,\n    whiteSpace: `white-space: {{VALUE}}`,\n    lineHeight: `line-height: {{VALUE}}px`,\n    wordWrapWidth: `max-width: {{VALUE}}px`,\n};\n\n/** Converts the tag styles into CSS if modifications are required */\nconst transform = {\n    fill: (value: string) => `color: ${Color.shared.setValue(value).toHex()}`,\n    breakWords: (value: string) => `word-wrap: ${value ? 'break-all' : 'break-word'}`,\n    stroke: strokeToCSS,\n    dropShadow: dropShadowToCSS\n};\n\nfunction tagStyleToCSS(tagStyles: Record<string, HTMLTextStyleOptions>, out: string[])\n{\n    for (const i in tagStyles)\n    {\n        const tagStyle = tagStyles[i];\n        const cssTagStyle = [];\n\n        for (const j in tagStyle)\n        {\n            if (transform[j as keyof typeof transform])\n            {\n                cssTagStyle.push(transform[j as keyof typeof transform](tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n            else if (templates[j as keyof typeof templates])\n            {\n                // eslint-disable-next-line max-len\n                cssTagStyle.push(templates[j as keyof typeof templates].replace('{{VALUE}}', tagStyle[j as keyof HTMLTextStyleOptions] as any));\n            }\n        }\n\n        out.push(`${i} { ${cssTagStyle.join(';')} }`);\n    }\n}\n","/* eslint-disable accessor-pairs */\nimport { warn } from '../../utils/logging/warn';\nimport { TextStyle } from '../text/TextStyle';\nimport { textStyleToCSS } from './utils/textStyleToCSS';\n\nimport type { FillInput, StrokeInput } from '../graphics/shared/FillTypes';\nimport type { TextStyleOptions } from '../text/TextStyle';\n\n/**\n * Options for HTML text style, extends standard text styling with HTML-specific capabilities.\n * Omits certain base text properties that don't apply to HTML rendering.\n * @example\n * ```ts\n * // Basic HTML text style\n * const text = new HTMLText({\n *     text: '<p>Hello World</p>',\n *     style: {\n *         fontSize: 24,\n *         fill: '#ff0000',\n *         fontFamily: 'Arial',\n *         align: 'center'\n *     }\n * });\n *\n * // Custom tag styling\n * const taggedText = new HTMLText({\n *     text: '<custom>Custom Tag</custom>',\n *     style: {\n *         fontSize: 16,\n *         tagStyles: {\n *             custom: {\n *                 fontSize: 32,\n *                 fill: '#00ff00',\n *                 fontStyle: 'italic'\n *             }\n *         }\n *     }\n * });\n * ```\n * @category text\n * @standard\n */\nexport interface HTMLTextStyleOptions extends Omit<TextStyleOptions, 'leading' | 'textBaseline' | 'trim' | 'filters'>\n{\n    /**\n     * List of CSS style overrides to apply to the HTML text.\n     * These styles are added after the built-in styles and can override any default styling.\n     * @advanced\n     */\n    cssOverrides?: string[];\n\n    /**\n     * Custom styles to apply to specific HTML tags.\n     * Allows for consistent styling of custom elements without CSS overrides.\n     * @example\n     * ```ts\n     * const text = new HTMLText({\n     *     text: `\n     *         <red>Main Title</red>\n     *         <grey>The subtitle</grey>\n     *         <blue>Regular content text</blue>\n     *     `,\n     *     style: {\n     *         tagStyles: {\n     *             red: {\n     *                 fill: '#ff0000',\n     *             },\n     *             grey: {\n     *                 fill: '#666666',\n     *             },\n     *             blue: {\n     *                 fill: 'blue',\n     *             }\n     *         }\n     *     }\n     * });\n     * ```\n     * @standard\n     */\n    tagStyles?: Record<string, HTMLTextStyleOptions>;\n}\n\n/**\n * A TextStyle object rendered by the HTMLTextSystem.\n * @category text\n */\nexport class HTMLTextStyle extends TextStyle\n{\n    private _cssOverrides: string[] = [];\n    private _cssStyle: string;\n    /**\n     * Custom styles to apply to specific HTML tags.\n     * Allows for consistent styling of custom elements without CSS overrides.\n     * @example\n     * new HTMLText({\n     *   text:'<red>Red</red>,<blue>Blue</blue>,<green>Green</green>',\n     *   style:{\n     *       fontFamily: 'DM Sans',\n     *       fill: 'white',\n     *       fontSize:100,\n     *       tagStyles:{\n     *           red:{\n     *               fill:'red',\n     *           },\n     *           blue:{\n     *               fill:'blue',\n     *           },\n     *           green:{\n     *               fill:'green',\n     *           }\n     *       }\n     *   }\n     * );\n     * @standard\n     */\n    public tagStyles: Record<string, HTMLTextStyleOptions>;\n\n    constructor(options: HTMLTextStyleOptions = {})\n    {\n        super(options);\n\n        this.cssOverrides = options.cssOverrides ?? [];\n        this.tagStyles = options.tagStyles ?? {};\n    }\n\n    /**\n     * List of CSS style overrides to apply to the HTML text.\n     * These styles are added after the built-in styles and can override any default styling.\n     * @advanced\n     */\n    set cssOverrides(value: string | string[])\n    {\n        this._cssOverrides = value instanceof Array ? value : [value];\n        this.update();\n    }\n\n    /** @advanced */\n    get cssOverrides(): string[]\n    {\n        return this._cssOverrides;\n    }\n\n    /**\n     * Updates the text style and triggers a refresh of the CSS style cache.\n     * This method is called automatically when style properties are changed.\n     * @example\n     * ```ts\n     * // Update after multiple changes\n     * const text = new HTMLText({\n     *     text: 'Hello World',\n     *     style\n     * });\n     *\n     * style.fontSize = 32;\n     * style.fill = '#00ff00';\n     * style.fontFamily = 'Arial';\n     * style.update(); // Apply all changes at once\n     * ```\n     * @advanced\n     * @see {@link HTMLTextStyle#cssStyle} For accessing the generated CSS\n     * @see {@link HTMLTextStyle#cssOverrides} For managing CSS overrides\n     */\n    public update()\n    {\n        this._cssStyle = null;\n        super.update();\n    }\n\n    /**\n     * Creates a new HTMLTextStyle object with the same values as this one.\n     * This creates a deep copy of all style properties, including dropShadow and tag styles.\n     * @example\n     * ```ts\n     * // Create original style\n     * const originalStyle = new HTMLTextStyle({\n     *     fontSize: 24,\n     *     fill: '#ff0000',\n     *     tagStyles: {\n     *         header: { fontSize: 32, fill: '#00ff00' }\n     *     }\n     * });\n     *\n     * // Clone the style\n     * const clonedStyle = originalStyle.clone();\n     *\n     * // Modify cloned style independently\n     * clonedStyle.fontSize = 36;\n     * clonedStyle.fill = '#0000ff';\n     *\n     * // Original style remains unchanged\n     * console.log(originalStyle.fontSize); // Still 24\n     * console.log(originalStyle.fill); // Still '#ff0000'\n     * ```\n     *\n     * Properties that are cloned:\n     * - Basic text properties (fontSize, fontFamily, etc.)\n     * - Fill and stroke styles\n     * - Drop shadow configuration\n     * - CSS overrides\n     * - Tag styles (deep copied)\n     * - Word wrap settings\n     * - Alignment and spacing\n     * @returns {HTMLTextStyle} A new HTMLTextStyle instance with the same properties\n     * @see {@link HTMLTextStyle} For available style properties\n     * @see {@link HTMLTextStyle#cssOverrides} For CSS override handling\n     * @see {@link HTMLTextStyle#tagStyles} For tag style configuration\n     * @standard\n     */\n    public clone(): HTMLTextStyle\n    {\n        return new HTMLTextStyle({\n            align: this.align,\n            breakWords: this.breakWords,\n            dropShadow: this.dropShadow ? { ...this.dropShadow } : null,\n            fill: this._fill,\n            fontFamily: this.fontFamily,\n            fontSize: this.fontSize,\n            fontStyle: this.fontStyle,\n            fontVariant: this.fontVariant,\n            fontWeight: this.fontWeight,\n            letterSpacing: this.letterSpacing,\n            lineHeight: this.lineHeight,\n            padding: this.padding,\n            stroke: this._stroke,\n            whiteSpace: this.whiteSpace,\n            wordWrap: this.wordWrap,\n            wordWrapWidth: this.wordWrapWidth,\n            cssOverrides: this.cssOverrides,\n            tagStyles: { ...this.tagStyles },\n        });\n    }\n\n    /**\n     * The CSS style string that will be applied to the HTML text.\n     * @advanced\n     */\n    get cssStyle(): string\n    {\n        if (!this._cssStyle)\n        {\n            this._cssStyle = textStyleToCSS(this);\n        }\n\n        return this._cssStyle;\n    }\n\n    /**\n     * Add a style override, this can be any CSS property\n     * it will override any built-in style. This is the\n     * property and the value as a string (e.g., `color: red`).\n     * This will override any other internal style.\n     * @param {string} value - CSS style(s) to add.\n     * @example\n     * style.addOverride('background-color: red');\n     * @advanced\n     */\n    public addOverride(...value: string[]): void\n    {\n        const toAdd = value.filter((v) => !this.cssOverrides.includes(v));\n\n        if (toAdd.length > 0)\n        {\n            this.cssOverrides.push(...toAdd);\n            this.update();\n        }\n    }\n\n    /**\n     * Remove any overrides that match the value.\n     * @param {string} value - CSS style to remove.\n     * @example\n     * style.removeOverride('background-color: red');\n     * @advanced\n     */\n    public removeOverride(...value: string[]): void\n    {\n        const toRemove = value.filter((v) => this.cssOverrides.includes(v));\n\n        if (toRemove.length > 0)\n        {\n            this.cssOverrides = this.cssOverrides.filter((v) => !toRemove.includes(v));\n            this.update();\n        }\n    }\n\n    /**\n     * Sets the fill style for the text. HTML text only supports color fills (string or number values).\n     * Texture fills are not supported and will trigger a warning in debug mode.\n     * @example\n     * ```ts\n     * // Using hex colors\n     * const text = new HTMLText({\n     *     text: 'Colored Text',\n     *     style: {\n     *         fill: 0xff0000 // Red color\n     *     }\n     * });\n     *\n     * // Using CSS color strings\n     * text.style.fill = '#00ff00';     // Hex string (Green)\n     * text.style.fill = 'blue';        // Named color\n     * text.style.fill = 'rgb(255,0,0)' // RGB\n     * text.style.fill = '#f0f';        // Short hex\n     *\n     * // Invalid usage (will trigger warning in debug)\n     * text.style.fill = {\n     *     type: 'pattern',\n     *     texture: Texture.from('pattern.png')\n     * }; // Not supported, falls back to default\n     * ```\n     * @param value - The fill color to use. Must be a string or number.\n     * @throws {Warning} In debug mode when attempting to use unsupported fill types\n     * @see {@link TextStyle#fill} For full fill options in canvas text\n     * @standard\n     */\n    override set fill(value: FillInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color fill is not supported by HTMLText');\n            // #endif\n        }\n\n        super.fill = value;\n    }\n\n    /**\n     * Sets the stroke style for the text. HTML text only supports color strokes (string or number values).\n     * Texture strokes are not supported and will trigger a warning in debug mode.\n     * @example\n     * ```ts\n     * // Using hex colors\n     * const text = new HTMLText({\n     *     text: 'Outlined Text',\n     *     style: {\n     *         stroke: 0xff0000 // Red outline\n     *     }\n     * });\n     *\n     * // Using CSS color strings\n     * text.style.stroke = '#00ff00';     // Hex string (Green)\n     * text.style.stroke = 'blue';        // Named color\n     * text.style.stroke = 'rgb(255,0,0)' // RGB\n     * text.style.stroke = '#f0f';        // Short hex\n     *\n     * // Using stroke width\n     * text.style = {\n     *     stroke: {\n     *         color: '#ff0000',\n     *         width: 2\n     *     }\n     * };\n     *\n     * // Remove stroke\n     * text.style.stroke = null;\n     *\n     * // Invalid usage (will trigger warning in debug)\n     * text.style.stroke = {\n     *     type: 'pattern',\n     *     texture: Texture.from('pattern.png')\n     * }; // Not supported, falls back to default\n     * ```\n     * @param value - The stroke style to use. Must be a string, number, or stroke configuration object\n     * @throws {Warning} In debug mode when attempting to use unsupported stroke types\n     * @see {@link TextStyle#stroke} For full stroke options in canvas text\n     * @standard\n     */\n    override set stroke(value: StrokeInput)\n    {\n        // if its not a string or a number, then its a texture!\n        if (value && typeof value !== 'string' && typeof value !== 'number')\n        {\n            // #if _DEBUG\n            warn('[HTMLTextStyle] only color stroke is not supported by HTMLText');\n            // #endif\n        }\n\n        super.stroke = value;\n    }\n}\n","import { loadFontAsBase64 } from './loadFontAsBase64';\n\n/**\n * Options for the font CSS style\n * @category text\n * @internal\n */\nexport interface FontCSSStyleOptions\n{\n    /**\n     * The font family to use in the CSS\n     * @example\n     * 'Arial' or ['Arial', 'Helvetica']\n     */\n    fontFamily: string | string[]\n    /**\n     * The font weight to use in the CSS\n     * @example\n     * 'normal', 'bold', '100', '200', etc.\n     */\n    fontWeight: string\n    /**\n     * The font style to use in the CSS\n     * @example\n     * 'normal', 'italic', 'oblique'\n     */\n    fontStyle: string\n}\n\n/**\n * This will take a font url and a style and return a css string that can be injected into a style tag\n * This will contain inlined base64 font and the font family information\n * @param style - the style to generate the css for\n * @param url - The url to load the font from\n * @returns - The css string\n * @internal\n */\nexport async function loadFontCSS(style: FontCSSStyleOptions, url: string): Promise<string>\n{\n    const dataSrc = await loadFontAsBase64(url);\n\n    return `@font-face {\n        font-family: \"${style.fontFamily}\";\n        src: url('${dataSrc}');\n        font-weight: ${style.fontWeight};\n        font-style: ${style.fontStyle};\n    }`;\n}\n","import { DOMAdapter } from '../../../environment/adapter';\n\n/**\n * Resolves a font url to a base64 string\n * @param url - The url to load the font from\n * @returns - The font as a base64 string\n * @internal\n */\nexport async function loadFontAsBase64(url: string): Promise<string>\n{\n    const response = await DOMAdapter.get().fetch(url);\n\n    const blob = await response.blob();\n\n    const reader = new FileReader();\n\n    const dataSrc: string = await new Promise((resolve, reject) =>\n    {\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    return dataSrc;\n}\n","import { Cache } from '../../../assets/cache/Cache';\nimport { loadFontCSS } from './loadFontCSS';\n\nimport type { FontCSSStyleOptions } from './loadFontCSS';\n\n/** @internal */\nexport const FontStylePromiseCache = new Map<string, Promise<string>>();\n\n/**\n * takes the font families and returns a css string that can be injected into a style tag\n * It will contain the font families and the font urls encoded as base64\n * @param fontFamilies - The font families to load\n * @param style - The FontCSSStyleOptions to load the font with (used for the first font family)\n * @param defaultOptions - The default options to load the font with (used for the rest of the font families)\n * @param defaultOptions.fontWeight - The default font weight\n * @param defaultOptions.fontStyle - The default font style\n * @returns - The css string\n * @internal\n */\nexport async function getFontCss(\n    fontFamilies: string[],\n    style: FontCSSStyleOptions,\n    defaultOptions: {fontWeight: string, fontStyle: string}\n)\n{\n    const fontPromises = fontFamilies\n        .filter((fontFamily) => Cache.has(`${fontFamily}-and-url`))\n        .map((fontFamily, i) =>\n        {\n            if (!FontStylePromiseCache.has(fontFamily))\n            {\n                const { url } = Cache.get(`${fontFamily}-and-url`);\n\n                if (i === 0)\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: style.fontWeight,\n                        fontStyle: style.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n\n                else\n                {\n                    FontStylePromiseCache.set(fontFamily, loadFontCSS({\n                        fontWeight: defaultOptions.fontWeight,\n                        fontStyle: defaultOptions.fontStyle,\n                        fontFamily,\n                    }, url));\n                }\n            }\n\n            return FontStylePromiseCache.get(fontFamily);\n        });\n\n    return (await Promise.all(fontPromises)).join('\\n');\n}\n","import { HTMLTextRenderData } from '../HTMLTextRenderData';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\nlet tempHTMLTextRenderData: HTMLTextRenderData;\n\n/**\n * Measures the HTML text without actually generating an image.\n * This is used to calculate the size of the text.\n * @param text - The text to measure\n * @param style - The style to use\n * @param fontStyleCSS - The font css to use\n * @param htmlTextRenderData - The HTMLTextRenderData to write the SVG to\n * @returns - The size of the text\n * @internal\n */\nexport function measureHtmlText(\n    text: string,\n    style: HTMLTextStyle,\n    fontStyleCSS?: string,\n    htmlTextRenderData?: HTMLTextRenderData\n): Size\n{\n    htmlTextRenderData ||= tempHTMLTextRenderData || (tempHTMLTextRenderData = new HTMLTextRenderData());\n\n    const { domElement, styleElement, svgRoot } = htmlTextRenderData;\n\n    domElement.innerHTML = `<style>${style.cssStyle};</style><div style='padding:0'>${text}</div>`;\n\n    domElement.setAttribute('style', 'transform-origin: top left; display: inline-block');\n\n    if (fontStyleCSS)\n    {\n        styleElement.textContent = fontStyleCSS;\n    }\n\n    // Measure the contents using the shadow DOM\n    document.body.appendChild(svgRoot);\n\n    const contentBounds = domElement.getBoundingClientRect();\n\n    svgRoot.remove();\n\n    // padding is included in the CSS calculation, so we need to remove it here\n    const doublePadding = style.padding * 2;\n\n    return {\n        width: contentBounds.width - doublePadding,\n        height: contentBounds.height - doublePadding,\n    };\n}\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { type CanvasAndContext, CanvasPool } from '../../rendering/renderers/shared/texture/CanvasPool';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type TextureStyle } from '../../rendering/renderers/shared/texture/TextureStyle';\nimport { type Renderer, RendererType } from '../../rendering/renderers/types';\nimport { isSafari } from '../../utils/browser/isSafari';\nimport { warn } from '../../utils/logging/warn';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { getPo2TextureFromSource } from '../text/utils/getPo2TextureFromSource';\nimport { HTMLTextRenderData } from './HTMLTextRenderData';\nimport { HTMLTextStyle } from './HTMLTextStyle';\nimport { extractFontFamilies } from './utils/extractFontFamilies';\nimport { getFontCss } from './utils/getFontCss';\nimport { getSVGUrl } from './utils/getSVGUrl';\nimport { getTemporaryCanvasFromImage } from './utils/getTemporaryCanvasFromImage';\nimport { loadSVGImage } from './utils/loadSVGImage';\nimport { measureHtmlText } from './utils/measureHtmlText';\n\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { HTMLTextOptions } from './HTMLText';\n\n/**\n * System plugin to the renderer to manage HTMLText\n * @category rendering\n * @advanced\n */\nexport class HTMLTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'htmlText',\n    } as const;\n\n    /**\n     * WebGPU has a cors issue when uploading an image that is an SVGImage\n     * To get around this we need to create a canvas draw the image to it and upload that instead.\n     * Bit of a shame.. but no other work around just yet!\n     */\n    private readonly _createCanvas: boolean;\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._createCanvas = renderer.type === RendererType.WEBGPU;\n    }\n\n    /**\n     * @param options\n     * @deprecated Use getTexturePromise instead\n     */\n    public getTexture(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this.getTexturePromise(options);\n    }\n\n    public getTexturePromise(options: HTMLTextOptions): Promise<Texture>\n    {\n        return this._buildTexturePromise(options);\n    }\n\n    private async _buildTexturePromise(options: HTMLTextOptions)\n    {\n        const { text, style, resolution, textureStyle } = options as {\n            text: string,\n            style: HTMLTextStyle,\n            resolution: number,\n            textureStyle?: TextureStyle,\n        };\n\n        const htmlTextData = BigPool.get(HTMLTextRenderData);\n        const fontFamilies = extractFontFamilies(text, style);\n        const fontCSS = await getFontCss(\n            fontFamilies,\n            style,\n            HTMLTextStyle.defaultTextStyle as {fontWeight: string, fontStyle: string}\n        );\n        const measured = measureHtmlText(text, style, fontCSS, htmlTextData);\n\n        const width = Math.ceil(Math.ceil((Math.max(1, measured.width) + (style.padding * 2))) * resolution);\n        const height = Math.ceil(Math.ceil((Math.max(1, measured.height) + (style.padding * 2))) * resolution);\n\n        const image = htmlTextData.image;\n\n        // this off set will ensure we don't get any UV bleeding!\n        const uvSafeOffset = 2;\n\n        image.width = (width | 0) + uvSafeOffset;\n        image.height = (height | 0) + uvSafeOffset;\n\n        const svgURL = getSVGUrl(text, style, resolution, fontCSS, htmlTextData);\n\n        await loadSVGImage(image, svgURL, isSafari() && fontFamilies.length > 0);\n\n        const resource: HTMLImageElement | HTMLCanvasElement = image;\n        let canvasAndContext: CanvasAndContext;\n\n        if (this._createCanvas)\n        {\n            // silly webGPU workaround..\n            canvasAndContext = getTemporaryCanvasFromImage(image, resolution);\n        }\n\n        const texture = getPo2TextureFromSource(canvasAndContext ? canvasAndContext.canvas : resource,\n            image.width - uvSafeOffset,\n            image.height - uvSafeOffset,\n            resolution\n        );\n\n        if (textureStyle) texture.source.style = textureStyle;\n\n        if (this._createCanvas)\n        {\n            this._renderer.texture.initSource(texture.source);\n            CanvasPool.returnCanvasAndContext(canvasAndContext);\n        }\n\n        BigPool.return(htmlTextData as PoolItem);\n\n        return texture;\n    }\n\n    public returnTexturePromise(texturePromise: Promise<Texture>)\n    {\n        texturePromise.then((texture) =>\n        {\n            this._cleanUp(texture);\n        }).catch(() =>\n        {\n            // #if _DEBUG\n            warn('HTMLTextSystem: Failed to clean texture');\n            // #endif\n        });\n    }\n\n    private _cleanUp(texture: Texture)\n    {\n        TexturePool.returnTexture(texture, true);\n        texture.source.resource = null;\n        texture.source.uploadMethodId = 'unknown';\n    }\n\n    public destroy()\n    {\n        // BOOM!\n        (this._renderer as null) = null;\n    }\n}\n","import type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * Extracts font families from text. It will extract font families from the style, tagStyles and any font families\n * embedded in the text. It should also strip out duplicates as it goes.\n * @param  text - The text to extract font families from\n * @param style - The style to extract font families from\n * @returns {string[]} - The font families as an array of strings\n * @internal\n */\nexport function extractFontFamilies(text: string, style: HTMLTextStyle): string[]\n{\n    const fontFamily = style.fontFamily;\n    const fontFamilies: string[] = [];\n    const dedupe: Record<string, boolean> = {};\n\n    // first ensure fonts are loaded inline..\n    // find any font..\n    const regex = /font-family:([^;\"\\s]+)/g;\n\n    const matches = text.match(regex);\n\n    function addFontFamily(fontFamily: string)\n    {\n        if (!dedupe[fontFamily])\n        {\n            fontFamilies.push(fontFamily);\n\n            dedupe[fontFamily] = true;\n        }\n    }\n\n    if (Array.isArray(fontFamily))\n    {\n        for (let i = 0; i < fontFamily.length; i++)\n        {\n            addFontFamily(fontFamily[i]);\n        }\n    }\n    else\n    {\n        addFontFamily(fontFamily);\n    }\n\n    if (matches)\n    {\n        matches.forEach((match) =>\n        {\n            const fontFamily = match.split(':')[1].trim();\n\n            addFontFamily(fontFamily);\n        });\n    }\n\n    for (const i in style.tagStyles)\n    {\n        const fontFamily = style.tagStyles[i].fontFamily;\n\n        addFontFamily(fontFamily as string);\n    }\n\n    return fontFamilies;\n}\n","import type { HTMLTextRenderData } from '../HTMLTextRenderData';\nimport type { HTMLTextStyle } from '../HTMLTextStyle';\n\n/**\n * takes all the data and returns a svg url string can be loaded by an image element\n * @param text - The text to measure\n * @param style - The style to use\n * @param resolution - The resolution to use\n * @param fontCSS - The font css to use\n * @param htmlTextData - The HTMLTextRenderData to write the SVG to\n * @returns - The SVG as a url string\n * @internal\n */\nexport function getSVGUrl(\n    text: string,\n    style: HTMLTextStyle,\n    resolution: number,\n    fontCSS: string,\n    htmlTextData: HTMLTextRenderData\n)\n{\n    const { domElement, styleElement, svgRoot } = htmlTextData;\n\n    domElement.innerHTML = `<style>${style.cssStyle}</style><div style='padding:0;'>${text}</div>`;\n    domElement.setAttribute('style', `transform: scale(${resolution});transform-origin: top left; display: inline-block`);\n    styleElement.textContent = fontCSS;\n\n    const { width, height } = htmlTextData.image;\n\n    svgRoot.setAttribute('width', width.toString());\n    svgRoot.setAttribute('height', height.toString());\n\n    return new XMLSerializer().serializeToString(svgRoot);\n}\n","/**\n * This function loads an SVG image into an HTMLImageElement.\n * The image can then be uploaded as texture to the GPU.\n * iOS has a bug where embedded fonts are not available immediately after the image loads,\n * so we wait an arbitrary amount of time before resolving the promise.\n * @param image - The image to load the SVG into\n * @param url - The url to load the SVG from\n * @param delay - Whether to delay the load\n * @returns - A promise that resolves when the image has loaded\n * @internal\n */\nexport function loadSVGImage(image: HTMLImageElement, url: string, delay: boolean)\n{\n    return new Promise<void>(async (resolve) =>\n    {\n        // Safari has a known bug where embedded fonts are not available\n        // immediately after the image loads, to compensate we wait an\n        // arbitrary amount of time\n        // @see https://bugs.webkit.org/show_bug.cgi?id=219770\n        if (delay)\n        {\n            await new Promise<void>((resolve) => setTimeout(resolve, 100));\n        }\n\n        image.onload = () =>\n        {\n            resolve();\n        };\n\n        image.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(url)}`;\n        image.crossOrigin = 'anonymous';\n    });\n}\n","import { DOMAdapter } from '../../environment/adapter';\n\n/**\n * Checks if the current browser is Safari.\n * @returns {boolean} True if the browser is Safari, false otherwise.\n * @internal\n */\nexport function isSafari(): boolean\n{\n    const { userAgent } = DOMAdapter.get().getNavigator();\n\n    return (/^((?!chrome|android).)*safari/i).test(userAgent);\n}\n","import { CanvasPool } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\nimport type { CanvasAndContext } from '../../../rendering/renderers/shared/texture/CanvasPool';\n\n/**\n * This function converts an image to a canvas, and returns the canvas.\n * It is used to convert images to canvases to work around a CORS issue where WebGPU cannot\n * upload an SVGImage to a texture.\n *\n * It uses the CanvasPool to get an optimal canvas and context, and then draws the image onto it.\n * Remember to return this canvas is immediately to the CanvasPool for reuse when you are done with it.\n * (eg upload it to the GPU!)\n * @param image - The image to convert to a canvas.\n * @param resolution - The resolution of the canvas.\n * @internal\n */\nexport function getTemporaryCanvasFromImage(image: HTMLImageElement, resolution: number): CanvasAndContext\n{\n    // Get an optimal canvas and context from the CanvasPool, based on the\n    // dimensions of the image and the desired resolution.\n    const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(\n        image.width,\n        image.height,\n        resolution\n    );\n\n    // Clear the context of the canvas, and draw the image onto it.\n    const { context } = canvasAndContext;\n\n    context.clearRect(0, 0, image.width, image.height);\n    context.drawImage(image, 0, 0);\n\n    // Return the canvas.\n    return canvasAndContext;\n}\n\n","import { extensions } from '../../extensions/Extensions';\nimport { HTMLTextPipe } from './HTMLTextPipe';\nimport { HTMLTextSystem } from './HTMLTextSystem';\n\nextensions.add(HTMLTextSystem);\nextensions.add(HTMLTextPipe);\n","import { BatchableSprite } from '../../sprite/BatchableSprite';\n\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class BatchableText extends BatchableSprite\n{\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        super();\n\n        // Next step is to make canvasTextSystem a GLOBAL object.\n        // so this is ok for now..\n        this._renderer = renderer;\n\n        renderer.runners.resolutionChange.add(this);\n    }\n\n    public resolutionChange()\n    {\n        const text = this.renderable as Text;\n\n        if (text._autoResolution)\n        {\n            text.onViewUpdate();\n        }\n    }\n\n    public destroy()\n    {\n        this._renderer.canvasText.returnTexture(this.texture);\n\n        (this._renderer as null) = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { updateTextBounds } from '../utils/updateTextBounds';\nimport { BatchableText } from './BatchableText';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Text } from '../Text';\n\n/** @internal */\nexport class CanvasTextPipe implements RenderPipe<Text>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'text',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public validateRenderable(text: Text): boolean\n    {\n        return text._didTextUpdate;\n    }\n\n    public addRenderable(text: Text, instructionSet: InstructionSet)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (text._didTextUpdate)\n        {\n            this._updateGpuText(text);\n            text._didTextUpdate = false;\n        }\n\n        this._renderer.renderPipes.batch.addToBatch(batchableText, instructionSet);\n    }\n\n    public updateRenderable(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        batchableText._batcher.updateElement(batchableText);\n    }\n\n    private _updateGpuText(text: Text)\n    {\n        const batchableText = this._getGpuText(text);\n\n        if (batchableText.texture)\n        {\n            this._renderer.canvasText.returnTexture(batchableText.texture);\n        }\n\n        text._resolution = text._autoResolution ? this._renderer.resolution : text.resolution;\n\n        batchableText.texture = batchableText.texture = this._renderer.canvasText.getTexture(text);\n\n        updateTextBounds(batchableText, text);\n    }\n\n    private _getGpuText(text: Text)\n    {\n        return text._gpuData[this._renderer.uid] || this.initGpuText(text);\n    }\n\n    public initGpuText(text: Text)\n    {\n        const batchableText = new BatchableText(this._renderer);\n\n        batchableText.renderable = text;\n        batchableText.transform = text.groupTransform;\n        batchableText.bounds = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n        batchableText.roundPixels = (this._renderer._roundPixels | text._roundPixels) as 0 | 1;\n\n        text._gpuData[this._renderer.uid] = batchableText;\n\n        return batchableText;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { type Filter } from '../../../filters/Filter';\nimport { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { TextureStyle } from '../../../rendering/renderers/shared/texture/TextureStyle';\nimport { deprecation } from '../../../utils/logging/deprecation';\nimport { type CanvasTextOptions } from '../Text';\nimport { TextStyle } from '../TextStyle';\nimport { getPo2TextureFromSource } from '../utils/getPo2TextureFromSource';\nimport { CanvasTextGenerator } from './CanvasTextGenerator';\n\nimport type { System } from '../../../rendering/renderers/shared/system/System';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport type { Renderer } from '../../../rendering/renderers/types';\n\n/**\n * System plugin to the renderer to manage canvas text.\n * @category rendering\n * @advanced\n */\nexport class CanvasTextSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'canvasText',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(_renderer: Renderer)\n    {\n        this._renderer = _renderer;\n    }\n\n    /** @deprecated since 8.0.0 */\n    public getTexture(text: string, resolution: number, style: TextStyle, textKey: string): Texture;\n    /**\n     * This is a function that will create a texture from a text string, style and resolution.\n     * Useful if you want to make a texture of your text and use if for various other pixi things!\n     * @param options - The options of the text that will be used to generate the texture.\n     * @param options.text - the text to render\n     * @param options.style - the style of the text\n     * @param options.resolution - the resolution of the texture\n     * @returns the newly created texture\n     */\n    public getTexture(options: CanvasTextOptions): Texture;\n    public getTexture(\n        options: CanvasTextOptions | string,\n        _resolution?: number,\n        _style?: TextStyle,\n        _textKey?: string\n    ): Texture\n    {\n        if (typeof options === 'string')\n        {\n            // #if _DEBUG\n            deprecation('8.0.0', 'CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments');\n            // #endif\n\n            options = {\n                text: options,\n                style: _style,\n                resolution: _resolution,\n            };\n        }\n\n        if (!(options.style instanceof TextStyle))\n        {\n            options.style = new TextStyle(options.style);\n        }\n\n        if (!(options.textureStyle instanceof TextureStyle))\n        {\n            options.textureStyle = new TextureStyle(options.textureStyle);\n        }\n\n        if (typeof options.text !== 'string')\n        {\n            options.text = options.text.toString();\n        }\n\n        const { text, style, textureStyle } = options;\n\n        const resolution = options.resolution ?? this._renderer.resolution;\n\n        const { frame, canvasAndContext } = CanvasTextGenerator.getCanvasAndContext({\n            text: text as string,\n            style: style as TextStyle,\n            resolution,\n        });\n\n        const texture = getPo2TextureFromSource(canvasAndContext.canvas, frame.width, frame.height, resolution);\n\n        if (textureStyle) texture.source.style = textureStyle as TextureStyle;\n\n        if (style.trim)\n        {\n            // reapply the padding to the frame\n            frame.pad(style.padding);\n            texture.frame.copyFrom(frame);\n            texture.updateUvs();\n        }\n\n        if (style.filters)\n        {\n            // apply the filters to the texture if required..\n            // this returns a new texture with the filters applied\n            const filteredTexture = this._applyFilters(texture, style.filters);\n\n            // return the original texture to the pool so we can reuse the next frame\n            this.returnTexture(texture);\n\n            CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n            // return the new texture with the filters applied\n            return filteredTexture;\n        }\n\n        this._renderer.texture.initSource(texture._source);\n\n        CanvasTextGenerator.returnCanvasAndContext(canvasAndContext);\n\n        return texture;\n    }\n\n    /**\n     * Returns a texture that was created wit the above `getTexture` function.\n     * Handy if you are done with a texture and want to return it to the pool.\n     * @param texture - The texture to be returned.\n     */\n    public returnTexture(texture: Texture)\n    {\n        const source = texture.source;\n\n        source.resource = null;\n        source.uploadMethodId = 'unknown';\n        source.alphaMode = 'no-premultiply-alpha';\n\n        TexturePool.returnTexture(texture, true);\n    }\n\n    /**\n     * Renders text to its canvas, and updates its texture.\n     * @deprecated since 8.10.0\n     */\n    public renderTextToCanvas(): void\n    {\n        // #if _DEBUG\n        deprecation(\n            '8.10.0',\n            'CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead'\n        );\n        // #endif\n    }\n\n    /**\n     * Applies the specified filters to the given texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture. It also ensures that the alpha mode of the resulting\n     * texture is set to 'premultiplied-alpha'.\n     * @param {Texture} texture - The texture to which the filters will be applied.\n     * @param {Filter[]} filters - The filters to apply to the texture.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     */\n    private _applyFilters(texture: Texture, filters: Filter[]): Texture\n    {\n        // Save the current render target so it can be restored later\n        const currentRenderTarget = this._renderer.renderTarget.renderTarget;\n\n        // Apply the filters to the texture and get the resulting texture\n        const resultTexture = this._renderer.filter.generateFilteredTexture({\n            texture,\n            filters,\n        });\n\n        // Set the alpha mode of the resulting texture to 'premultiplied-alpha'\n\n        // Restore the previous render target\n        this._renderer.renderTarget.bind(currentRenderTarget, false);\n\n        // Return the resulting texture with the filters applied\n        return resultTexture;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { CanvasTextPipe } from './canvas/CanvasTextPipe';\nimport { CanvasTextSystem } from './canvas/CanvasTextSystem';\n\nextensions.add(CanvasTextSystem);\nextensions.add(CanvasTextPipe);\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { BindGroup } from '../../../rendering/renderers/gpu/shader/BindGroup';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { type GPUData } from '../../view/ViewContainer';\nimport { BatchableMesh } from './BatchableMesh';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type {\n    InstructionPipe,\n    RenderPipe\n} from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { Mesh } from './Mesh';\n\n// TODO Record mode is a P2, will get back to this as it's not a priority\n// const recordMode = true;\n\n/**\n * GPUData for Mesh\n * @internal\n */\nexport class MeshGpuData implements GPUData\n{\n    public meshData?: MeshData;\n    public batchableMesh?: BatchableMesh;\n\n    public destroy()\n    {\n        // BOOM!\n    }\n}\n\n/**\n * The data for the mesh\n * @internal\n */\ninterface MeshData\n{\n    /** if the mesh is batched or not */\n    batched: boolean;\n    /** the size of the index buffer */\n    indexSize: number;\n    /** the size of the vertex buffer */\n    vertexSize: number;\n}\n\n/** @internal */\nexport interface MeshAdaptor\n{\n    init(): void;\n    execute(meshPipe: MeshPipe, mesh: Mesh): void;\n    destroy(): void;\n}\n\n/**\n * The MeshPipe is responsible for handling the rendering of Mesh objects.\n * It manages the batching of meshes, updates their GPU data, and executes the rendering instructions.\n * It also handles the local uniforms for each mesh, such as transformation matrices and colors.\n * @category scene\n * @internal\n */\nexport class MeshPipe implements RenderPipe<Mesh>, InstructionPipe<Mesh>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'mesh',\n    } as const;\n\n    public localUniforms = new UniformGroup({\n        uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n        uRound: { value: 0, type: 'f32' },\n    });\n\n    public localUniformsBindGroup = new BindGroup({\n        0: this.localUniforms,\n    });\n\n    public renderer: Renderer;\n\n    private _adaptor: MeshAdaptor;\n\n    constructor(renderer: Renderer, adaptor: MeshAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init();\n    }\n\n    public validateRenderable(mesh: Mesh): boolean\n    {\n        const meshData = this._getMeshData(mesh);\n\n        const wasBatched = meshData.batched;\n\n        const isBatched = mesh.batched;\n\n        meshData.batched = isBatched;\n\n        if (wasBatched !== isBatched)\n        {\n            return true;\n        }\n        else if (isBatched)\n        {\n            const geometry = mesh._geometry;\n\n            // no need to break the batch if it's the same size\n            if (geometry.indices.length !== meshData.indexSize\n                    || geometry.positions.length !== meshData.vertexSize)\n            {\n                meshData.indexSize = geometry.indices.length;\n                meshData.vertexSize = geometry.positions.length;\n\n                return true;\n            }\n\n            const batchableMesh = this._getBatchableMesh(mesh);\n\n            if (batchableMesh.texture.uid !== mesh._texture.uid)\n            {\n                batchableMesh._textureMatrixUpdateId = -1;\n            }\n\n            return !batchableMesh._batcher.checkAndUpdateTexture(\n                batchableMesh,\n                mesh._texture\n            );\n        }\n\n        return false;\n    }\n\n    public addRenderable(mesh: Mesh, instructionSet: InstructionSet)\n    {\n        const batcher = this.renderer.renderPipes.batch;\n\n        const { batched } = this._getMeshData(mesh);\n\n        if (batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            batcher.addToBatch(gpuBatchableMesh, instructionSet);\n        }\n        else\n        {\n            batcher.break(instructionSet);\n\n            instructionSet.add(mesh);\n        }\n    }\n\n    public updateRenderable(mesh: Mesh)\n    {\n        if (mesh.batched)\n        {\n            const gpuBatchableMesh = this._getBatchableMesh(mesh);\n\n            gpuBatchableMesh.setTexture(mesh._texture);\n\n            gpuBatchableMesh.geometry = mesh._geometry;\n\n            gpuBatchableMesh._batcher.updateElement(gpuBatchableMesh);\n        }\n    }\n\n    public execute(mesh: Mesh)\n    {\n        if (!mesh.isRenderable) return;\n\n        mesh.state.blendMode = getAdjustedBlendModeBlend(mesh.groupBlendMode, mesh.texture._source);\n\n        const localUniforms = this.localUniforms;\n\n        localUniforms.uniforms.uTransformMatrix = mesh.groupTransform;\n        localUniforms.uniforms.uRound = this.renderer._roundPixels | mesh._roundPixels;\n        localUniforms.update();\n\n        color32BitToUniform(\n            mesh.groupColorAlpha,\n            localUniforms.uniforms.uColor,\n            0\n        );\n\n        this._adaptor.execute(this, mesh);\n    }\n\n    private _getMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].meshData || this._initMeshData(mesh);\n    }\n\n    private _initMeshData(mesh: Mesh): MeshData\n    {\n        mesh._gpuData[this.renderer.uid].meshData = {\n            batched: mesh.batched,\n            indexSize: mesh._geometry.indices?.length,\n            vertexSize: mesh._geometry.positions?.length,\n        };\n\n        return mesh._gpuData[this.renderer.uid].meshData;\n    }\n\n    private _getBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        mesh._gpuData[this.renderer.uid] ||= new MeshGpuData();\n\n        return mesh._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(mesh);\n    }\n\n    private _initBatchableMesh(mesh: Mesh): BatchableMesh\n    {\n        // TODO - make this batchable graphics??\n        const gpuMesh: BatchableMesh = new BatchableMesh();\n\n        gpuMesh.renderable = mesh;\n        gpuMesh.setTexture(mesh._texture);\n        gpuMesh.transform = mesh.groupTransform;\n        gpuMesh.roundPixels = (this.renderer._roundPixels | mesh._roundPixels) as 0 | 1;\n\n        mesh._gpuData[this.renderer.uid].batchableMesh = gpuMesh;\n\n        return gpuMesh;\n    }\n\n    public destroy()\n    {\n        this.localUniforms = null;\n        this.localUniformsBindGroup = null;\n\n        this._adaptor.destroy();\n        this._adaptor = null;\n\n        this.renderer = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { MeshPipe } from './shared/MeshPipe';\n\nextensions.add(MeshPipe);\n","import { TexturePool } from '../../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from '../../container/bounds/Bounds';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { Texture } from '../../../rendering/renderers/shared/texture/Texture';\n\nconst tempBounds = new Bounds();\n\n/**\n * Takes an image and creates a texture from it, using a power of 2 texture from the texture pool.\n * Remember to return the texture when you don't need it any more!\n * @param image - The image to create a texture from\n * @param width - the frame width of the texture\n * @param height - the frame height of the texture\n * @param resolution - The resolution of the texture\n * @returns - The texture\n * @internal\n */\nexport function getPo2TextureFromSource(\n    image: HTMLImageElement | HTMLCanvasElement | ICanvas,\n    width: number,\n    height: number,\n    resolution: number\n): Texture\n{\n    const bounds = tempBounds;\n\n    bounds.minX = 0;\n    bounds.minY = 0;\n\n    bounds.maxX = (image.width / resolution) | 0;\n    bounds.maxY = (image.height / resolution) | 0;\n\n    const texture = TexturePool.getOptimalTexture(\n        bounds.width,\n        bounds.height,\n        resolution,\n        false\n    );\n\n    texture.source.uploadMethodId = 'image';\n    texture.source.resource = image;\n    texture.source.alphaMode = 'premultiply-alpha-on-upload';\n\n    texture.frame.width = width / resolution;\n    texture.frame.height = height / resolution;\n\n    // We want to update the resource on the GPU,\n    // but we do not want to resize the texture.\n    // calling `texture.source.update` will fit the resource to the texture\n    // causing a resize of the texture on the GPU.\n    // which is not what we want!\n    texture.source.emit('update', texture.source);\n\n    texture.updateUvs();\n\n    return texture;\n}\n","import { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { MeshGeometryOptions } from '../mesh/shared/MeshGeometry';\n\n/**\n * Constructor options used for `PlaneGeometry` instances.\n * ```js\n * const planeGeometry = new PlaneGeometry({\n *    width: 100,\n *    height: 100,\n *    verticesX: 10,\n *    verticesY: 10,\n * });\n * ```\n * @see {@link PlaneGeometry}\n * @category scene\n * @advanced\n */\nexport interface PlaneGeometryOptions\n{\n    /** Width of plane */\n    width?: number;\n    /** Height of plane */\n    height?: number;\n    /** Number of vertices on x-axis */\n    verticesX?: number;\n    /** Number of vertices on y-axis */\n    verticesY?: number;\n}\n\n/**\n * The PlaneGeometry allows you to draw a 2d plane\n * @category scene\n * @advanced\n */\nexport class PlaneGeometry extends MeshGeometry\n{\n    public static defaultOptions: PlaneGeometryOptions & MeshGeometryOptions = {\n        width: 100,\n        height: 100,\n        verticesX: 10,\n        verticesY: 10,\n    };\n\n    /** The number of vertices on x-axis */\n    public verticesX: number;\n    /** The number of vertices on y-axis */\n    public verticesY: number;\n    /** The width of plane */\n    public width: number;\n    /** The height of plane */\n    public height: number;\n\n    /**\n     * @param {PlaneGeometryOptions} options - Options to be applied to plane geometry\n     */\n    constructor(options: PlaneGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(width?: number, height?: number, verticesX?: number, verticesY?: number);\n    constructor(...args: [PlaneGeometryOptions?] | [number?, number?, number?, number?])\n    {\n        super({});\n\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number')\n        {\n            // #if _DEBUG\n            // eslint-disable-next-line max-len\n            deprecation(v8_0_0, 'PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead');\n            // #endif\n\n            options = {\n                width: options,\n                height: args[1],\n                verticesX: args[2],\n                verticesY: args[3],\n            };\n        }\n\n        this.build(options);\n    }\n\n    /**\n     * Refreshes plane coordinates\n     * @param options - Options to be applied to plane geometry\n     */\n    public build(options: PlaneGeometryOptions): void\n    {\n        options = { ...PlaneGeometry.defaultOptions, ...options };\n\n        this.verticesX = this.verticesX ?? options.verticesX;\n        this.verticesY = this.verticesY ?? options.verticesY;\n\n        this.width = this.width ?? options.width;\n        this.height = this.height ?? options.height;\n\n        const total = this.verticesX * this.verticesY;\n        const verts = [];\n        const uvs = [];\n        const indices = [];\n\n        const verticesX = this.verticesX - 1;\n        const verticesY = this.verticesY - 1;\n\n        const sizeX = (this.width) / verticesX;\n        const sizeY = (this.height) / verticesY;\n\n        for (let i = 0; i < total; i++)\n        {\n            const x = (i % this.verticesX);\n            const y = ((i / this.verticesX) | 0);\n\n            verts.push(x * sizeX, y * sizeY);\n            uvs.push(x / verticesX, y / verticesY);\n        }\n\n        const totalSub = verticesX * verticesY;\n\n        for (let i = 0; i < totalSub; i++)\n        {\n            const xpos = i % verticesX;\n            const ypos = (i / verticesX) | 0;\n\n            const value = (ypos * this.verticesX) + xpos;\n            const value2 = (ypos * this.verticesX) + xpos + 1;\n            const value3 = ((ypos + 1) * this.verticesX) + xpos;\n            const value4 = ((ypos + 1) * this.verticesX) + xpos + 1;\n\n            indices.push(value, value2, value3,\n                value2, value4, value3);\n        }\n\n        this.buffers[0].data = new Float32Array(verts);\n        this.buffers[1].data = new Float32Array(uvs);\n        this.indexBuffer.data = new Uint32Array(indices);\n\n        // ensure that the changes are uploaded\n        this.buffers[0].update();\n        this.buffers[1].update();\n        this.indexBuffer.update();\n    }\n}\n","import { type PointData } from '../../maths/point/PointData';\nimport { PlaneGeometry } from '../mesh-plane/PlaneGeometry';\n\n/**\n * Options for the NineSliceGeometry.\n * @category scene\n * @advanced\n */\nexport interface NineSliceGeometryOptions\n{\n\n    /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    width?: number\n    /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n    height?: number\n    /** The original width of the texture */\n    originalWidth?: number\n    /** The original height of the texture */\n    originalHeight?: number\n    /** The width of the left column. */\n    leftWidth?: number\n    /** The height of the top row. */\n    topHeight?: number\n    /** The width of the right column. */\n    rightWidth?: number\n    /** The height of the bottom row. */\n    bottomHeight?: number\n\n    /** The anchor point of the NineSliceSprite. */\n    anchor?: PointData\n}\n\n/**\n * The NineSliceGeometry class allows you to create a NineSlicePlane object.\n * @category scene\n * @advanced\n */\nexport class NineSliceGeometry extends PlaneGeometry\n{\n    /** The default options for the NineSliceGeometry. */\n    public static defaultOptions: NineSliceGeometryOptions = {\n        /** The width of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        width: 100,\n        /** The height of the NineSlicePlane, setting this will actually modify the vertices and UV's of this plane. */\n        height: 100,\n        /** The width of the left column. */\n        leftWidth: 10,\n        /** The height of the top row. */\n        topHeight: 10,\n        /** The width of the right column. */\n        rightWidth: 10,\n        /** The height of the bottom row. */\n        bottomHeight: 10,\n\n        /** The original width of the texture */\n        originalWidth: 100,\n        /** The original height of the texture */\n        originalHeight: 100,\n    };\n\n    /** @internal */\n    public _leftWidth: number;\n    /** @internal */\n    public _rightWidth: number;\n    /** @internal */\n    public _topHeight: number;\n    /** @internal */\n    public _bottomHeight: number;\n\n    private _originalWidth: number;\n    private _originalHeight: number;\n    private _anchorX: any;\n    private _anchorY: number;\n\n    constructor(options: NineSliceGeometryOptions = {})\n    {\n        options = { ...NineSliceGeometry.defaultOptions, ...options };\n\n        super({\n            width: options.width,\n            height: options.height,\n            verticesX: 4,\n            verticesY: 4,\n        });\n\n        this.update(options);\n    }\n\n    /**\n     * Updates the NineSliceGeometry with the options.\n     * @param options - The options of the NineSliceGeometry.\n     */\n    public update(options: NineSliceGeometryOptions)\n    {\n        this.width = options.width ?? this.width;\n        this.height = options.height ?? this.height;\n        this._originalWidth = options.originalWidth ?? this._originalWidth;\n        this._originalHeight = options.originalHeight ?? this._originalHeight;\n        this._leftWidth = options.leftWidth ?? this._leftWidth;\n        this._rightWidth = options.rightWidth ?? this._rightWidth;\n        this._topHeight = options.topHeight ?? this._topHeight;\n        this._bottomHeight = options.bottomHeight ?? this._bottomHeight;\n\n        this._anchorX = options.anchor?.x;\n        this._anchorY = options.anchor?.y;\n\n        this.updateUvs();\n        this.updatePositions();\n    }\n\n    /** Updates the positions of the vertices. */\n    public updatePositions()\n    {\n        const p = this.positions;\n        const {\n            width,\n            height,\n            _leftWidth,\n            _rightWidth,\n            _topHeight,\n            _bottomHeight,\n            _anchorX,\n            _anchorY,\n        } = this;\n\n        const w = _leftWidth + _rightWidth;\n        const scaleW = width > w ? 1.0 : width / w;\n\n        const h = _topHeight + _bottomHeight;\n        const scaleH = height > h ? 1.0 : height / h;\n\n        const scale = Math.min(scaleW, scaleH);\n\n        const anchorOffsetX = _anchorX * width;\n        const anchorOffsetY = _anchorY * height;\n\n        p[0] = p[8] = p[16] = p[24] = -anchorOffsetX;\n        p[2] = p[10] = p[18] = p[26] = (_leftWidth * scale) - anchorOffsetX;\n        p[4] = p[12] = p[20] = p[28] = width - (_rightWidth * scale) - anchorOffsetX;\n        p[6] = p[14] = p[22] = p[30] = width - anchorOffsetX;\n\n        p[1] = p[3] = p[5] = p[7] = -anchorOffsetY;\n        p[9] = p[11] = p[13] = p[15] = (_topHeight * scale) - anchorOffsetY;\n        p[17] = p[19] = p[21] = p[23] = height - (_bottomHeight * scale) - anchorOffsetY;\n        p[25] = p[27] = p[29] = p[31] = height - anchorOffsetY;\n\n        this.getBuffer('aPosition').update();\n    }\n\n    /** Updates the UVs of the vertices. */\n    public updateUvs()\n    {\n        const uvs = this.uvs;\n\n        uvs[0] = uvs[8] = uvs[16] = uvs[24] = 0;\n        uvs[1] = uvs[3] = uvs[5] = uvs[7] = 0;\n\n        uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;\n        uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;\n\n        const _uvw = 1.0 / this._originalWidth;\n        const _uvh = 1.0 / this._originalHeight;\n\n        uvs[2] = uvs[10] = uvs[18] = uvs[26] = _uvw * this._leftWidth;\n        uvs[9] = uvs[11] = uvs[13] = uvs[15] = _uvh * this._topHeight;\n\n        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - (_uvw * this._rightWidth);\n        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - (_uvh * this._bottomHeight);\n\n        this.getBuffer('aUV').update();\n    }\n}\n\n","import { ExtensionType } from '../../extensions/Extensions';\nimport { BatchableMesh } from '../mesh/shared/BatchableMesh';\nimport { NineSliceGeometry } from './NineSliceGeometry';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { NineSliceSprite } from './NineSliceSprite';\n\n/**\n * GPU data for NineSliceSprite.\n * @internal\n */\nexport class NineSliceSpriteGpuData extends BatchableMesh\n{\n    constructor()\n    {\n        super();\n        this.geometry = new NineSliceGeometry();\n    }\n\n    public destroy()\n    {\n        this.geometry.destroy();\n    }\n}\n\n/**\n * The NineSliceSpritePipe is a render pipe for rendering NineSliceSprites.\n * @internal\n */\nexport class NineSliceSpritePipe implements RenderPipe<NineSliceSprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'nineSliceSprite',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderable(sprite: NineSliceSprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: NineSliceSprite)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: NineSliceSprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture\n        );\n    }\n\n    private _updateBatchableSprite(sprite: NineSliceSprite, batchableSprite: BatchableMesh)\n    {\n        (batchableSprite.geometry as NineSliceGeometry)\n            .update(sprite);\n\n        // = sprite.bounds;\n        batchableSprite.setTexture(sprite._texture);\n    }\n\n    private _getGpuSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        return sprite._gpuData[this._renderer.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: NineSliceSprite): NineSliceSpriteGpuData\n    {\n        const gpuData = sprite._gpuData[this._renderer.uid] = new NineSliceSpriteGpuData();\n\n        const batchableMesh = gpuData;\n\n        batchableMesh.renderable = sprite;\n        batchableMesh.transform = sprite.groupTransform;\n        batchableMesh.texture = sprite._texture;\n        batchableMesh.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        // if the sprite has not been updated by the view, we need to update the batchable mesh now.\n        if (!sprite.didViewUpdate)\n        {\n            this._updateBatchableSprite(sprite, batchableMesh);\n        }\n\n        return gpuData;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { NineSliceSpritePipe } from './NineSliceSpritePipe';\n\nextensions.add(NineSliceSpritePipe);\n","import { ExtensionType } from '../extensions/Extensions';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { Effect } from '../scene/container/Effect';\nimport type { FilterInstruction } from './FilterSystem';\n\n/** @internal */\nexport class FilterPipe implements InstructionPipe<FilterInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'filter',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(filterEffect: Effect, container: Container, instructionSet: InstructionSet): void\n    {\n        const renderPipes = this._renderer.renderPipes;\n\n        renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            canBundle: false,\n            action: 'pushFilter',\n            container,\n            filterEffect,\n        } as FilterInstruction);\n    }\n\n    public pop(_filterEffect: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: FilterInstruction)\n    {\n        if (instruction.action === 'pushFilter')\n        {\n            this._renderer.filter.push(instruction);\n        }\n        else if (instruction.action === 'popFilter')\n        {\n            this._renderer.filter.pop();\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { Matrix } from '../maths/matrix/Matrix';\nimport { type Rectangle } from '../maths/shapes/Rectangle';\nimport { BindGroup } from '../rendering/renderers/gpu/shader/BindGroup';\nimport { Geometry } from '../rendering/renderers/shared/geometry/Geometry';\nimport { UniformGroup } from '../rendering/renderers/shared/shader/UniformGroup';\nimport { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport { TexturePool } from '../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer, RendererType } from '../rendering/renderers/types';\nimport { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalRenderableBounds } from '../scene/container/bounds/getRenderableBounds';\nimport { warn } from '../utils/logging/warn';\n\nimport type { WebGLRenderer } from '../rendering/renderers/gl/WebGLRenderer';\nimport type { WebGPURenderer } from '../rendering/renderers/gpu/WebGPURenderer';\nimport type { Instruction } from '../rendering/renderers/shared/instructions/Instruction';\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { RenderTarget } from '../rendering/renderers/shared/renderTarget/RenderTarget';\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Container } from '../scene/container/Container';\nimport type { Sprite } from '../scene/sprite/Sprite';\nimport type { Filter } from './Filter';\nimport type { FilterEffect } from './FilterEffect';\n\nconst quadGeometry = new Geometry({\n    attributes: {\n        aPosition: {\n            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\n            format: 'float32x2',\n            stride: 2 * 4,\n            offset: 0,\n        },\n    },\n    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3]),\n});\n\n/**\n * The filter pipeline is responsible for applying filters scene items!\n *\n * KNOWN BUGS:\n * 1. Global bounds calculation is incorrect if it is used when flip flopping filters. The maths can be found below\n * eg: filters [noiseFilter, blurFilter] noiseFilter will calculate the global bounds incorrectly.\n *\n * 2. RenderGroups do not work with filters. This is because the renderGroup matrix is not currently taken into account.\n *\n * Implementation notes:\n * 1. Gotcha - nesting filters that require blending will not work correctly. This creates a chicken and egg problem\n * the complexity and performance required to do this is not worth it i feel.. but lets see if others agree!\n *\n * 2. Filters are designed to be changed on the fly, this is means that changing filter information each frame will\n * not trigger an instruction rebuild. If you are constantly turning a filter on and off.. its therefore better to set\n * enabled to true or false on the filter. Or setting an empty array.\n *\n * 3. Need to look at perhaps aliasing when flip flopping filters. Really we should only need to antialias the FIRST\n * Texture we render too. The rest can be non aliased. This might help performance.\n * Currently we flip flop with an antialiased texture if antialiasing is enabled on the filter.\n * @internal\n */\nexport interface FilterInstruction extends Instruction\n{\n    renderPipeId: 'filter',\n    action: 'pushFilter' | 'popFilter',\n    container?: Container,\n    renderables?: Renderable[],\n    filterEffect: FilterEffect,\n}\n\n/**\n * Class representing the data required for applying filters.\n * This class holds various properties that are used during the filter application process.\n * @internal\n */\nclass FilterData\n{\n    /**\n     * Indicates whether the filter should be skipped.\n     * @type {boolean}\n     */\n    public skip = false;\n\n    /**\n     * The texture to which the filter is applied.\n     * @type {Texture}\n     */\n    public inputTexture: Texture = null;\n\n    /**\n     * The back texture used for blending, if required.\n     * @type {Texture | null}\n     */\n    public backTexture?: Texture = null;\n\n    /**\n     * The list of filters to be applied.\n     * @type {Filter[]}\n     */\n    public filters: Filter[] = null;\n\n    /**\n     * The bounds of the filter area.\n     * @type {Bounds}\n     */\n    public bounds = new Bounds();\n\n    /**\n     * The container to which the filter is applied.\n     * @type {Container}\n     */\n    public container: Container = null;\n\n    /**\n     * Indicates whether blending is required for the filter.\n     * @type {boolean}\n     */\n    public blendRequired: boolean = false;\n\n    /**\n     * The render surface where the output of the filter is rendered.\n     * @type {RenderSurface}\n     */\n    public outputRenderSurface: RenderSurface = null;\n\n    /**\n     * The global frame of the filter area.\n     * @type {{ x: number, y: number, width: number, height: number }}\n     */\n    public globalFrame = { x: 0, y: 0, width: 0, height: 0 };\n\n    /**\n     * Indicates whether antialiasing is enabled for the filter.\n     * @type {boolean}\n     */\n    public antialias: boolean;\n\n    /**\n     * The resolution of the filter.\n     * @type {number}\n     */\n    public resolution: number;\n}\n\n/**\n * System that manages the filter pipeline\n * @category rendering\n * @advanced\n */\nexport class FilterSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'filter',\n    } as const;\n\n    public readonly renderer: Renderer;\n\n    private _filterStackIndex = 0;\n    private _filterStack: FilterData[] = [];\n\n    private readonly _filterGlobalUniforms = new UniformGroup({\n        uInputSize: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputPixel: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uInputClamp: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uGlobalFrame: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uOutputTexture: { value: new Float32Array(4), type: 'vec4<f32>' },\n    });\n\n    private readonly _globalFilterBindGroup: BindGroup = new BindGroup({});\n    private _activeFilterData: FilterData;\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * The back texture of the currently active filter. Requires the filter to have `blendRequired` set to true.\n     * @readonly\n     */\n    public get activeBackTexture(): Texture | undefined\n    {\n        return this._activeFilterData?.backTexture;\n    }\n\n    /**\n     * Pushes a filter instruction onto the filter stack.\n     * @param instruction - The instruction containing the filter effect and container.\n     * @internal\n     */\n    public push(instruction: FilterInstruction)\n    {\n        const renderer = this.renderer;\n\n        const filters = instruction.filterEffect.filters;\n\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        filterData.skip = false;\n\n        filterData.filters = filters as Filter[];\n        filterData.container = instruction.container;\n        filterData.outputRenderSurface = renderer.renderTarget.renderSurface;\n\n        const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        const bounds = filterData.bounds;\n\n        this._calculateFilterArea(instruction, bounds);\n\n        this._calculateFilterBounds(filterData, renderer.renderTarget.rootViewPort, rootAntialias, rootResolution, 1);\n\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        const previousFilterData = this._getPreviousFilterData();\n\n        const globalResolution = this._findFilterResolution(rootResolution);\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (previousFilterData)\n        {\n            offsetX = previousFilterData.bounds.minX;\n            offsetY = previousFilterData.bounds.minY;\n        }\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        // set all the filter data\n\n        this._setupFilterTextures(filterData, bounds, renderer, previousFilterData);\n    }\n\n    /**\n     * Applies filters to a texture.\n     *\n     * This method takes a texture and a list of filters, applies the filters to the texture,\n     * and returns the resulting texture.\n     * @param {object} params - The parameters for applying filters.\n     * @param {Texture} params.texture - The texture to apply filters to.\n     * @param {Filter[]} params.filters - The filters to apply.\n     * @returns {Texture} The resulting texture after all filters have been applied.\n     * @example\n     *\n     * ```ts\n     * // Create a texture and a list of filters\n     * const texture = new Texture(...);\n     * const filters = [new BlurFilter(), new ColorMatrixFilter()];\n     *\n     * // Apply the filters to the texture\n     * const resultTexture = filterSystem.applyToTexture({ texture, filters });\n     *\n     * // Use the resulting texture\n     * sprite.texture = resultTexture;\n     * ```\n     *\n     * Key Points:\n     * 1. padding is not currently supported here - so clipping may occur with filters that use padding.\n     * 2. If all filters are disabled or skipped, the original texture is returned.\n     */\n    public generateFilteredTexture({ texture, filters }: {texture: Texture, filters: Filter[]}): Texture\n    {\n        // get a filter data from the stack. They can be reused multiple times each frame,\n        // so we don't need to worry about overwriting them in a single pass.\n        const filterData = this._pushFilterData();\n\n        this._activeFilterData = filterData;\n        filterData.skip = false;\n\n        filterData.filters = filters;\n\n        const colorTextureSource = texture.source;\n\n        const rootResolution = colorTextureSource.resolution;\n        const rootAntialias = colorTextureSource.antialias;\n\n        // if there are no filters, we skip the pass\n        if (filters.length === 0)\n        {\n            filterData.skip = true;\n\n            return texture;\n        }\n\n        const bounds = filterData.bounds;\n\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n\n        bounds.addRect(texture.frame);\n\n        this._calculateFilterBounds(filterData, bounds.rectangle, rootAntialias, rootResolution, 0);\n\n        if (filterData.skip)\n        {\n            return texture;\n        }\n\n        const globalResolution = rootResolution;\n        const offsetX = 0;\n        const offsetY = 0;\n\n        this._calculateGlobalFrame(\n            filterData,\n            offsetX, offsetY,\n            globalResolution,\n            colorTextureSource.width,\n            colorTextureSource.height\n        );\n\n        /// /////////\n\n        // set all the filter data\n        // get a P02 texture from our pool...\n        filterData.outputRenderSurface = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        filterData.backTexture = Texture.EMPTY;\n\n        /// ///\n        // bind...\n        // TODO this might need looking at for padding!\n        filterData.inputTexture = texture;\n\n        /// ////////////// PART 2 POP //////////////////////\n\n        const renderer = this.renderer;\n\n        // TODO required? check with AA\n        renderer.renderTarget.finishRenderPass();\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n        this._applyFiltersToTexture(filterData, true);\n\n        const outputTexture = filterData.outputRenderSurface as Texture;\n\n        outputTexture.source.alphaMode = 'premultiplied-alpha';\n\n        return outputTexture;\n    }\n\n    /** @internal */\n    public pop()\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._popFilterData();\n\n        // if we are skipping this filter then we just do nothing :D\n        if (filterData.skip)\n        {\n            return;\n        }\n\n        renderer.globalUniforms.pop();\n\n        renderer.renderTarget.finishRenderPass();\n\n        this._activeFilterData = filterData;\n\n        this._applyFiltersToTexture(filterData, false);\n\n        // if we made a background texture, lets return that also\n        if (filterData.blendRequired)\n        {\n            TexturePool.returnTexture(filterData.backTexture);\n        }\n\n        // return the texture to the pool so we can reuse the next frame\n        TexturePool.returnTexture(filterData.inputTexture);\n    }\n\n    /**\n     * Copies the last render surface to a texture.\n     * @param lastRenderSurface - The last render surface to copy from.\n     * @param bounds - The bounds of the area to copy.\n     * @param previousBounds - The previous bounds to use for offsetting the copy.\n     */\n    public getBackTexture(lastRenderSurface: RenderTarget, bounds: Bounds, previousBounds?: Bounds)\n    {\n        const backgroundResolution = lastRenderSurface.colorTexture.source._resolution;\n\n        const backTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            backgroundResolution,\n            false,\n        );\n\n        let x = bounds.minX;\n        let y = bounds.minY;\n\n        if (previousBounds)\n        {\n            x -= previousBounds.minX;\n            y -= previousBounds.minY;\n        }\n\n        x = Math.floor(x * backgroundResolution);\n        y = Math.floor(y * backgroundResolution);\n\n        const width = Math.ceil(bounds.width * backgroundResolution);\n        const height = Math.ceil(bounds.height * backgroundResolution);\n\n        this.renderer.renderTarget.copyToTexture(\n            lastRenderSurface,\n            backTexture,\n            { x, y },\n            { width, height },\n            { x: 0, y: 0 }\n        );\n\n        return backTexture;\n    }\n\n    /**\n     * Applies a filter to a texture.\n     * @param filter - The filter to apply.\n     * @param input - The input texture.\n     * @param output - The output render surface.\n     * @param clear - Whether to clear the output surface before applying the filter.\n     */\n    public applyFilter(filter: Filter, input: Texture, output: RenderSurface, clear: boolean)\n    {\n        const renderer = this.renderer;\n\n        const filterData = this._activeFilterData;\n\n        const outputRenderSurface = filterData.outputRenderSurface;\n\n        const isFinalTarget = outputRenderSurface === output;\n\n        // Find the correct resolution by looking back through the filter stack\n        const rootResolution = renderer.renderTarget.rootRenderTarget.colorTexture.source._resolution;\n        const resolution = this._findFilterResolution(rootResolution);\n\n        // Calculate the offset for both outputFrame and globalFrame\n        let offsetX = 0;\n        let offsetY = 0;\n\n        if (isFinalTarget)\n        {\n            const offset = this._findPreviousFilterOffset();\n\n            offsetX = offset.x;\n            offsetY = offset.y;\n        }\n\n        this._updateFilterUniforms(input, output, filterData, offsetX, offsetY, resolution, isFinalTarget, clear);\n\n        this._setupBindGroupsAndRender(filter, input, renderer);\n    }\n\n    /**\n     * Multiply _input normalized coordinates_ to this matrix to get _sprite texture normalized coordinates_.\n     *\n     * Use `outputMatrix * vTextureCoord` in the shader.\n     * @param outputMatrix - The matrix to output to.\n     * @param {Sprite} sprite - The sprite to map to.\n     * @returns The mapped matrix.\n     */\n    public calculateSpriteMatrix(outputMatrix: Matrix, sprite: Sprite): Matrix\n    {\n        const data = this._activeFilterData;\n\n        const mappedMatrix = outputMatrix.set(\n            data.inputTexture._source.width,\n            0, 0,\n            data.inputTexture._source.height,\n            data.bounds.minX, data.bounds.minY\n        );\n\n        const worldTransform = sprite.worldTransform.copyTo(Matrix.shared);\n\n        const renderGroup = sprite.renderGroup || sprite.parentRenderGroup;\n\n        if (renderGroup && renderGroup.cacheToLocalTransform)\n        {\n            // get the matrix relative to the render group..\n            worldTransform.prepend(renderGroup.cacheToLocalTransform);\n        }\n\n        worldTransform.invert();\n        mappedMatrix.prepend(worldTransform);\n        mappedMatrix.scale(\n            1.0 / sprite.texture.frame.width,\n            1.0 / sprite.texture.frame.height\n        );\n\n        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n        return mappedMatrix;\n    }\n\n    public destroy(): void\n    {\n        // BOOM!\n    }\n\n    /**\n     * Sets up the bind groups and renders the filter.\n     * @param filter - The filter to apply\n     * @param input - The input texture\n     * @param renderer - The renderer instance\n     */\n    private _setupBindGroupsAndRender(filter: Filter, input: Texture, renderer: Renderer): void\n    {\n        // TODO - should prolly use a adaptor...\n        if ((renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            const batchUniforms = (renderer as WebGPURenderer).renderPipes.uniformBatch\n                .getUboResource(this._filterGlobalUniforms);\n\n            this._globalFilterBindGroup.setResource(batchUniforms, 0);\n        }\n        else\n        {\n            this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);\n        }\n\n        // now lets update the output texture...\n\n        // set bind group..\n        this._globalFilterBindGroup.setResource(input.source, 1);\n        this._globalFilterBindGroup.setResource(input.source.style, 2);\n\n        filter.groups[0] = this._globalFilterBindGroup;\n\n        renderer.encoder.draw({\n            geometry: quadGeometry,\n            shader: filter,\n            state: filter._state,\n            topology: 'triangle-list'\n        });\n\n        // WebGPU blit's automatically, but WebGL does not!\n        if (renderer.type === RendererType.WEBGL)\n        {\n            renderer.renderTarget.finishRenderPass();\n        }\n    }\n\n    /**\n     * Sets up the filter textures including input texture and back texture if needed.\n     * @param filterData - The filter data to update\n     * @param bounds - The bounds for the texture\n     * @param renderer - The renderer instance\n     * @param previousFilterData - The previous filter data for back texture calculation\n     */\n    private _setupFilterTextures(\n        filterData: FilterData,\n        bounds: Bounds,\n        renderer: Renderer,\n        previousFilterData: FilterData | null\n    ): void\n    {\n        // set all the filter data\n        filterData.backTexture = Texture.EMPTY;\n\n        if (filterData.blendRequired)\n        {\n            renderer.renderTarget.finishRenderPass();\n            // this actually forces the current commandQueue to render everything so far.\n            // if we don't do this, we won't be able to copy pixels for the background\n            const renderTarget = renderer.renderTarget.getRenderTarget(filterData.outputRenderSurface);\n\n            filterData.backTexture = this.getBackTexture(renderTarget, bounds, previousFilterData?.bounds);\n        }\n\n        /// ///\n        // bind...\n        // get a P02 texture from our pool...\n        filterData.inputTexture = TexturePool.getOptimalTexture(\n            bounds.width,\n            bounds.height,\n            filterData.resolution,\n            filterData.antialias,\n        );\n\n        renderer.renderTarget.bind(filterData.inputTexture, true);\n        // set the global uniforms to take into account the bounds offset required\n\n        renderer.globalUniforms.push({\n            offset: bounds,\n        });\n    }\n\n    /**\n     * Calculates and sets the global frame for the filter.\n     * @param filterData - The filter data to update\n     * @param offsetX - The X offset\n     * @param offsetY - The Y offset\n     * @param globalResolution - The global resolution\n     * @param sourceWidth - The source texture width\n     * @param sourceHeight - The source texture height\n     */\n    private _calculateGlobalFrame(\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        globalResolution: number,\n        sourceWidth: number,\n        sourceHeight: number\n    ): void\n    {\n        const globalFrame = filterData.globalFrame;\n\n        globalFrame.x = offsetX * globalResolution;\n        globalFrame.y = offsetY * globalResolution;\n        globalFrame.width = sourceWidth * globalResolution;\n        globalFrame.height = sourceHeight * globalResolution;\n    }\n\n    /**\n     * Updates the filter uniforms with the current filter state.\n     * @param input - The input texture\n     * @param output - The output render surface\n     * @param filterData - The current filter data\n     * @param offsetX - The X offset for positioning\n     * @param offsetY - The Y offset for positioning\n     * @param resolution - The current resolution\n     * @param isFinalTarget - Whether this is the final render target\n     * @param clear - Whether to clear the output surface\n     */\n    private _updateFilterUniforms(\n        input: Texture,\n        output: RenderSurface,\n        filterData: FilterData,\n        offsetX: number,\n        offsetY: number,\n        resolution: number,\n        isFinalTarget: boolean,\n        clear: boolean\n    ): void\n    {\n        const uniforms = this._filterGlobalUniforms.uniforms;\n        const outputFrame = uniforms.uOutputFrame;\n        const inputSize = uniforms.uInputSize;\n        const inputPixel = uniforms.uInputPixel;\n        const inputClamp = uniforms.uInputClamp;\n        const globalFrame = uniforms.uGlobalFrame;\n        const outputTexture = uniforms.uOutputTexture;\n\n        // are we rendering back to the original surface?\n        if (isFinalTarget)\n        {\n            outputFrame[0] = filterData.bounds.minX - offsetX;\n            outputFrame[1] = filterData.bounds.minY - offsetY;\n        }\n        else\n        {\n            outputFrame[0] = 0;\n            outputFrame[1] = 0;\n        }\n\n        outputFrame[2] = input.frame.width;\n        outputFrame[3] = input.frame.height;\n\n        inputSize[0] = input.source.width;\n        inputSize[1] = input.source.height;\n        inputSize[2] = 1 / inputSize[0];\n        inputSize[3] = 1 / inputSize[1];\n\n        inputPixel[0] = input.source.pixelWidth;\n        inputPixel[1] = input.source.pixelHeight;\n        inputPixel[2] = 1.0 / inputPixel[0];\n        inputPixel[3] = 1.0 / inputPixel[1];\n\n        inputClamp[0] = 0.5 * inputPixel[2];\n        inputClamp[1] = 0.5 * inputPixel[3];\n        inputClamp[2] = (input.frame.width * inputSize[2]) - (0.5 * inputPixel[2]);\n        inputClamp[3] = (input.frame.height * inputSize[3]) - (0.5 * inputPixel[3]);\n\n        const rootTexture = this.renderer.renderTarget.rootRenderTarget.colorTexture;\n\n        globalFrame[0] = offsetX * resolution;\n        globalFrame[1] = offsetY * resolution;\n        globalFrame[2] = rootTexture.source.width * resolution;\n        globalFrame[3] = rootTexture.source.height * resolution;\n\n        // we are going to overwrite resource we can set it to null!\n        if (output instanceof Texture) output.source.resource = null;\n\n        // set the output texture - this is where we are going to render to\n        const renderTarget = this.renderer.renderTarget.getRenderTarget(output);\n\n        this.renderer.renderTarget.bind(output, !!clear);\n\n        if (output instanceof Texture)\n        {\n            outputTexture[0] = output.frame.width;\n            outputTexture[1] = output.frame.height;\n        }\n        else\n        {\n            // this means a renderTarget was passed directly\n            outputTexture[0] = renderTarget.width;\n            outputTexture[1] = renderTarget.height;\n        }\n\n        outputTexture[2] = renderTarget.isRoot ? -1 : 1;\n\n        this._filterGlobalUniforms.update();\n    }\n\n    /**\n     * Finds the correct resolution by looking back through the filter stack.\n     * @param rootResolution - The fallback root resolution to use\n     * @returns The resolution from the previous filter or root resolution\n     */\n    private _findFilterResolution(rootResolution: number): number\n    {\n        let currentIndex = this._filterStackIndex - 1;\n\n        while (currentIndex > 0 && this._filterStack[currentIndex].skip)\n        {\n            --currentIndex;\n        }\n\n        return currentIndex > 0 && this._filterStack[currentIndex].inputTexture\n            ? this._filterStack[currentIndex].inputTexture.source._resolution\n            : rootResolution;\n    }\n\n    /**\n     * Finds the offset from the previous non-skipped filter in the stack.\n     * @returns The offset coordinates from the previous filter\n     */\n    private _findPreviousFilterOffset(): { x: number, y: number }\n    {\n        let offsetX = 0;\n        let offsetY = 0;\n        let lastIndex = this._filterStackIndex;\n\n        while (lastIndex > 0)\n        {\n            lastIndex--;\n            const prevFilterData = this._filterStack[lastIndex];\n\n            if (!prevFilterData.skip)\n            {\n                offsetX = prevFilterData.bounds.minX;\n                offsetY = prevFilterData.bounds.minY;\n                break;\n            }\n        }\n\n        return { x: offsetX, y: offsetY };\n    }\n\n    /**\n     * Calculates the filter area bounds based on the instruction type.\n     * @param instruction - The filter instruction\n     * @param bounds - The bounds object to populate\n     */\n    private _calculateFilterArea(instruction: FilterInstruction, bounds: Bounds): void\n    {\n        // this path is used by the blend modes mostly!\n        // they collect all renderables and push them into a list.\n        // this list is then used to calculate the bounds of the filter area\n        if (instruction.renderables)\n        {\n            getGlobalRenderableBounds(instruction.renderables, bounds);\n        }\n        // if a filterArea is provided, we save our selves some measuring and just use that area supplied\n        else if (instruction.filterEffect.filterArea)\n        {\n            bounds.clear();\n\n            // transform the filterArea into global space..\n            bounds.addRect(instruction.filterEffect.filterArea);\n\n            // new for v8, we transform the bounds into the space of the container\n            bounds.applyMatrix(instruction.container.worldTransform);\n        }\n        // classic filter path, we get the bounds of the container and use it by recursively\n        // measuring.\n        else\n        {\n            // we want to factor render layers to get the real visual bounds of this container.\n            // so the last param is true..\n            instruction.container.getFastGlobalBounds(true, bounds);\n        }\n\n        if (instruction.container)\n        {\n            // When a container is cached as a texture, its filters need to be applied relative to its\n            // cached parent's coordinate space rather than world space. This transform adjustment ensures\n            // filters are applied in the correct coordinate system.\n            const renderGroup = instruction.container.renderGroup || instruction.container.parentRenderGroup;\n            const filterFrameTransform = renderGroup.cacheToLocalTransform;\n\n            if (filterFrameTransform)\n            {\n                bounds.applyMatrix(filterFrameTransform);\n            }\n        }\n    }\n\n    private _applyFiltersToTexture(filterData: FilterData, clear: boolean)\n    {\n        const inputTexture = filterData.inputTexture;\n\n        const bounds = filterData.bounds;\n\n        const filters = filterData.filters;\n\n        // get a BufferResource from the uniformBatch.\n        // this will batch the shader uniform data and give us a buffer resource we can\n        // set on our globalUniform Bind Group\n\n        // update the resources on the bind group...\n        this._globalFilterBindGroup.setResource(inputTexture.source.style, 2);\n        this._globalFilterBindGroup.setResource(filterData.backTexture.source, 3);\n\n        if (filters.length === 1)\n        {\n            // render a single filter...\n            filters[0].apply(this, inputTexture, filterData.outputRenderSurface, clear);\n        }\n        else\n        {\n            let flip = filterData.inputTexture;\n\n            const tempTexture = TexturePool.getOptimalTexture(\n                bounds.width,\n                bounds.height,\n                flip.source._resolution,\n                false\n            );\n\n            // get another texture that we will render the next filter too\n            let flop = tempTexture;\n\n            let i = 0;\n\n            // loop and apply the filters, omitting the last one as we will render that to the final target\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                const filter = filters[i];\n\n                filter.apply(this, flip, flop, true);\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, filterData.outputRenderSurface, clear);\n\n            // return those textures for later!\n            TexturePool.returnTexture(tempTexture);\n        }\n    }\n\n    private _calculateFilterBounds(\n        filterData: FilterData,\n        viewPort: Rectangle,\n        rootAntialias: boolean,\n        rootResolution: number,\n        // a multiplier padding for the bounds calculation\n        // this prop is used when applying filters to textures\n        // as the should have padding applied to them already (until we fix padding when applying them to textures)\n        // set to 0 to remove padding from the bounds calculation\n        paddingMultiplier: number\n    )\n    {\n        const renderer = this.renderer;\n\n        const bounds = filterData.bounds;\n        const filters = filterData.filters;\n\n        // get GLOBAL bounds of the item we are going to apply the filter to\n\n        // next we get the settings for the filter\n        // we need to find the LOWEST resolution for the filter list\n        let resolution = Infinity;\n        // Padding is additive to add padding to our padding\n        let padding = 0;\n        // if this is true for all filter, it should be true, and otherwise false\n        let antialias = true;\n        // true if any filter requires the previous render target\n        let blendRequired = false;\n        // true if any filter in the list is enabled\n        let enabled = false;\n        // false if any filter in the list has false\n        let clipToViewport = true;\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            const filter = filters[i];\n\n            resolution = Math.min(resolution, filter.resolution === 'inherit'\n                ? rootResolution : filter.resolution);\n            padding += filter.padding;\n\n            if (filter.antialias === 'off')\n            {\n                antialias = false;\n            }\n            else if (filter.antialias === 'inherit')\n            {\n                antialias &&= rootAntialias;\n            }\n\n            if (!filter.clipToViewport)\n            {\n                clipToViewport = false;\n            }\n\n            const isCompatible = !!(filter.compatibleRenderers & renderer.type);\n\n            if (!isCompatible)\n            {\n                enabled = false;\n                break;\n            }\n\n            if (filter.blendRequired && !((renderer as WebGLRenderer).backBuffer?.useBackBuffer ?? true))\n            {\n                // #if _DEBUG\n                // eslint-disable-next-line max-len\n                warn('Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options.');\n                // #endif\n\n                enabled = false;\n                break;\n            }\n\n            enabled = filter.enabled || enabled;\n            blendRequired ||= filter.blendRequired;\n        }\n\n        // if no filters are enabled lets skip!\n        if (!enabled)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // here we constrain the bounds to the viewport we will render too\n        // this should not take into account the x, y offset of the viewport - as this is\n        // handled by the viewport on the gpu.\n        if (clipToViewport)\n        {\n            bounds.fitBounds(0, viewPort.width / rootResolution, 0, viewPort.height / rootResolution);\n        }\n\n        // round the bounds to the nearest pixel\n        bounds\n            .scale(resolution)\n            .ceil()\n            .scale(1 / resolution)\n            .pad((padding | 0) * paddingMultiplier);\n\n        // skip if the bounds are negative or zero as this means they are\n        // not visible on the screen\n        if (!bounds.isPositive)\n        {\n            filterData.skip = true;\n\n            return;\n        }\n\n        // set the global frame to the root texture\n\n        // get previous bounds.. we must take into account skipped filters also..\n\n        // // to find the previous resolution we need to account for the skipped filters\n        // // the following will find the last non skipped filter...\n\n        // store the values that will be used to apply the filters\n        filterData.antialias = antialias;\n        filterData.resolution = resolution;\n        filterData.blendRequired = blendRequired;\n    }\n\n    private _popFilterData(): FilterData\n    {\n        this._filterStackIndex--;\n\n        return this._filterStack[this._filterStackIndex];\n    }\n\n    private _getPreviousFilterData(): FilterData | null\n    {\n        let previousFilterData: FilterData;\n\n        let index = this._filterStackIndex - 1;\n\n        while (index > 1)\n        {\n            index--;\n            previousFilterData = this._filterStack[index];\n\n            if (!previousFilterData.skip)\n            {\n                break;\n            }\n        }\n\n        return previousFilterData;\n    }\n\n    private _pushFilterData(): FilterData\n    {\n        let filterData = this._filterStack[this._filterStackIndex];\n\n        if (!filterData)\n        {\n            filterData = this._filterStack[this._filterStackIndex] = new FilterData();\n        }\n\n        this._filterStackIndex++;\n\n        return filterData;\n    }\n}\n\n","import type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Bounds } from './Bounds';\n\n/**\n * @param renderables\n * @param bounds\n * @internal\n */\nexport function getGlobalRenderableBounds(renderables: Renderable[], bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    // instead of copying the matrix each time we are assigning it in bounds\n    // this is a performance hack :D\n    // so we need to restore the matrix after we are done\n\n    const tempMatrix = bounds.matrix;\n\n    for (let i = 0; i < renderables.length; i++)\n    {\n        const renderable = renderables[i];\n\n        if (renderable.globalDisplayStatus < 0b111)\n        {\n            continue;\n        }\n\n        bounds.matrix = renderable.worldTransform;\n        bounds.addBounds(renderable.bounds);\n    }\n\n    bounds.matrix = tempMatrix;\n\n    return bounds;\n}\n","import { extensions } from '../extensions/Extensions';\nimport { FilterPipe } from './FilterPipe';\nimport { FilterSystem } from './FilterSystem';\n\nextensions.add(FilterSystem);\nextensions.add(FilterPipe);\n","import type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GlParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const state = particleContainerPipe.state;\n        const renderer = particleContainerPipe.renderer as WebGLRenderer;\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.resources.uTexture = container.texture._source;\n        shader.resources.uniforms = particleContainerPipe.localUniforms;\n\n        const gl = renderer.gl;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        // now lets upload and render the buffers..\n        renderer.shader.bind(shader);\n        renderer.state.set(state);\n        renderer.geometry.bind(buffer.geometry, shader.glProgram);\n\n        const byteSize = buffer.geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n        const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n        gl.drawElements(gl.TRIANGLES, container.particleChildren.length * 6, glType, 0);\n    }\n}\n","/**\n * Generic Mask Stack data structure\n * @function createIndicesForQuads\n * @param {number} size - Number of quads\n * @param {Uint16Array|Uint32Array} [outBuffer] - Buffer for output, length has to be `6 * size`\n * @returns {Uint16Array|Uint32Array} - Resulting index buffer\n * @internal\n */\nexport function createIndicesForQuads(\n    size: number,\n    outBuffer: Uint16Array | Uint32Array | null = null\n): Uint16Array | Uint32Array\n{\n    // the total number of indices in our array, there are 6 points per quad.\n    const totalIndices = size * 6;\n\n    // Check if we need to use Uint32Array\n    if (totalIndices > 65535)\n    {\n        outBuffer ||= new Uint32Array(totalIndices); // Use Uint32Array if needed\n    }\n    else\n    {\n        outBuffer ||= new Uint16Array(totalIndices);\n    }\n\n    if (outBuffer.length !== totalIndices)\n    {\n        throw new Error(`Out buffer length is incorrect, got ${outBuffer.length} and expected ${totalIndices}`);\n    }\n\n    // fill the indices with the quads to draw\n    for (let i = 0, j = 0; i < totalIndices; i += 6, j += 4)\n    {\n        outBuffer[i + 0] = j + 0;\n        outBuffer[i + 1] = j + 1;\n        outBuffer[i + 2] = j + 2;\n        outBuffer[i + 3] = j + 0;\n        outBuffer[i + 4] = j + 2;\n        outBuffer[i + 5] = j + 3;\n    }\n\n    return outBuffer;\n}\n","import {\n    getAttributeInfoFromFormat\n} from '../../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { IParticle } from '../Particle';\nimport type { ParticleRendererProperty } from '../particleData';\n\n// TODO rename to update function\n/** @internal */\nexport type ParticleUpdateFunction = (ps: IParticle[], f32v: Float32Array, u32v: Uint32Array) => void;\n\n/**\n * @param properties\n * @internal\n */\nexport function generateParticleUpdateFunction(properties: Record<string, ParticleRendererProperty>)\n{\n    return {\n        dynamicUpdate: generateUpdateFunction(properties, true),\n        staticUpdate: generateUpdateFunction(properties, false),\n    };\n}\n\nfunction generateUpdateFunction(\n    properties: Record<string, ParticleRendererProperty>,\n    dynamic: boolean\n): ParticleUpdateFunction\n{\n    const funcFragments: string[] = [];\n\n    funcFragments.push(`\n\n        var index = 0;\n\n        for (let i = 0; i < ps.length; ++i)\n        {\n            const p = ps[i];\n\n            `);\n\n    let offset = 0;\n\n    for (const i in properties)\n    {\n        const property = properties[i];\n\n        if (dynamic !== property.dynamic) continue;\n\n        funcFragments.push(`offset = index + ${offset}`);\n\n        funcFragments.push(property.code);\n\n        const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n        offset += attributeInfo.stride / 4;\n    }\n\n    funcFragments.push(`\n            index += stride * 4;\n        }\n    `);\n\n    // add to the front..\n    funcFragments.unshift(`\n        var stride = ${offset};\n    `);\n\n    const functionSource = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function('ps', 'f32v', 'u32v', functionSource) as ParticleUpdateFunction;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { getAttributeInfoFromFormat } from '../../../rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { createIndicesForQuads } from './utils/createIndicesForQuads';\nimport { generateParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\nimport type { IndexBufferArray } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport type { IParticle } from './Particle';\nimport type { ParticleRendererProperty } from './particleData';\nimport type { ParticleUpdateFunction } from './utils/generateParticleUpdateFunction';\n\n/**\n * Options for creating a ParticleBuffer.\n * @internal\n */\nexport interface ParticleBufferOptions\n{\n    /** The size of the particle buffer, defaults to 1000. */\n    size: number;\n    /** A record of attributes that the particle container uses. */\n    properties: Record<string, ParticleRendererProperty>;\n}\n\n/**\n * The ParticleBuffer holds the buffers and geometry for a particle container.\n * It also contains the upload functions for the static and dynamic properties.\n * @internal\n */\nexport class ParticleBuffer\n{\n    /** The buffer containing static attribute data for all elements in the batch. */\n    public staticAttributeBuffer: ViewableBuffer;\n    /** The buffer containing dynamic attribute data for all elements in the batch. */\n    public dynamicAttributeBuffer: ViewableBuffer;\n\n    private readonly _staticBuffer: Buffer;\n    private readonly _dynamicBuffer: Buffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    private readonly _dynamicStride: number;\n    private readonly _staticStride: number;\n\n    /** The geometry of the particle buffer. */\n    public readonly geometry: Geometry;\n\n    private _size = 0;\n    private readonly _dynamicUpload: ParticleUpdateFunction;\n    private readonly _staticUpload: ParticleUpdateFunction;\n    private readonly _generateParticleUpdateCache: Record<string, {\n        dynamicUpdate: ParticleUpdateFunction;\n        staticUpdate: ParticleUpdateFunction;\n    }> = {};\n\n    constructor(options: ParticleBufferOptions)\n    {\n        // size in sprites!\n        const size = this._size = options.size ?? 1000;\n\n        // TODO add the option to specify what is dynamic!\n        const properties = options.properties;\n\n        // in bytes!\n        let staticVertexSize = 0;\n        let dynamicVertexSize = 0;\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                // dynamic.\n                dynamicVertexSize += attributeInfo.stride;\n            }\n            else\n            {\n                // static.\n                staticVertexSize += attributeInfo.stride;\n            }\n        }\n\n        this._dynamicStride = dynamicVertexSize / 4;\n        this._staticStride = staticVertexSize / 4;\n\n        this.staticAttributeBuffer = new ViewableBuffer(size * 4 * staticVertexSize);\n        this.dynamicAttributeBuffer = new ViewableBuffer(size * 4 * dynamicVertexSize);\n\n        this.indexBuffer = createIndicesForQuads(size);\n\n        // build geometry..\n\n        const geometry = new Geometry();\n\n        let dynamicOffset = 0;\n        let staticOffset = 0;\n\n        this._staticBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'static-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        this._dynamicBuffer = new Buffer({\n            data: new Float32Array(1),\n            label: 'dynamic-particle-buffer',\n            shrinkToFit: false,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST\n        });\n\n        for (const i in properties)\n        {\n            const property = properties[i];\n            const attributeInfo = getAttributeInfoFromFormat(property.format);\n\n            if (property.dynamic)\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._dynamicBuffer,\n                    stride: this._dynamicStride * 4,\n                    offset: dynamicOffset * 4,\n                    format: property.format,\n                });\n                dynamicOffset += attributeInfo.size;\n            }\n            else\n            {\n                geometry.addAttribute(property.attributeName, {\n                    buffer: this._staticBuffer,\n                    stride: this._staticStride * 4,\n                    offset: staticOffset * 4,\n                    format: property.format,\n                });\n                staticOffset += attributeInfo.size;\n            }\n        }\n\n        geometry.addIndex(this.indexBuffer);\n\n        const uploadFunction = this.getParticleUpdate(properties);\n\n        this._dynamicUpload = uploadFunction.dynamicUpdate;\n        this._staticUpload = uploadFunction.staticUpdate;\n\n        this.geometry = geometry;\n    }\n\n    public getParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        const key = getParticleSyncKey(properties);\n\n        if (this._generateParticleUpdateCache[key])\n        {\n            return this._generateParticleUpdateCache[key];\n        }\n\n        this._generateParticleUpdateCache[key] = this.generateParticleUpdate(properties);\n\n        return this._generateParticleUpdateCache[key];\n    }\n\n    public generateParticleUpdate(properties: Record<string, ParticleRendererProperty>)\n    {\n        return generateParticleUpdateFunction(properties);\n    }\n\n    public update(particles: IParticle[], uploadStatic: boolean)\n    {\n        // first resize the buffers if needed!\n        // TODO resize!\n        if (particles.length > this._size)\n        {\n            uploadStatic = true;\n\n            this._size = Math.max(particles.length, (this._size * 1.5) | 0);\n\n            this.staticAttributeBuffer = new ViewableBuffer(this._size * this._staticStride * 4 * 4);\n            this.dynamicAttributeBuffer = new ViewableBuffer(this._size * this._dynamicStride * 4 * 4);\n            this.indexBuffer = createIndicesForQuads(this._size);\n\n            this.geometry.indexBuffer.setDataWithSize(\n                this.indexBuffer, this.indexBuffer.byteLength, true);\n        }\n\n        const dynamicAttributeBuffer = this.dynamicAttributeBuffer;\n\n        this._dynamicUpload(particles, dynamicAttributeBuffer.float32View, dynamicAttributeBuffer.uint32View);\n\n        this._dynamicBuffer.setDataWithSize(\n            this.dynamicAttributeBuffer.float32View, particles.length * this._dynamicStride * 4, true);\n\n        if (uploadStatic)\n        {\n            const staticAttributeBuffer = this.staticAttributeBuffer;\n\n            this._staticUpload(particles, staticAttributeBuffer.float32View, staticAttributeBuffer.uint32View);\n\n            this._staticBuffer.setDataWithSize(\n                staticAttributeBuffer.float32View, particles.length * this._staticStride * 4, true);\n        }\n    }\n\n    public destroy()\n    {\n        this._staticBuffer.destroy();\n        this._dynamicBuffer.destroy();\n        this.geometry.destroy();\n    }\n}\n\nfunction getParticleSyncKey(properties: Record<string, ParticleRendererProperty>)\n{\n    const keyGen: string[] = [];\n\n    for (const key in properties)\n    {\n        const property = properties[key];\n\n        keyGen.push(key, property.code, property.dynamic ? 'd' : 's');\n    }\n\n    return keyGen.join('_');\n}\n\n","import { Color } from '../../../../color/Color';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { GlProgram } from '../../../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../../../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../../rendering/renderers/shared/texture/Texture';\nimport { TextureStyle } from '../../../../rendering/renderers/shared/texture/TextureStyle';\nimport fragment from './particles.frag';\nimport vertex from './particles.vert';\nimport wgsl from './particles.wgsl';\n\n/** @internal */\nexport class ParticleShader extends Shader\n{\n    constructor()\n    {\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment\n        });\n\n        const gpuProgram = GpuProgram.from({\n            fragment: {\n                source: wgsl,\n                entryPoint: 'mainFragment'\n            },\n            vertex: {\n                source: wgsl,\n                entryPoint: 'mainVertex'\n            }\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                // this will be replaced with the texture from the particle container\n                uTexture: Texture.WHITE.source,\n                // this will be replaced with the texture style from the particle container\n                uSampler: new TextureStyle({}),\n                // this will be replaced with the local uniforms from the particle container\n                uniforms: {\n                    uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n                    uColor: { value: new Color(0xFFFFFF), type: 'vec4<f32>' },\n                    uRound: { value: 1, type: 'f32' },\n                    uResolution: { value: [0, 0], type: 'vec2<f32>' },\n                }\n            }\n        });\n    }\n}\n","import { Matrix } from '../../../maths/matrix/Matrix';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\nimport { getAdjustedBlendModeBlend } from '../../../rendering/renderers/shared/state/getAdjustedBlendModeBlend';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { color32BitToUniform } from '../../graphics/gpu/colorToUniform';\nimport { ParticleBuffer } from './ParticleBuffer';\nimport { ParticleShader } from './shader/ParticleShader';\n\nimport type { InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { Renderer } from '../../../rendering/renderers/types';\nimport type { ParticleContainer } from './ParticleContainer';\n\n/** @internal */\nexport interface ParticleContainerAdaptor\n{\n    execute(particleContainerPop: ParticleContainerPipe, container: ParticleContainer): void;\n}\n\n/**\n * Renderer for Particles that is designer for speed over feature set.\n * @category scene\n * @internal\n */\nexport class ParticleContainerPipe implements RenderPipe<ParticleContainer>\n{\n    /** The default shader that is used if a sprite doesn't have a more specific one. */\n    public defaultShader: Shader;\n\n    /** @internal */\n    public adaptor: ParticleContainerAdaptor;\n    /** @internal */\n    public readonly state = State.for2d();\n    /** @internal */\n    public readonly renderer: Renderer;\n\n    /** Local uniforms that are used for rendering particles. */\n    public readonly localUniforms = new UniformGroup({\n        uTranslationMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n        uColor: { value: new Float32Array(4), type: 'vec4<f32>' },\n        uRound: { value: 1, type: 'f32' },\n        uResolution: { value: [0, 0], type: 'vec2<f32>' },\n    });\n\n    /**\n     * @param renderer - The renderer this sprite batch works for.\n     * @param adaptor\n     */\n    constructor(renderer: Renderer, adaptor: ParticleContainerAdaptor)\n    {\n        this.renderer = renderer;\n\n        this.adaptor = adaptor;\n\n        this.defaultShader = new ParticleShader();\n\n        this.state = State.for2d();\n    }\n\n    public validateRenderable(_renderable: ParticleContainer): boolean\n    {\n        // always fine :D\n        return false;\n    }\n\n    public addRenderable(renderable: ParticleContainer, instructionSet: InstructionSet)\n    {\n        this.renderer.renderPipes.batch.break(instructionSet);\n        instructionSet.add(renderable);\n    }\n\n    public getBuffers(renderable: ParticleContainer): ParticleBuffer\n    {\n        return renderable._gpuData[this.renderer.uid] || this._initBuffer(renderable);\n    }\n\n    private _initBuffer(renderable: ParticleContainer): ParticleBuffer\n    {\n        renderable._gpuData[this.renderer.uid] = new ParticleBuffer({\n            size: renderable.particleChildren.length,\n            properties: renderable._properties,\n        });\n\n        return renderable._gpuData[this.renderer.uid];\n    }\n\n    public updateRenderable(_renderable: ParticleContainer)\n    {\n        // nothing to be done here!\n\n    }\n\n    public execute(container: ParticleContainer): void\n    {\n        const children = container.particleChildren;\n\n        if (children.length === 0)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const buffer = this.getBuffers(container);\n\n        container.texture ||= children[0].texture;\n\n        const state = this.state;\n\n        buffer.update(children, container._childrenDirty);\n        container._childrenDirty = false;\n\n        state.blendMode = getAdjustedBlendModeBlend(container.blendMode, container.texture._source);\n\n        const uniforms = this.localUniforms.uniforms;\n\n        const transformationMatrix = uniforms.uTranslationMatrix;\n\n        container.worldTransform.copyTo(transformationMatrix);\n\n        transformationMatrix.prepend(renderer.globalUniforms.globalUniformData.projectionMatrix);\n\n        uniforms.uResolution = renderer.globalUniforms.globalUniformData.resolution;\n        uniforms.uRound = renderer._roundPixels | container._roundPixels;\n\n        color32BitToUniform(\n            container.groupColorAlpha,\n            uniforms.uColor,\n            0\n        );\n\n        this.adaptor.execute(this, container);\n    }\n\n    /** Destroys the ParticleRenderer. */\n    public destroy(): void\n    {\n        if (this.defaultShader)\n        {\n            this.defaultShader.destroy();\n            this.defaultShader = null;\n        }\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GlParticleContainerAdaptor } from '../gl/GlParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGLRenderer } from '../../../rendering/renderers/gl/WebGLRenderer';\n\n/**\n * WebGL renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GlParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGLRenderer)\n    {\n        super(renderer, new GlParticleContainerAdaptor());\n    }\n}\n","import type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { ParticleContainer } from '../shared/ParticleContainer';\nimport type { ParticleContainerAdaptor, ParticleContainerPipe } from '../shared/ParticleContainerPipe';\n\n/** @internal */\nexport class GpuParticleContainerAdaptor implements ParticleContainerAdaptor\n{\n    public execute(particleContainerPipe: ParticleContainerPipe, container: ParticleContainer)\n    {\n        const renderer = particleContainerPipe.renderer as WebGPURenderer;\n\n        const shader = container.shader || particleContainerPipe.defaultShader;\n\n        shader.groups[0] = renderer.renderPipes.uniformBatch.getUniformBindGroup(particleContainerPipe.localUniforms, true);\n\n        shader.groups[1] = renderer.texture.getTextureBindGroup(container.texture);\n\n        const state = particleContainerPipe.state;\n\n        const buffer = particleContainerPipe.getBuffers(container);\n\n        renderer.encoder.draw({\n            geometry: buffer.geometry,\n            shader: container.shader || particleContainerPipe.defaultShader,\n            state,\n            size: container.particleChildren.length * 6,\n        });\n    }\n}\n","import { ExtensionType } from '../../../extensions/Extensions';\nimport { GpuParticleContainerAdaptor } from '../gpu/GpuParticleContainerAdaptor';\nimport { ParticleContainerPipe } from './ParticleContainerPipe';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\n\n/**\n * WebGPU renderer for Particles that is designed for speed over feature set.\n * @category scene\n * @internal\n */\nexport class GpuParticleContainerPipe extends ParticleContainerPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'particle',\n    } as const;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer, new GpuParticleContainerAdaptor());\n    }\n}\n","import { extensions } from '../../extensions/Extensions';\nimport { GlParticleContainerPipe } from './shared/GlParticleContainerPipe';\nimport { GpuParticleContainerPipe } from './shared/GpuParticleContainerPipe';\n\n// NOTE: this is the first occurrence of needing both gl and gpu pipes in the same file\n// This could cause some issues with tree shaking in the future.\n// Right now these two files do not import anything specific for a renderer, so is not an issue for now.\nextensions.add(GlParticleContainerPipe);\nextensions.add(GpuParticleContainerPipe);\n","import { updateQuadBounds } from '../../../utils/data/updateQuadBounds';\nimport { type BatchableSprite } from '../../sprite/BatchableSprite';\nimport { type AbstractText } from '../AbstractText';\nimport { type TextStyle, type TextStyleOptions } from '../TextStyle';\n\n/**\n * Updates the bounds of the given batchable sprite based on the provided text object.\n *\n * This function adjusts the bounds of the batchable sprite to match the dimensions\n * and anchor point of the text's texture. Additionally, it compensates for any padding\n * specified in the text's style to ensure the text is rendered correctly on screen.\n * @param {BatchableSprite} batchableSprite - The sprite whose bounds need to be updated.\n * @param {AbstractText} text - The text object containing the texture and style information.\n * @internal\n */\nexport function updateTextBounds(batchableSprite: BatchableSprite, text: AbstractText<TextStyle, TextStyleOptions>)\n{\n    const { texture, bounds } = batchableSprite;\n    const padding = text._style._getFinalPadding();\n\n    // When HTML text textures are created, they include the padding around the text content\n    // to prevent text clipping and provide a buffer zone. This padding is built into\n    // the texture itself. However, we don't want this padding to affect the text's\n    // actual position on screen.\n\n    // First, calculate bounds using the full padded texture\n    updateQuadBounds(bounds, text._anchor, texture);\n\n    // Then adjust by the padding amount to compensate for the buffer zone\n    // This shifts the render position back by the padding amount, ensuring the text\n    // appears exactly where intended while maintaining the buffer zone around it.\n    const paddingOffset = text._anchor._x * padding * 2;\n    const paddingOffsetY = text._anchor._y * padding * 2;\n\n    bounds.minX -= padding - paddingOffset;\n    bounds.minY -= padding - paddingOffsetY;\n    bounds.maxX -= padding - paddingOffset;\n    bounds.maxY -= padding - paddingOffsetY;\n}\n","/**\n * @param rgb\n * @param alpha\n * @param out\n * @param offset\n * @internal\n */\nexport function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\n/**\n * @param abgr\n * @param out\n * @param offset\n * @internal\n */\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n","import { Buffer } from '../../../rendering/renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../../rendering/renderers/shared/buffer/const';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { BatchMode } from '../../graphics/shared/GraphicsContext';\n\n/**\n * Options for the mesh geometry.\n * @category scene\n * @advanced\n */\nexport interface MeshGeometryOptions\n{\n    /** The positions of the mesh. */\n    positions?: Float32Array;\n    /** The UVs of the mesh. If not provided, they will be filled with 0 and match the size of the positions. */\n    uvs?: Float32Array;\n    /** The indices of the mesh. */\n    indices?: Uint32Array;\n    /** The topology of the mesh. */\n    topology?: Topology;\n    /** Whether to shrink the buffers to fit the data. */\n    shrinkBuffersToFit?: boolean;\n}\n\n/**\n * A geometry used to batch multiple meshes with the same texture.\n * @category scene\n * @advanced\n */\nexport class MeshGeometry extends Geometry\n{\n    public static defaultOptions: MeshGeometryOptions = {\n        topology: 'triangle-list',\n        shrinkBuffersToFit: false,\n    };\n\n    public batchMode: BatchMode = 'auto';\n\n    /**\n     * @param {MeshGeometryOptions} options - The options of the mesh geometry.\n     */\n    constructor(options: MeshGeometryOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(positions: Float32Array, uvs: Float32Array, indices: Uint32Array);\n    constructor(...args: [MeshGeometryOptions] | [Float32Array, Float32Array, Uint32Array])\n    {\n        let options = args[0] ?? {};\n\n        if (options instanceof Float32Array)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new MeshGeometry({ positions, uvs, indices }) instead');\n            // #endif\n\n            options = {\n                positions: options,\n                uvs: args[1],\n                indices: args[2],\n            };\n        }\n\n        options = { ...MeshGeometry.defaultOptions, ...options };\n\n        const positions = options.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n\n        let uvs = options.uvs;\n\n        if (!uvs)\n        {\n            if (options.positions)\n            {\n                uvs = new Float32Array(positions.length);\n            }\n            else\n            {\n                uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n            }\n        }\n\n        const indices = options.indices || new Uint32Array([0, 1, 2, 0, 2, 3]);\n\n        const shrinkToFit = options.shrinkBuffersToFit;\n\n        const positionBuffer = new Buffer({\n            data: positions,\n            label: 'attribute-mesh-positions',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const uvBuffer = new Buffer({\n            data: uvs,\n            label: 'attribute-mesh-uvs',\n            shrinkToFit,\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n        });\n\n        const indexBuffer = new Buffer({\n            data: indices,\n            label: 'index-mesh-buffer',\n            shrinkToFit,\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n        });\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: positionBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: uvBuffer,\n                    format: 'float32x2',\n                    stride: 2 * 4,\n                    offset: 0,\n                },\n            },\n            indexBuffer,\n            topology: options.topology,\n        });\n    }\n\n    /** The positions of the mesh. */\n    get positions(): Float32Array\n    {\n        return this.attributes.aPosition.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the positions of the mesh.\n     * When setting the positions, its important that the uvs array is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The positions of the mesh.\n     */\n    set positions(value: Float32Array)\n    {\n        this.attributes.aPosition.buffer.data = value;\n    }\n\n    /** The UVs of the mesh. */\n    get uvs(): Float32Array\n    {\n        return this.attributes.aUV.buffer.data as Float32Array;\n    }\n\n    /**\n     * Set the UVs of the mesh.\n     * Its important that the uvs array you set is at least as long as the positions array.\n     * otherwise the geometry will not be valid.\n     * @param {Float32Array} value - The UVs of the mesh.\n     */\n    set uvs(value: Float32Array)\n    {\n        this.attributes.aUV.buffer.data = value;\n    }\n\n    /** The indices of the mesh. */\n    get indices(): Uint32Array\n    {\n        return this.indexBuffer.data as Uint32Array;\n    }\n\n    set indices(value: Uint32Array)\n    {\n        this.indexBuffer.data = value;\n    }\n}\n"],"names":["localUniformBit","name","vertex","header","main","end","localUniformBitGroup2","replace","localUniformBitGl","tilingBit","fragment","tilingBitGl","gpuProgram","glProgram","TilingSpriteShader","Shader","constructor","compileHighShaderGpuProgram","bits","roundPixelsBit","compileHighShaderGlProgram","roundPixelsBitGl","tilingUniforms","UniformGroup","uMapCoord","value","Matrix","type","uClampFrame","Float32Array","uClampOffset","uTextureTransform","uSizeAnchor","resources","localUniforms","uTransformMatrix","uColor","uRound","uTexture","Texture","EMPTY","source","uSampler","style","updateUniforms","width","height","matrix","anchorX","anchorY","texture","this","textureWidth","textureHeight","textureMatrix","uniforms","set","a","b","c","d","tx","ty","invert","mapCoord","QuadGeometry","MeshGeometry","positions","uvs","indices","Uint32Array","sharedQuad","TilingSpriteGpuData","canBatch","geometry","slice","destroy","shader","TilingSpritePipe","renderer","_state","State","default2d","_renderer","validateRenderable","renderable","tilingSpriteData","_getTilingSpriteData","couldBatch","_updateCanBatch","batchableMesh","_batcher","checkAndUpdateTexture","addRenderable","tilingSprite","instructionSet","batcher","renderPipes","batch","BatchableMesh","didViewUpdate","_updateBatchableMesh","transform","groupTransform","setTexture","_texture","roundPixels","_roundPixels","addToBatch","break","updateRenderable","add","execute","groups","globalUniforms","bindGroup","color32BitToUniform","groupColorAlpha","blendMode","getAdjustedBlendModeBlend","groupBlendMode","_source","encoder","draw","state","updateElement","_tileTransform","anchor","x","y","_gpuData","uid","_initTilingSpriteData","gpuData","renderableData","addressMode","update","frame","applyAnchorToTexture","shared","copyFrom","scale","array","stride","offset","index","size","length","applyMatrix","setUvs","setPositions","_nonPowOf2wrapping","RendererType","WEBGL","context","supports","nonPowOf2wrapping","isSimple","isPowerOfTwo","extension","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","extensions","batcherName","packAsQuad","indexOffset","attributeOffset","_batch","_textureMatrixUpdateId","_uvUpdateId","topology","_topology","reset","uvBuffer","getBuffer","data","transformedUvs","_transformedUvs","_updateID","multiplyUvs","color","attributeSize","indexSize","blendModeIds","normal","multiply","screen","overlay","erase","min","max","_State","polygonOffset","blend","depthMask","offsets","cullMode","culling","clockwiseFrontFace","depthTest","_blendMode","_blendModeId","_polygonOffset","toString","for2d","ResizePlugin","init","options","Object","defineProperty","dom","globalThis","removeEventListener","queueResize","_resizeTo","addEventListener","resize","get","_cancelResize","_resizeId","requestAnimationFrame","cancelAnimationFrame","window","innerWidth","innerHeight","clientWidth","clientHeight","render","resizeTo","Application","TickerPlugin","assign","autoStart","sharedTicker","ticker","_ticker","remove","UPDATE_PRIORITY","LOW","stop","start","Ticker","oldTicker","BatchableSprite","_attributeStart","bounds","GraphicsGpuData","batches","batched","forEach","BigPool","return","GraphicsPipe","adaptor","_adaptor","runners","contextChange","graphics","wasBatched","gpuContext","graphicsContext","updateGpuContext","isBatchable","_rebuild","_addToBatcher","_getGpuDataForRenderable","i","isRenderable","getGpuContext","customShader","_updateBatchesForRenderable","batchPipe","_initGpuDataForRenderable","map","batchClone","BatchableGraphics","copyTo","GraphicsContextSystem","localUniformMSDFBit","localUniformMSDFBitGl","mSDFBit","mSDFBitGl","SdfShader","maxTextures","uDistance","colorBit","generateTextureBatchBit","colorBitGl","generateTextureBatchBitGl","batchSamplers","getBatchSamplersUniformGroup","AbstractBitmapFont","EventEmitter","arguments","chars","create","lineHeight","fontFamily","fontMetrics","fontSize","ascent","descent","baseLineOffset","distanceField","range","pages","applyFillAsTint","baseMeasurementFontSize","baseRenderedFontSize","font","deprecation","v8_0_0","pageTextures","distanceFieldRange","distanceFieldType","destroyTextures","undefined","emit","removeAllListeners","page","_DynamicBitmapFont","resolution","_padding","_measureCache","_currentChars","_currentX","_currentY","_currentMaxCharHeight","_currentPageIndex","_skipKerning","dynamicOptions","defaultOptions","_textureSize","textureSize","_mipmap","mipmap","clone","overrideFill","_fill","alpha","WHITE","fill","requestedFontSize","fontStringFromTextStyle","overrideSize","_stroke","_style","skipKerning","padding","textureStyle","_textureStyle","TextureStyle","CanvasTextMetrics","measureFont","ensureCharacters","charList","graphemeSegmenter","filter","char","includes","self","indexOf","pageData","_nextPage","canvas","canvasAndContext","textureSource","currentX","currentY","currentMaxCharHeight","fontScale","skipTexture","maxTextureWidth","maxTextureHeight","metrics","measureText","paddedWidth","Math","ceil","fontStyle","paddedHeight","pageData2","xAdvance","dropShadow","distance","id","codePointAt","xOffset","yOffset","kerning","_drawGlyph","px","py","Rectangle","_applyKerning","newChars","measureCache","first","j","second","c1","c2","total","amount","textureResolution","CanvasPool","getOptimalCanvasAndContext","_setupContext","ImageSource","resource","alphaMode","autoGenerateMipmaps","textBaseline","stroke","strokeThickness","lineWidth","lineJoin","join","miterLimit","strokeStyle","getCanvasFillStyle","fillStyle","shadowOptions","rgb","Color","setValue","toArray","dropShadowBlur","blur","dropShadowDistance","shadowColor","shadowBlur","shadowOffsetX","cos","angle","shadowOffsetY","sin","text","fontProperties","removeShadow","strokeText","fillText","super","returnCanvasAndContext","TextStyle","DynamicBitmapFont","getBitmapTextLayout","trimEnd","layoutData","offsetY","lines","charPositions","spaceWidth","spacesIndex","currentLine","previousChar","firstWord","currentWord","spaceWord","nextWord","word","position","push","nextLine","lastChar","adjustedLetterSpacing","letterSpacing","adjustedWordWrapWidth","wordWrapWidth","breakWords","wordWrap","checkIsOverflow","isEnd","charData","test","nextCharWidth","align","measurementData","line","alignCenter","alignRight","indy","spaceIndex","totalSpaces","alignJustify","fontCount","BitmapFontManager","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","getFont","fontFamilyKey","styleKey","key","substring","lastIndexOf","Cache","has","fnt","warn","once","dynamicFont","getLayout","bitmapFont","install","Error","textStyle","flatChars","result","item","Array","isArray","startCode","charCodeAt","endCode","i2","j2","String","fromCharCode","from","resolveCharacters","uninstall","cacheKey","BitmapTextGraphics","Graphics","BitmapTextPipe","renderableGC","addManagedHash","bitmapText","graphicsRenderable","_getGpuBitmapText","_didTextUpdate","_updateContext","syncWithProxy","_updateDistanceField","proxyGraphics","clear","limits","maxBatchableTextures","bitmapTextLayout","translate","_anchor","_x","_y","tint","round","initGpuText","proxyRenderable","dx","sqrt","dy","worldScale","abs","container","proxy","groupColor","globalDisplayStatus","localDisplayStatus","groupAlpha","BatchableHTMLText","generatingTexture","resolutionChange","_autoResolution","onViewUpdate","htmlText","returnTexturePromise","texturePromise","HTMLTextPipe","batchableHTMLText","_getGpuText","_updateGpuText","catch","e","console","error","updateTextBounds","_resolution","getTexturePromise","renderGroup","parentRenderGroup","structureDidChange","minX","maxX","minY","maxY","nssvg","nsxhtml","HTMLTextRenderData","svgRoot","document","createElementNS","foreignObject","domElement","styleElement","image","Image","setAttribute","overflow","appendChild","textStyleToCSS","cssStyles","toHex","fontWeight","fontVariant","whiteSpace","strokeToCSS","dropShadowToCSS","cssOverrides","tagStyles","out","tagStyle","cssTagStyle","templates","tagStyleToCSS","dropShadowStyle","setAlpha","toHexa","HTMLTextStyle","_cssOverrides","_cssStyle","cssStyle","addOverride","_len","_key","toAdd","v","removeOverride","_len2","_key2","toRemove","loadFontCSS","url","dataSrc","response","DOMAdapter","fetch","blob","reader","FileReader","Promise","resolve","reject","onloadend","onerror","readAsDataURL","loadFontAsBase64","FontStylePromiseCache","Map","tempHTMLTextRenderData","HTMLTextSystem","_createCanvas","WEBGPU","getTexture","_buildTexturePromise","htmlTextData","fontFamilies","dedupe","matches","match","addFontFamily","fontFamily2","split","trim","extractFontFamilies","fontCSS","fontPromises","all","getFontCss","defaultTextStyle","measured","fontStyleCSS","htmlTextRenderData","innerHTML","textContent","body","contentBounds","getBoundingClientRect","doublePadding","measureHtmlText","svgURL","XMLSerializer","serializeToString","getSVGUrl","delay","async","resolve2","setTimeout","onload","src","encodeURIComponent","crossOrigin","loadSVGImage","userAgent","getNavigator","isSafari","clearRect","drawImage","getTemporaryCanvasFromImage","getPo2TextureFromSource","initSource","then","_cleanUp","TexturePool","returnTexture","uploadMethodId","WebGLSystem","WebGPUSystem","CanvasSystem","BatchableText","canvasText","CanvasTextPipe","batchableText","CanvasTextSystem","_textKey","CanvasTextGenerator","getCanvasAndContext","pad","updateUvs","filters","filteredTexture","_applyFilters","renderTextToCanvas","currentRenderTarget","renderTarget","resultTexture","generateFilteredTexture","bind","MeshGpuData","MeshPipe","localUniformsBindGroup","BindGroup","mesh","meshData","_getMeshData","isBatched","_geometry","vertexSize","_getBatchableMesh","gpuBatchableMesh","_a","_b","_initMeshData","_initBatchableMesh","gpuMesh","tempBounds","Bounds","getOptimalTexture","_PlaneGeometry","verticesX","verticesY","build","verts","sizeX","sizeY","totalSub","xpos","ypos","value2","value3","value4","buffers","indexBuffer","PlaneGeometry","_NineSliceGeometry","_originalWidth","originalWidth","_originalHeight","originalHeight","_leftWidth","leftWidth","_rightWidth","rightWidth","_topHeight","topHeight","_bottomHeight","bottomHeight","_anchorX","_anchorY","updatePositions","p","w","scaleW","h","scaleH","anchorOffsetX","anchorOffsetY","_uvw","_uvh","NineSliceGeometry","NineSliceSpriteGpuData","NineSliceSpritePipe","sprite","gpuSprite","_getGpuSprite","_updateBatchableSprite","batchableSprite","_initGPUSprite","FilterPipe","filterEffect","renderPipeId","canBundle","action","pop","_filterEffect","_container","instruction","quadGeometry","Geometry","attributes","aPosition","buffer","format","FilterData","skip","inputTexture","backTexture","blendRequired","outputRenderSurface","globalFrame","FilterSystem","_filterStackIndex","_filterStack","_filterGlobalUniforms","uInputSize","uInputPixel","uInputClamp","uOutputFrame","uGlobalFrame","uOutputTexture","_globalFilterBindGroup","activeBackTexture","_activeFilterData","filterData","_pushFilterData","renderSurface","colorTextureSource","colorTexture","rootResolution","rootAntialias","antialias","_calculateFilterArea","_calculateFilterBounds","rootViewPort","previousFilterData","_getPreviousFilterData","globalResolution","_findFilterResolution","offsetX","_calculateGlobalFrame","_setupFilterTextures","_ref","addRect","rectangle","finishRenderPass","_applyFiltersToTexture","outputTexture","_popFilterData","getBackTexture","lastRenderSurface","previousBounds","backgroundResolution","floor","copyToTexture","applyFilter","input","output","isFinalTarget","rootRenderTarget","_findPreviousFilterOffset","_updateFilterUniforms","_setupBindGroupsAndRender","calculateSpriteMatrix","outputMatrix","mappedMatrix","worldTransform","cacheToLocalTransform","prepend","uniformBatch","batchUniforms","getUboResource","setResource","getRenderTarget","sourceWidth","sourceHeight","outputFrame","inputSize","inputPixel","inputClamp","pixelWidth","pixelHeight","rootTexture","isRoot","currentIndex","lastIndex","prevFilterData","renderables","tempMatrix","addBounds","getGlobalRenderableBounds","filterArea","getFastGlobalBounds","filterFrameTransform","apply","flip","tempTexture","flop","t","viewPort","paddingMultiplier","Infinity","enabled","clipToViewport","compatibleRenderers","backBuffer","useBackBuffer","fitBounds","isPositive","GlParticleContainerAdaptor","particleContainerPipe","defaultShader","gl","getBuffers","glType","BYTES_PER_ELEMENT","UNSIGNED_SHORT","UNSIGNED_INT","drawElements","TRIANGLES","particleChildren","createIndicesForQuads","outBuffer","totalIndices","Uint16Array","generateUpdateFunction","properties","dynamic","funcFragments","property","code","getAttributeInfoFromFormat","unshift","functionSource","Function","ParticleBuffer","_size","_generateParticleUpdateCache","staticVertexSize","dynamicVertexSize","attributeInfo","_dynamicStride","_staticStride","staticAttributeBuffer","ViewableBuffer","dynamicAttributeBuffer","dynamicOffset","staticOffset","_staticBuffer","Buffer","label","shrinkToFit","usage","BufferUsage","VERTEX","COPY_DST","_dynamicBuffer","addAttribute","attributeName","addIndex","uploadFunction","getParticleUpdate","_dynamicUpload","dynamicUpdate","_staticUpload","staticUpdate","keyGen","getParticleSyncKey","generateParticleUpdate","generateParticleUpdateFunction","particles","uploadStatic","setDataWithSize","byteLength","float32View","uint32View","ParticleShader","GlProgram","GpuProgram","wgsl","entryPoint","uTranslationMatrix","uResolution","ParticleContainerPipe","_renderable","_initBuffer","_properties","children","_childrenDirty","transformationMatrix","globalUniformData","projectionMatrix","GlParticleContainerPipe","GpuParticleContainerAdaptor","getUniformBindGroup","getTextureBindGroup","GpuParticleContainerPipe","_getFinalPadding","updateQuadBounds","paddingOffset","paddingOffsetY","abgr","_MeshGeometry","shrinkBuffersToFit","aUV","INDEX","batchMode"],"sourceRoot":""}