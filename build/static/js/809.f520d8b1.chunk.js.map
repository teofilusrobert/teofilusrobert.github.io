{"version":3,"file":"static/js/809.f520d8b1.chunk.js","mappings":"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","sources":["../node_modules/pixi.js/src/events/FederatedEvent.ts","../node_modules/ismobilejs/src/isMobile.ts","../node_modules/pixi.js/src/utils/browser/isMobile.ts","../node_modules/pixi.js/src/accessibility/AccessibilitySystem.ts","../node_modules/pixi.js/src/accessibility/init.ts","../node_modules/pixi.js/src/accessibility/accessibilityTarget.ts","../node_modules/pixi.js/src/events/EventTicker.ts","../node_modules/pixi.js/src/events/FederatedMouseEvent.ts","../node_modules/pixi.js/src/events/FederatedPointerEvent.ts","../node_modules/pixi.js/src/events/FederatedWheelEvent.ts","../node_modules/pixi.js/src/events/EventBoundary.ts","../node_modules/pixi.js/src/events/EventSystem.ts","../node_modules/pixi.js/src/events/FederatedEventTarget.ts","../node_modules/pixi.js/src/events/init.ts","../node_modules/pixi.js/src/dom/DOMPipe.ts","../node_modules/pixi.js/src/dom/init.ts"],"sourcesContent":["import { Point } from '../maths/point/Point';\n\nimport type { Container } from '../scene/container/Container';\nimport type { EventBoundary } from './EventBoundary';\n\n/**\n * A PixiJS compatible touch event interface that extends the standard DOM Touch interface.\n * Provides additional properties to normalize touch input with mouse/pointer events.\n * @example\n * ```ts\n * // Access touch information\n * sprite.on('touchstart', (event) => {\n *     // Standard touch properties\n *     console.log('Touch position:', event.clientX, event.clientY);\n *     console.log('Touch ID:', event.pointerId);\n *\n *     // Additional PixiJS properties\n *     console.log('Pressure:', event.pressure);\n *     console.log('Size:', event.width, event.height);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n * });\n * ```\n * @category events\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Touch} DOM Touch Interface\n * @standard\n */\nexport interface PixiTouch extends Touch\n{\n    /** The button being pressed (0: left, 1: middle, 2: right) */\n    button: number;\n\n    /** Bitmap of currently pressed buttons */\n    buttons: number;\n\n    /** Whether this is the primary touch point */\n    isPrimary: boolean;\n\n    /** The width of the touch contact area */\n    width: number;\n\n    /** The height of the touch contact area */\n    height: number;\n\n    /** The angle of tilt along the x-axis (in degrees) */\n    tiltX: number;\n\n    /** The angle of tilt along the y-axis (in degrees) */\n    tiltY: number;\n\n    /** The type of pointer that triggered this event */\n    pointerType: string;\n\n    /** Unique identifier for this touch point */\n    pointerId: number;\n\n    /** The normalized pressure of the pointer (0 to 1) */\n    pressure: number;\n\n    /** The rotation angle of the pointer (e.g., pen) */\n    twist: number;\n\n    /** The normalized tangential pressure of the pointer */\n    tangentialPressure: number;\n\n    /** The x coordinate relative to the current layer */\n    layerX: number;\n\n    /** The y coordinate relative to the current layer */\n    layerY: number;\n\n    /** The x coordinate relative to the target's offset parent */\n    offsetX: number;\n\n    /** The y coordinate relative to the target's offset parent */\n    offsetY: number;\n\n    /** Whether the event was normalized by PixiJS */\n    isNormalized: boolean;\n\n    /** The type of touch event */\n    type: string;\n}\n\n/**\n * A DOM-compatible synthetic event implementation for PixiJS's event system.\n * This class implements the standard DOM Event interface while providing additional\n * functionality specific to PixiJS events.\n * > [!NOTE] You wont receive an instance of this class directly, but rather a subclass\n * > of this class, such as {@link FederatedPointerEvent}, {@link FederatedMouseEvent}, or\n * > {@link FederatedWheelEvent}. This class is the base for all federated events.\n * @example\n * ```ts\n * // Basic event handling\n * sprite.on('pointerdown', (event: FederatedEvent) => {\n *     // Access standard DOM event properties\n *     console.log('Target:', event.target);\n *     console.log('Phase:', event.eventPhase);\n *     console.log('Type:', event.type);\n *\n *     // Control propagation\n *     event.stopPropagation();\n * });\n * ```\n * @typeParam N - The type of native event held. Can be either a UIEvent or PixiTouch.\n * @remarks\n * - Implements the standard DOM UIEvent interface\n * - Provides event bubbling and capturing phases\n * - Supports propagation control\n * - Manages event paths through display tree\n * - Normalizes native browser events\n * @see {@link https://dom.spec.whatwg.org/#event} DOM Event Specification\n * @see {@link FederatedPointerEvent} For pointer-specific events\n * @see {@link FederatedMouseEvent} For mouse-specific events\n * @see {@link FederatedWheelEvent} For wheel-specific events\n * @category events\n * @standard\n */\nexport class FederatedEvent<N extends UIEvent | PixiTouch = UIEvent | PixiTouch> implements UIEvent\n{\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    public bubbles = true;\n\n    /** @deprecated since 7.0.0 */\n    public cancelBubble = true;\n\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    public readonly cancelable = false;\n\n    /**\n     * Flag added for compatibility with DOM `Event`. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     * @ignore\n     */\n    public readonly composed = false;\n\n    /** The listeners of the event target that are being notified. */\n    public currentTarget: Container;\n\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    public defaultPrevented = false;\n\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    public eventPhase = FederatedEvent.prototype.NONE;\n\n    /** Flags whether this is a user-trusted event */\n    public isTrusted: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public returnValue: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public srcElement: EventTarget;\n\n    /** The event target that this will be dispatched to. */\n    public target: Container;\n\n    /** The timestamp of when the event was created. */\n    public timeStamp: number;\n\n    /** The type of event, e.g. `\"mouseup\"`. */\n    public type: string;\n\n    /** The native event that caused the foremost original event. */\n    public nativeEvent: N;\n\n    /** The original event that caused this event, if any. */\n    public originalEvent: FederatedEvent<N>;\n\n    /** Flags whether propagation was stopped. */\n    public propagationStopped = false;\n\n    /** Flags whether propagation was immediately stopped. */\n    public propagationImmediatelyStopped = false;\n\n    /** The composed path of the event's propagation. The `target` is at the end. */\n    public path: Container[];\n\n    /** The {@link EventBoundary} that manages this event. Null for root events. */\n    public readonly manager: EventBoundary;\n\n    /** Event-specific detail */\n    public detail: number;\n\n    /** The global Window object. */\n    public view: WindowProxy;\n\n    /**\n     * Not supported.\n     * @deprecated since 7.0.0\n     * @ignore\n     */\n    public which: number;\n\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    public layer: Point = new Point();\n\n    /** @readonly */\n    get layerX(): number { return this.layer.x; }\n\n    /** @readonly */\n    get layerY(): number { return this.layer.y; }\n\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    public page: Point = new Point();\n\n    /** @readonly */\n    get pageX(): number { return this.page.x; }\n\n    /** @readonly */\n    get pageY(): number { return this.page.y; }\n\n    /**\n     * @param manager - The event boundary which manages this event. Propagation can only occur\n     *  within the boundary's jurisdiction.\n     */\n    constructor(manager: EventBoundary)\n    {\n        this.manager = manager;\n    }\n\n    /**\n     * Fallback for the deprecated `InteractionEvent.data`.\n     * @deprecated since 7.0.0\n     */\n    get data(): this\n    {\n        return this;\n    }\n\n    /**\n     * The propagation path for this event. Alias for {@link EventBoundary.propagationPath}.\n     * @advanced\n     */\n    public composedPath(): Container[]\n    {\n        // Find the propagation path if it isn't cached or if the target has changed since since\n        // the last evaluation.\n        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target))\n        {\n            this.path = this.target ? this.manager.propagationPath(this.target) : [];\n        }\n\n        return this.path;\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface `Event`. It will throw an `Error`.\n     * @deprecated\n     * @ignore\n     * @param _type\n     * @param _bubbles\n     * @param _cancelable\n     */\n    public initEvent(_type: string, _bubbles?: boolean, _cancelable?: boolean): void\n    {\n        throw new Error('initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface `UIEvent`. It will throw an `Error`.\n     * @ignore\n     * @deprecated\n     * @param _typeArg\n     * @param _bubblesArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     */\n    public initUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window | null,\n        _detailArg?: number): void\n    {\n        throw new Error('initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Prevent default behavior of both PixiJS and the user agent.\n     * @example\n     * ```ts\n     * sprite.on('click', (event) => {\n     *     // Prevent both browser's default click behavior\n     *     // and PixiJS's default handling\n     *     event.preventDefault();\n     *\n     *     // Custom handling\n     *     customClickHandler();\n     * });\n     * ```\n     * @remarks\n     * - Only works if the native event is cancelable\n     * - Does not stop event propagation\n     */\n    public preventDefault(): void\n    {\n        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable)\n        {\n            this.nativeEvent.preventDefault();\n        }\n\n        this.defaultPrevented = true;\n    }\n\n    /**\n     * Stop this event from propagating to any additional listeners, including those\n     * on the current target and any following targets in the propagation path.\n     * @example\n     * ```ts\n     * container.on('pointerdown', (event) => {\n     *     // Stop all further event handling\n     *     event.stopImmediatePropagation();\n     *\n     *     // These handlers won't be called:\n     *     // - Other pointerdown listeners on this container\n     *     // - Any pointerdown listeners on parent containers\n     * });\n     * ```\n     * @remarks\n     * - Immediately stops all event propagation\n     * - Prevents other listeners on same target from being called\n     * - More aggressive than stopPropagation()\n     */\n    public stopImmediatePropagation(): void\n    {\n        this.propagationImmediatelyStopped = true;\n    }\n\n    /**\n     * Stop this event from propagating to the next target in the propagation path.\n     * The rest of the listeners on the current target will still be notified.\n     * @example\n     * ```ts\n     * child.on('pointermove', (event) => {\n     *     // Handle event on child\n     *     updateChild();\n     *\n     *     // Prevent parent handlers from being called\n     *     event.stopPropagation();\n     * });\n     *\n     * // This won't be called if child handles the event\n     * parent.on('pointermove', (event) => {\n     *     updateParent();\n     * });\n     * ```\n     * @remarks\n     * - Stops event bubbling to parent containers\n     * - Does not prevent other listeners on same target\n     * - Less aggressive than stopImmediatePropagation()\n     */\n    public stopPropagation(): void\n    {\n        this.propagationStopped = true;\n    }\n\n    /**\n     * The event propagation phase NONE that indicates that the event is not in any phase.\n     * @default 0\n     * @advanced\n     */\n    public readonly NONE = 0;\n    /**\n     * The event propagation phase CAPTURING_PHASE that indicates that the event is in the capturing phase.\n     * @default 1\n     * @advanced\n     */\n    public readonly CAPTURING_PHASE = 1;\n    /**\n     * The event propagation phase AT_TARGET that indicates that the event is at the target.\n     * @default 2\n     * @advanced\n     */\n    public readonly AT_TARGET = 2;\n    /**\n     * The event propagation phase BUBBLING_PHASE that indicates that the event is in the bubbling phase.\n     * @default 3\n     * @advanced\n     */\n    public readonly BUBBLING_PHASE = 3;\n}\n","const appleIphone = /iPhone/i;\nconst appleIpod = /iPod/i;\nconst appleTablet = /iPad/i;\nconst appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nconst androidPhone = /\\bAndroid(?:.+)Mobile\\b/i; // Match 'Android' AND 'Mobile'\nconst androidTablet = /Android/i;\nconst amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i; // Match 'Silk' AND 'Mobile'\nconst amazonTablet = /Silk/i;\nconst windowsPhone = /Windows Phone/i;\nconst windowsTablet = /\\bWindows(?:.+)ARM\\b/i; // Match 'Windows' AND 'ARM'\nconst otherBlackBerry = /BlackBerry/i;\nconst otherBlackBerry10 = /BB10/i;\nconst otherOpera = /Opera Mini/i;\nconst otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nconst otherFirefox = /Mobile(?:.+)Firefox\\b/i; // Match 'Mobile' AND 'Firefox'\n\nexport type UserAgent = string;\nexport type Navigator = {\n  userAgent: string;\n  platform: string;\n  maxTouchPoints?: number;\n};\n\nconst isAppleTabletOnIos13 = (navigator?: Navigator): boolean => {\n  return (\n    typeof navigator !== 'undefined' &&\n    navigator.platform === 'MacIntel' &&\n    typeof navigator.maxTouchPoints === 'number' &&\n    navigator.maxTouchPoints > 1 &&\n    typeof MSStream === 'undefined'\n  );\n};\n\nfunction createMatch(userAgent: UserAgent): (regex: RegExp) => boolean {\n  return (regex: RegExp): boolean => regex.test(userAgent);\n}\n\nexport type isMobileResult = {\n  apple: {\n    phone: boolean;\n    ipod: boolean;\n    tablet: boolean;\n    universal: boolean;\n    device: boolean;\n  };\n  amazon: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  android: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  windows: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  other: {\n    blackberry: boolean;\n    blackberry10: boolean;\n    opera: boolean;\n    firefox: boolean;\n    chrome: boolean;\n    device: boolean;\n  };\n  phone: boolean;\n  tablet: boolean;\n  any: boolean;\n};\n\nexport type IsMobileParameter = UserAgent | Navigator;\n\nexport default function isMobile(param?: IsMobileParameter): isMobileResult {\n  let nav: Navigator = {\n    userAgent: '',\n    platform: '',\n    maxTouchPoints: 0,\n  };\n\n  if (!param && typeof navigator !== 'undefined') {\n    nav = {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      maxTouchPoints: navigator.maxTouchPoints || 0,\n    };\n  } else if (typeof param === 'string') {\n    nav.userAgent = param;\n  } else if (param && param.userAgent) {\n    nav = {\n      userAgent: param.userAgent,\n      platform: param.platform,\n      maxTouchPoints: param.maxTouchPoints || 0,\n    };\n  }\n\n  let userAgent = nav.userAgent;\n\n  // Facebook mobile app's integrated browser adds a bunch of strings that\n  // match everything. Strip it out if it exists.\n  let tmp = userAgent.split('[FBAN');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  // Twitter mobile app's integrated browser on iPad adds a \"Twitter for\n  // iPhone\" string. Same probably happens on other tablet platforms.\n  // This will confuse detection so strip it out if it exists.\n  tmp = userAgent.split('Twitter');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  const match = createMatch(userAgent);\n\n  const result: isMobileResult = {\n    apple: {\n      phone: match(appleIphone) && !match(windowsPhone),\n      ipod: match(appleIpod),\n      tablet:\n        !match(appleIphone) &&\n        (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n      universal: match(appleUniversal),\n      device:\n        (match(appleIphone) ||\n          match(appleIpod) ||\n          match(appleTablet) ||\n          match(appleUniversal) ||\n          isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n    },\n    amazon: {\n      phone: match(amazonPhone),\n      tablet: !match(amazonPhone) && match(amazonTablet),\n      device: match(amazonPhone) || match(amazonTablet),\n    },\n    android: {\n      phone:\n        (!match(windowsPhone) && match(amazonPhone)) ||\n        (!match(windowsPhone) && match(androidPhone)),\n      tablet:\n        !match(windowsPhone) &&\n        !match(amazonPhone) &&\n        !match(androidPhone) &&\n        (match(amazonTablet) || match(androidTablet)),\n      device:\n        (!match(windowsPhone) &&\n          (match(amazonPhone) ||\n            match(amazonTablet) ||\n            match(androidPhone) ||\n            match(androidTablet))) ||\n        match(/\\bokhttp\\b/i),\n    },\n    windows: {\n      phone: match(windowsPhone),\n      tablet: match(windowsTablet),\n      device: match(windowsPhone) || match(windowsTablet),\n    },\n    other: {\n      blackberry: match(otherBlackBerry),\n      blackberry10: match(otherBlackBerry10),\n      opera: match(otherOpera),\n      firefox: match(otherFirefox),\n      chrome: match(otherChrome),\n      device:\n        match(otherBlackBerry) ||\n        match(otherBlackBerry10) ||\n        match(otherOpera) ||\n        match(otherFirefox) ||\n        match(otherChrome),\n    },\n    any: false,\n    phone: false,\n    tablet: false,\n  };\n\n  result.any =\n    result.apple.device ||\n    result.android.device ||\n    result.windows.device ||\n    result.other.device;\n  // excludes 'other' devices and ipods, targeting touchscreen phones\n  result.phone =\n    result.apple.phone || result.android.phone || result.windows.phone;\n  result.tablet =\n    result.apple.tablet || result.android.tablet || result.windows.tablet;\n\n  return result;\n}\n","import isMobileJs from 'ismobilejs';\n\n// ismobilejs have different import behavior for CJS and ESM, so here is the hack\ntype isMobileJsType = typeof isMobileJs & { default?: typeof isMobileJs };\nconst isMobileCall = (isMobileJs as isMobileJsType).default ?? isMobileJs;\n\n/**\n * The result of the mobile device detection system.\n * Provides detailed information about device type and platform.\n * @example\n * ```ts\n * // Type usage with isMobile\n * const deviceInfo: isMobileResult = isMobile;\n *\n * // Check device categories\n * if (deviceInfo.apple.device) {\n *     console.log('iOS Device Details:', {\n *         isPhone: deviceInfo.apple.phone,\n *         isTablet: deviceInfo.apple.tablet,\n *         isUniversal: deviceInfo.apple.universal\n *     });\n * }\n *\n * // Platform-specific checks\n * const platformInfo = {\n *     isApple: deviceInfo.apple.device,\n *     isAndroid: deviceInfo.android.device,\n *     isAmazon: deviceInfo.amazon.device,\n *     isWindows: deviceInfo.windows.device\n * };\n * ```\n * @category utils\n * @standard\n */\nexport type isMobileResult = {\n    /**\n     * Apple device detection information.\n     * Provides detailed iOS device categorization.\n     * @example\n     * ```ts\n     * // iOS device checks\n     * if (isMobile.apple.device) {\n     *     if (isMobile.apple.tablet) {\n     *         // iPad-specific code\n     *         useTabletLayout();\n     *     } else if (isMobile.apple.phone) {\n     *         // iPhone-specific code\n     *         usePhoneLayout();\n     *     }\n     * }\n     * ```\n     */\n    apple: {\n        /** Whether the device is an iPhone */\n        phone: boolean;\n        /** Whether the device is an iPod Touch */\n        ipod: boolean;\n        /** Whether the device is an iPad */\n        tablet: boolean;\n        /** Whether app is running in iOS universal mode */\n        universal: boolean;\n        /** Whether device is any Apple mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Amazon device detection information.\n     * Identifies Amazon Fire tablets and phones.\n     * @example\n     * ```ts\n     * // Amazon Fire tablet detection\n     * if (isMobile.amazon.tablet) {\n     *     // Fire tablet optimizations\n     *     optimizeForFireTablet();\n     * }\n     * ```\n     */\n    amazon: {\n        /** Whether device is a Fire Phone */\n        phone: boolean;\n        /** Whether device is a Fire Tablet */\n        tablet: boolean;\n        /** Whether device is any Amazon mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Android device detection information.\n     * Categorizes Android phones and tablets.\n     * @example\n     * ```ts\n     * // Android device handling\n     * if (isMobile.android.device) {\n     *     // Check specific type\n     *     const deviceType = isMobile.android.tablet ?\n     *         'tablet' : 'phone';\n     *     console.log(`Android ${deviceType} detected`);\n     * }\n     * ```\n     */\n    android: {\n        /** Whether device is an Android phone */\n        phone: boolean;\n        /** Whether device is an Android tablet */\n        tablet: boolean;\n        /** Whether device is any Android device */\n        device: boolean;\n    };\n\n    /**\n     * Windows device detection information.\n     * Identifies Windows phones and tablets.\n     * @example\n     * ```ts\n     * // Windows device checks\n     * if (isMobile.windows.tablet) {\n     *     // Surface tablet optimizations\n     *     enableTouchFeatures();\n     * }\n     * ```\n     */\n    windows: {\n        /** Whether device is a Windows Phone */\n        phone: boolean;\n        /** Whether device is a Windows tablet */\n        tablet: boolean;\n        /** Whether device is any Windows mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Other device detection information.\n     * Covers additional platforms and browsers.\n     * @example\n     * ```ts\n     * // Check other platforms\n     * if (isMobile.other.blackberry10) {\n     *     // BlackBerry 10 specific code\n     * } else if (isMobile.other.chrome) {\n     *     // Chrome mobile specific code\n     * }\n     * ```\n     */\n    other: {\n        /** Whether device is a BlackBerry */\n        blackberry: boolean;\n        /** Whether device is a BlackBerry 10 */\n        blackberry10: boolean;\n        /** Whether browser is Opera Mobile */\n        opera: boolean;\n        /** Whether browser is Firefox Mobile */\n        firefox: boolean;\n        /** Whether browser is Chrome Mobile */\n        chrome: boolean;\n        /** Whether device is any other mobile device */\n        device: boolean;\n    };\n\n    /**\n     * Whether the device is any type of phone.\n     * Combines detection across all platforms.\n     * @example\n     * ```ts\n     * // Check if device is a phone\n     * if (isMobile.phone) {\n     *     console.log('Running on a mobile phone');\n     * }\n     * ```\n     */\n    phone: boolean;\n\n    /**\n     * Whether the device is any type of tablet.\n     * Combines detection across all platforms.\n     * @example\n     * ```ts\n     * // Check if device is a tablet\n     * if (isMobile.tablet) {\n     *     console.log('Running on a mobile tablet');\n     * }\n     * ```\n     */\n    tablet: boolean;\n\n    /**\n     * Whether the device is any type of mobile device.\n     * True if any mobile platform is detected.\n     * @example\n     * ```ts\n     * // Check if device is mobile\n     * if (isMobile.any) {\n     *     console.log('Running on a mobile device');\n     * }\n     * ```\n     */\n    any: boolean;\n};\n\n/**\n * Detects whether the device is mobile and what type of mobile device it is.\n * Provides a comprehensive detection system for mobile platforms and devices.\n * @example\n * ```ts\n * import { isMobile } from 'pixi.js';\n *\n * // Check specific device types\n * if (isMobile.apple.tablet) {\n *    console.log('Running on iPad');\n * }\n *\n * // Check platform categories\n * if (isMobile.android.any) {\n *    console.log('Running on Android');\n * }\n *\n * // Conditional rendering\n * if (isMobile.phone) {\n *    renderer.resolution = 2;\n *    view.style.width = '100vw';\n * }\n * ```\n * @remarks\n * - Detects all major mobile platforms\n * - Distinguishes between phones and tablets\n * - Updates when navigator changes\n * - Common in responsive design\n * @category utils\n * @standard\n * @see {@link isMobileResult} For full type definition\n */\nexport const isMobile: isMobileResult = isMobileCall(globalThis.navigator);\n","import { FederatedEvent } from '../events/FederatedEvent';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { isMobile } from '../utils/browser/isMobile';\nimport { removeItems } from '../utils/data/removeItems';\nimport { type AccessibleHTMLElement } from './accessibilityTarget';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { isMobileResult } from '../utils/browser/isMobile';\n\n/** @ignore */\nconst KEY_CODE_TAB = 9;\n\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\n\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1000;\nconst DIV_HOOK_POS_Y = -1000;\nconst DIV_HOOK_ZINDEX = 2;\n\n/**\n * Initialisation options for the accessibility system when used with an Application.\n * @category accessibility\n * @advanced\n */\nexport interface AccessibilitySystemOptions\n{\n    /** Options for the accessibility system */\n    accessibilityOptions?: AccessibilityOptions;\n}\n\n/**\n * The options for the accessibility system.\n * @category accessibility\n * @advanced\n */\nexport interface AccessibilityOptions\n{\n    /** Whether to enable accessibility features on initialization instead of waiting for tab key */\n    enabledByDefault?: boolean;\n    /** Whether to visually show the accessibility divs for debugging */\n    debug?: boolean;\n    /** Whether to allow tab key press to activate accessibility features */\n    activateOnTab?: boolean;\n    /** Whether to deactivate accessibility when mouse moves */\n    deactivateOnMouseMove?: boolean;\n}\n\n/**\n * The Accessibility system provides screen reader and keyboard navigation support for PixiJS content.\n * It creates an accessible DOM layer over the canvas that can be controlled programmatically or through user interaction.\n *\n * By default, the system activates when users press the tab key. This behavior can be customized through options:\n * ```js\n * const app = new Application({\n *     accessibilityOptions: {\n *     // Enable immediately instead of waiting for tab\n *     enabledByDefault: true,\n *     // Disable tab key activation\n *     activateOnTab: false,\n *     // Show/hide accessibility divs\n *     debug: false,\n *     // Prevent accessibility from being deactivated when mouse moves\n *     deactivateOnMouseMove: false,\n * }\n * });\n * ```\n *\n * The system can also be controlled programmatically by accessing the `renderer.accessibility` property:\n * ```js\n * app.renderer.accessibility.setAccessibilityEnabled(true);\n * ```\n *\n * To make individual containers accessible:\n * ```js\n * container.accessible = true;\n * ```\n * There are several properties that can be set on a Container to control its accessibility which can\n * be found here: {@link AccessibleOptions}.\n * @category accessibility\n * @standard\n */\nexport class AccessibilitySystem implements System<AccessibilitySystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'accessibility',\n    } as const;\n\n    /**\n     * The default options used by the system.\n     * You can set these before initializing the {@link Application} to change the default behavior.\n     * @example\n     * ```js\n     * import { AccessibilitySystem } from 'pixi.js';\n     *\n     * AccessibilitySystem.defaultOptions.enabledByDefault = true;\n     *\n     * const app = new Application()\n     * app.init()\n     * ```\n     */\n    public static defaultOptions: AccessibilityOptions = {\n        /**\n         * Whether to enable accessibility features on initialization\n         * @default false\n         */\n        enabledByDefault: false,\n        /**\n         * Whether to visually show the accessibility divs for debugging\n         * @default false\n         */\n        debug: false,\n        /**\n         * Whether to activate accessibility when tab key is pressed\n         * @default true\n         */\n        activateOnTab: true,\n        /**\n         * Whether to deactivate accessibility when mouse moves\n         * @default true\n         */\n        deactivateOnMouseMove: true,\n    };\n\n    /** Whether accessibility divs are visible for debugging */\n    public debug = false;\n\n    /** Whether to activate on tab key press */\n    private _activateOnTab = true;\n\n    /** Whether to deactivate accessibility when mouse moves */\n    private _deactivateOnMouseMove = true;\n\n    /**\n     * The renderer this accessibility manager works for.\n     * @type {WebGLRenderer|WebGPURenderer}\n     */\n    private _renderer: Renderer;\n\n    /** Internal variable, see isActive getter. */\n    private _isActive = false;\n\n    /** Internal variable, see isMobileAccessibility getter. */\n    private _isMobileAccessibility = false;\n\n    /** Button element for handling touch hooks. */\n    private _hookDiv: HTMLElement | null;\n\n    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n    private _div: HTMLElement | null = null;\n\n    /** A simple pool for storing divs. */\n    private _pool: AccessibleHTMLElement[] = [];\n\n    /** This is a tick used to check if an object is no longer being rendered. */\n    private _renderId = 0;\n\n    /** The array of currently active accessible items. */\n    private _children: Container[] = [];\n\n    /** Count to throttle div updates on android devices. */\n    private _androidUpdateCount = 0;\n\n    /**  The frequency to update the div elements. */\n    private readonly _androidUpdateFrequency = 500; // 2fps\n\n    // eslint-disable-next-line jsdoc/require-param\n    /**\n     * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer, private readonly _mobileInfo: isMobileResult = isMobile)\n    {\n        this._hookDiv = null;\n\n        if (_mobileInfo.tablet || _mobileInfo.phone)\n        {\n            this._createTouchHook();\n        }\n\n        this._renderer = renderer;\n    }\n\n    /**\n     * Value of `true` if accessibility is currently active and accessibility layers are showing.\n     * @type {boolean}\n     * @readonly\n     */\n    get isActive(): boolean\n    {\n        return this._isActive;\n    }\n\n    /**\n     * Value of `true` if accessibility is enabled for touch devices.\n     * @type {boolean}\n     * @readonly\n     */\n    get isMobileAccessibility(): boolean\n    {\n        return this._isMobileAccessibility;\n    }\n\n    /**\n     * The DOM element that will sit over the PixiJS element. This is where the div overlays will go.\n     * @readonly\n     */\n    get hookDiv()\n    {\n        return this._hookDiv;\n    }\n\n    /**\n     * Creates the touch hooks.\n     * @private\n     */\n    private _createTouchHook(): void\n    {\n        const hookDiv = document.createElement('button');\n\n        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.position = 'absolute';\n        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n        hookDiv.style.backgroundColor = '#FF0000';\n        hookDiv.title = 'select to enable accessibility for this content';\n\n        hookDiv.addEventListener('focus', () =>\n        {\n            this._isMobileAccessibility = true;\n            this._activate();\n            this._destroyTouchHook();\n        });\n\n        document.body.appendChild(hookDiv);\n        this._hookDiv = hookDiv;\n    }\n\n    /**\n     * Destroys the touch hooks.\n     * @private\n     */\n    private _destroyTouchHook(): void\n    {\n        if (!this._hookDiv)\n        {\n            return;\n        }\n        document.body.removeChild(this._hookDiv);\n        this._hookDiv = null;\n    }\n\n    /**\n     * Activating will cause the Accessibility layer to be shown.\n     * This is called when a user presses the tab key.\n     * @private\n     */\n    private _activate(): void\n    {\n        if (this._isActive)\n        {\n            return;\n        }\n\n        this._isActive = true;\n\n        // Create and add div if needed\n        if (!this._div)\n        {\n            this._div = document.createElement('div');\n            this._div.style.width = `${DIV_TOUCH_SIZE}px`;\n            this._div.style.height = `${DIV_TOUCH_SIZE}px`;\n            this._div.style.position = 'absolute';\n            this._div.style.top = `${DIV_TOUCH_POS_X}px`;\n            this._div.style.left = `${DIV_TOUCH_POS_Y}px`;\n            this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n            this._div.style.pointerEvents = 'none';\n        }\n\n        // Bind event handlers and add listeners when activating\n        if (this._activateOnTab)\n        {\n            this._onKeyDown = this._onKeyDown.bind(this);\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        if (this._deactivateOnMouseMove)\n        {\n            this._onMouseMove = this._onMouseMove.bind(this);\n            globalThis.document.addEventListener('mousemove', this._onMouseMove, true);\n        }\n\n        // Check if canvas is in DOM\n        const canvas = this._renderer.view.canvas;\n\n        if (!canvas.parentNode)\n        {\n            const observer = new MutationObserver(() =>\n            {\n                if (canvas.parentNode)\n                {\n                    canvas.parentNode.appendChild(this._div);\n                    observer.disconnect();\n\n                    // Only start the postrender runner after div is ready\n                    this._initAccessibilitySetup();\n                }\n            });\n\n            observer.observe(document.body, { childList: true, subtree: true });\n        }\n        else\n        {\n            // Add to DOM\n            canvas.parentNode.appendChild(this._div);\n\n            // Div is ready, initialize accessibility\n            this._initAccessibilitySetup();\n        }\n    }\n\n    // New method to handle initialization after div is ready\n    private _initAccessibilitySetup(): void\n    {\n        // Add the postrender runner to start processing accessible objects\n        this._renderer.runners.postrender.add(this);\n\n        // Force an initial update of accessible objects\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n        }\n    }\n\n    /**\n     * Deactivates the accessibility system. Removes listeners and accessibility elements.\n     * @private\n     */\n    private _deactivate(): void\n    {\n        if (!this._isActive || this._isMobileAccessibility)\n        {\n            return;\n        }\n\n        this._isActive = false;\n\n        // Switch listeners\n        globalThis.document.removeEventListener('mousemove', this._onMouseMove, true);\n        if (this._activateOnTab)\n        {\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        this._renderer.runners.postrender.remove(this);\n\n        // Remove all active accessibility elements\n        for (const child of this._children)\n        {\n            if (child._accessibleDiv && child._accessibleDiv.parentNode)\n            {\n                child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n                child._accessibleDiv = null;\n            }\n            child._accessibleActive = false;\n        }\n\n        // Clear the pool of divs\n        this._pool.forEach((div) =>\n        {\n            if (div.parentNode)\n            {\n                div.parentNode.removeChild(div);\n            }\n        });\n\n        // Remove parent div from DOM\n        if (this._div && this._div.parentNode)\n        {\n            this._div.parentNode.removeChild(this._div);\n        }\n\n        this._pool = [];\n        this._children = [];\n    }\n\n    /**\n     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n     * @private\n     * @param {Container} container - The Container to check.\n     */\n    private _updateAccessibleObjects(container: Container): void\n    {\n        if (!container.visible || !container.accessibleChildren)\n        {\n            return;\n        }\n\n        // Separate check for accessibility without requiring interactivity\n        if (container.accessible)\n        {\n            if (!container._accessibleActive)\n            {\n                this._addChild(container);\n            }\n\n            container._renderId = this._renderId;\n        }\n\n        const children = container.children;\n\n        if (children)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._updateAccessibleObjects(children[i] as Container);\n            }\n        }\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options?: AccessibilitySystemOptions): void\n    {\n        // Ensure we have the accessibilityOptions object\n        const defaultOpts = AccessibilitySystem.defaultOptions;\n        const mergedOptions = {\n            accessibilityOptions: {\n                ...defaultOpts,\n                ...(options?.accessibilityOptions || {})\n            }\n        };\n\n        this.debug = mergedOptions.accessibilityOptions.debug;\n        this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;\n        this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;\n\n        if (mergedOptions.accessibilityOptions.enabledByDefault)\n        {\n            this._activate();\n        }\n        else if (this._activateOnTab)\n        {\n            this._onKeyDown = this._onKeyDown.bind(this);\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        this._renderer.runners.postrender.remove(this);\n    }\n\n    /**\n     * Updates the accessibility layer during rendering.\n     * - Removes divs for containers no longer in the scene\n     * - Updates the position and dimensions of the root div\n     * - Updates positions of active accessibility divs\n     * Only fires while the accessibility system is active.\n     * @ignore\n     */\n    public postrender(): void\n    {\n        /* On Android default web browser, tab order seems to be calculated by position rather than tabIndex,\n        *  moving buttons can cause focus to flicker between two buttons making it hard/impossible to navigate,\n        *  so I am just running update every half a second, seems to fix it.\n        */\n        const now = performance.now();\n\n        if (this._mobileInfo.android.device && now < this._androidUpdateCount)\n        {\n            return;\n        }\n\n        this._androidUpdateCount = now + this._androidUpdateFrequency;\n\n        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas)\n        {\n            return;\n        }\n\n        // Track which containers are still active this frame\n        const activeIds = new Set<number>();\n\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n\n            // Mark all updated containers as active\n            for (const child of this._children)\n            {\n                if (child._renderId === this._renderId)\n                {\n                    activeIds.add(this._children.indexOf(child));\n                }\n            }\n        }\n\n        // Remove any containers that weren't updated this frame\n        for (let i = this._children.length - 1; i >= 0; i--)\n        {\n            const child = this._children[i];\n\n            if (!activeIds.has(i))\n            {\n                // Container was removed, clean up its accessibility div\n                if (child._accessibleDiv && child._accessibleDiv.parentNode)\n                {\n                    child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n\n                    this._pool.push(child._accessibleDiv);\n                    child._accessibleDiv = null;\n                }\n                child._accessibleActive = false;\n                removeItems(this._children, i, 1);\n            }\n        }\n\n        // Update root div dimensions if needed\n        if (this._renderer.renderingToScreen)\n        {\n            const { x, y, width: viewWidth, height: viewHeight } = this._renderer.screen;\n            const div = this._div;\n\n            div.style.left = `${x}px`;\n            div.style.top = `${y}px`;\n            div.style.width = `${viewWidth}px`;\n            div.style.height = `${viewHeight}px`;\n        }\n\n        // Update positions of existing divs\n        for (let i = 0; i < this._children.length; i++)\n        {\n            const child = this._children[i];\n\n            if (!child._accessibleActive || !child._accessibleDiv)\n            {\n                continue;\n            }\n\n            // Only update position-related properties\n            const div = child._accessibleDiv;\n            const hitArea = (child.hitArea || child.getBounds().rectangle) as Rectangle;\n\n            if (child.hitArea)\n            {\n                const wt = child.worldTransform;\n                const sx = this._renderer.resolution;\n                const sy = this._renderer.resolution;\n\n                div.style.left = `${(wt.tx + (hitArea.x * wt.a)) * sx}px`;\n                div.style.top = `${(wt.ty + (hitArea.y * wt.d)) * sy}px`;\n                div.style.width = `${hitArea.width * wt.a * sx}px`;\n                div.style.height = `${hitArea.height * wt.d * sy}px`;\n            }\n            else\n            {\n                this._capHitArea(hitArea);\n                const sx = this._renderer.resolution;\n                const sy = this._renderer.resolution;\n\n                div.style.left = `${hitArea.x * sx}px`;\n                div.style.top = `${hitArea.y * sy}px`;\n                div.style.width = `${hitArea.width * sx}px`;\n                div.style.height = `${hitArea.height * sy}px`;\n            }\n        }\n\n        // increment the render id..\n        this._renderId++;\n    }\n\n    /**\n     * private function that will visually add the information to the\n     * accessibility div\n     * @param {HTMLElement} div -\n     */\n    private _updateDebugHTML(div: AccessibleHTMLElement): void\n    {\n        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n    }\n\n    /**\n     * Adjust the hit area based on the bounds of a display object\n     * @param {Rectangle} hitArea - Bounds of the child\n     */\n    private _capHitArea(hitArea: Rectangle): void\n    {\n        if (hitArea.x < 0)\n        {\n            hitArea.width += hitArea.x;\n            hitArea.x = 0;\n        }\n\n        if (hitArea.y < 0)\n        {\n            hitArea.height += hitArea.y;\n            hitArea.y = 0;\n        }\n\n        const { width: viewWidth, height: viewHeight } = this._renderer;\n\n        if (hitArea.x + hitArea.width > viewWidth)\n        {\n            hitArea.width = viewWidth - hitArea.x;\n        }\n\n        if (hitArea.y + hitArea.height > viewHeight)\n        {\n            hitArea.height = viewHeight - hitArea.y;\n        }\n    }\n\n    /**\n     * Creates or reuses a div element for a Container and adds it to the accessibility layer.\n     * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.\n     * @private\n     * @param {Container} container - The child to make accessible.\n     */\n    private _addChild<T extends Container>(container: T): void\n    {\n        let div = this._pool.pop();\n\n        if (!div)\n        {\n            if (container.accessibleType === 'button')\n            {\n                div = document.createElement('button');\n            }\n            else\n            {\n                div = document.createElement(container.accessibleType);\n                div.style.cssText = `\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    `;\n                if (container.accessibleText)\n                {\n                    div.innerText = container.accessibleText;\n                }\n            }\n            div.style.width = `${DIV_TOUCH_SIZE}px`;\n            div.style.height = `${DIV_TOUCH_SIZE}px`;\n            div.style.backgroundColor = this.debug ? 'rgba(255,255,255,0.5)' : 'transparent';\n            div.style.position = 'absolute';\n            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n            div.style.borderStyle = 'none';\n\n            // ARIA attributes ensure that button title and hint updates are announced properly\n            if (navigator.userAgent.toLowerCase().includes('chrome'))\n            {\n                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.\n                div.setAttribute('aria-live', 'off');\n            }\n            else\n            {\n                div.setAttribute('aria-live', 'polite');\n            }\n\n            if (navigator.userAgent.match(/rv:.*Gecko\\//))\n            {\n                // FireFox needs this to announce only the new button name\n                div.setAttribute('aria-relevant', 'additions');\n            }\n            else\n            {\n                // required by IE, other browsers don't much care\n                div.setAttribute('aria-relevant', 'text');\n            }\n\n            div.addEventListener('click', this._onClick.bind(this));\n            div.addEventListener('focus', this._onFocus.bind(this));\n            div.addEventListener('focusout', this._onFocusOut.bind(this));\n        }\n\n        // set pointer events\n        div.style.pointerEvents = container.accessiblePointerEvents;\n        // set the type, this defaults to button!\n        div.type = container.accessibleType;\n\n        if (container.accessibleTitle && container.accessibleTitle !== null)\n        {\n            div.title = container.accessibleTitle;\n        }\n        else if (!container.accessibleHint\n            || container.accessibleHint === null)\n        {\n            div.title = `container ${container.tabIndex}`;\n        }\n\n        if (container.accessibleHint\n            && container.accessibleHint !== null)\n        {\n            div.setAttribute('aria-label', container.accessibleHint);\n        }\n\n        if (this.debug)\n        {\n            this._updateDebugHTML(div);\n        }\n\n        container._accessibleActive = true;\n        container._accessibleDiv = div;\n        div.container = container;\n\n        this._children.push(container);\n        this._div.appendChild(container._accessibleDiv);\n        if (container.interactive)\n        {\n            container._accessibleDiv.tabIndex = container.tabIndex;\n        }\n    }\n\n    /**\n     * Dispatch events with the EventSystem.\n     * @param e\n     * @param type\n     * @private\n     */\n    private _dispatchEvent(e: UIEvent, type: string[]): void\n    {\n        const { container: target } = e.target as AccessibleHTMLElement;\n        const boundary = this._renderer.events.rootBoundary;\n        const event: FederatedEvent = Object.assign(new FederatedEvent(boundary), { target });\n\n        boundary.rootTarget = this._renderer.lastObjectRendered as Container;\n        type.forEach((type) => boundary.dispatchEvent(event, type));\n    }\n\n    /**\n     * Maps the div button press to pixi's EventSystem (click)\n     * @private\n     * @param {MouseEvent} e - The click event.\n     */\n    private _onClick(e: MouseEvent): void\n    {\n        this._dispatchEvent(e, ['click', 'pointertap', 'tap']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseover)\n     * @private\n     * @param {FocusEvent} e - The focus event.\n     */\n    private _onFocus(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'assertive');\n        }\n\n        this._dispatchEvent(e, ['mouseover']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseout)\n     * @private\n     * @param {FocusEvent} e - The focusout event.\n     */\n    private _onFocusOut(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'polite');\n        }\n\n        this._dispatchEvent(e, ['mouseout']);\n    }\n\n    /**\n     * Is called when a key is pressed\n     * @private\n     * @param {KeyboardEvent} e - The keydown event.\n     */\n    private _onKeyDown(e: KeyboardEvent): void\n    {\n        if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab)\n        {\n            return;\n        }\n\n        this._activate();\n    }\n\n    /**\n     * Is called when the mouse moves across the renderer element\n     * @private\n     * @param {MouseEvent} e - The mouse event.\n     */\n    private _onMouseMove(e: MouseEvent): void\n    {\n        if (e.movementX === 0 && e.movementY === 0)\n        {\n            return;\n        }\n\n        this._deactivate();\n    }\n\n    /**\n     * Destroys the accessibility system. Removes all elements and listeners.\n     * > [!IMPORTANT] This is typically called automatically when the {@link Application} is destroyed.\n     * > A typically user should not need to call this method directly.\n     */\n    public destroy(): void\n    {\n        this._deactivate();\n        this._destroyTouchHook();\n\n        this._div = null;\n        this._pool = null;\n        this._children = null;\n        this._renderer = null;\n\n        if (this._activateOnTab)\n        {\n            globalThis.removeEventListener('keydown', this._onKeyDown);\n        }\n    }\n\n    /**\n     * Enables or disables the accessibility system.\n     * @param enabled - Whether to enable or disable accessibility.\n     * @example\n     * ```js\n     * app.renderer.accessibility.setAccessibilityEnabled(true); // Enable accessibility\n     * app.renderer.accessibility.setAccessibilityEnabled(false); // Disable accessibility\n     * ```\n     */\n    public setAccessibilityEnabled(enabled: boolean): void\n    {\n        if (enabled)\n        {\n            this._activate();\n        }\n        else\n        {\n            this._deactivate();\n        }\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { Container } from '../scene/container/Container';\nimport { AccessibilitySystem } from './AccessibilitySystem';\nimport { accessibilityTarget } from './accessibilityTarget';\n\nextensions.add(AccessibilitySystem);\nextensions.mixin(Container, accessibilityTarget);\n","import type { Container } from '../scene/container/Container';\n\n/**\n * The type of the pointer event to listen for.\n * @category accessibility\n * @standard\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\n */\nexport type PointerEvents = 'auto'\n| 'none'\n| 'visiblePainted'\n| 'visibleFill'\n| 'visibleStroke'\n| 'visible'\n| 'painted'\n| 'fill'\n| 'stroke'\n| 'all'\n| 'inherit';\n\n/**\n * When `accessible` is enabled on any display object, these properties will affect its accessibility.\n * @example\n * const container = new Container();\n * container.accessible = true;\n * container.accessibleTitle = 'My Container';\n * container.accessibleHint = 'This is a container';\n * container.tabIndex = 0;\n * @category accessibility\n * @standard\n */\nexport interface AccessibleOptions\n{\n    /**\n     * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n     * shadow div with attributes set\n     * @default false\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * ```\n     */\n    accessible: boolean;\n    /**\n     * Sets the title attribute of the shadow div\n     * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n     * @type {string}\n     * @default null\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleTitle = 'My Container';\n     * ```\n     */\n    accessibleTitle: string | null;\n    /**\n     * Sets the aria-label attribute of the shadow div\n     * @default null\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleHint = 'This is a container';\n     * ```\n     */\n    accessibleHint: string | null;\n    /**\n     * Sets the tabIndex of the shadow div. You can use this to set the order of the\n     * elements when using the tab key to navigate.\n     * @default 0\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.tabIndex = 0;\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.accessible = true;\n     * sprite.tabIndex = 1;\n     * ```\n     */\n    tabIndex: number;\n    /**\n     * Specify the type of div the accessible layer is. Screen readers treat the element differently\n     * depending on this type. Defaults to button.\n     * @default 'button'\n     * @type {string}\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleType = 'button'; // or 'link', 'checkbox', etc.\n     * ```\n     */\n    accessibleType: keyof HTMLElementTagNameMap;\n    /**\n     * Specify the pointer-events the accessible div will use\n     * Defaults to auto.\n     * @default 'auto'\n     * @type {PointerEvents}\n     * @advanced\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessiblePointerEvents = 'none'; // or 'auto', 'visiblePainted', etc.\n     * ```\n     */\n    accessiblePointerEvents: PointerEvents;\n\n    /**\n     * Sets the text content of the shadow\n     * @default null\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleText = 'This is a container';\n     * ```\n     */\n    accessibleText: string | null;\n\n    /**\n     * Setting to false will prevent any children inside this container to\n     * be accessible. Defaults to true.\n     * @default true\n     * @example\n     * ```js\n     * const container = new Container();\n     * container.accessible = true;\n     * container.accessibleChildren = false; // This will prevent any children from being accessible\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.accessible = true; // This will not work since accessibleChildren is false\n     * ```\n     */\n    accessibleChildren: boolean;\n}\n\n/**\n * The Accessibility object is attached to the {@link Container}.\n * @private\n */\nexport interface AccessibleTarget extends AccessibleOptions\n{\n    /** @private */\n    _accessibleActive: boolean;\n    /** @private */\n    _accessibleDiv: AccessibleHTMLElement | null;\n    /** @private */\n    _renderId: number;\n}\n\n/** @internal */\nexport interface AccessibleHTMLElement extends HTMLElement\n{\n    type?: string;\n    container?: Container;\n}\n\n/**\n * Default property values of accessible objects\n * used by {@link AccessibilitySystem}.\n * @internal\n * @example\n * import { accessibleTarget } from 'pixi.js';\n *\n * function MyObject() {}\n * Object.assign(MyObject.prototype, accessibleTarget);\n */\nexport const accessibilityTarget: AccessibleTarget = {\n    accessible: false,\n    accessibleTitle: null,\n    accessibleHint: null,\n    tabIndex: 0,\n    accessibleType: 'button',\n    accessibleText: null,\n    accessiblePointerEvents: 'auto',\n    accessibleChildren: true,\n    _accessibleActive: false,\n    _accessibleDiv: null,\n    _renderId: -1,\n};\n","import { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { EventSystem } from './EventSystem';\n\n/** @advanced */\nclass EventsTickerClass\n{\n    /** The event system. */\n    public events: EventSystem;\n    /** The DOM element to listen to events on. */\n    public domElement: HTMLElement;\n    /** The frequency that fake events will be fired. */\n    public interactionFrequency = 10;\n\n    private _deltaTime = 0;\n    private _didMove = false;\n    private _tickerAdded = false;\n    private _pauseUpdate = true;\n\n    /**\n     * Initializes the event ticker.\n     * @param events - The event system.\n     */\n    public init(events: EventSystem): void\n    {\n        this.removeTickerListener();\n        this.events = events;\n        this.interactionFrequency = 10;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n\n    /** Whether to pause the update checks or not. */\n    get pauseUpdate(): boolean\n    {\n        return this._pauseUpdate;\n    }\n\n    set pauseUpdate(paused: boolean)\n    {\n        this._pauseUpdate = paused;\n    }\n\n    /** Adds the ticker listener. */\n    public addTickerListener(): void\n    {\n        if (this._tickerAdded || !this.domElement)\n        {\n            return;\n        }\n\n        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n\n        this._tickerAdded = true;\n    }\n\n    /** Removes the ticker listener. */\n    public removeTickerListener(): void\n    {\n        if (!this._tickerAdded)\n        {\n            return;\n        }\n\n        Ticker.system.remove(this._tickerUpdate, this);\n\n        this._tickerAdded = false;\n    }\n\n    /** Sets flag to not fire extra events when the user has already moved there mouse */\n    public pointerMoved(): void\n    {\n        this._didMove = true;\n    }\n\n    /** Updates the state of interactive objects. */\n    private _update(): void\n    {\n        if (!this.domElement || this._pauseUpdate)\n        {\n            return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this._didMove)\n        {\n            this._didMove = false;\n\n            return;\n        }\n\n        // eslint-disable-next-line dot-notation\n        const rootPointerEvent = this.events['_rootPointerEvent'];\n\n        if (this.events.supportsTouchEvents && (rootPointerEvent as PointerEvent).pointerType === 'touch')\n        {\n            return;\n        }\n\n        globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent('pointermove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n            pointerType: rootPointerEvent.pointerType,\n            pointerId: rootPointerEvent.pointerId,\n        }) : new MouseEvent('mousemove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n        }));\n    }\n\n    /**\n     * Updates the state of interactive objects if at least {@link interactionFrequency}\n     * milliseconds have passed since the last invocation.\n     *\n     * Invoked by a throttled ticker update from {@link Ticker.system}.\n     * @param ticker - The throttled ticker.\n     */\n    private _tickerUpdate(ticker: Ticker): void\n    {\n        this._deltaTime += ticker.deltaTime;\n\n        if (this._deltaTime < this.interactionFrequency)\n        {\n            return;\n        }\n\n        this._deltaTime = 0;\n\n        this._update();\n    }\n}\n\n/**\n * This class handles automatic firing of PointerEvents\n * in the case where the pointer is stationary for too long.\n * This is to ensure that hit-tests are still run on moving objects.\n * @since 7.2.0\n * @category events\n * @class\n * @advanced\n */\nexport const EventsTicker = new EventsTickerClass();\n","import { Point } from '../maths/point/Point';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { Container } from '../scene/container/Container';\nimport type { PixiTouch } from './FederatedEvent';\n\n/**\n * A specialized event class for mouse interactions in PixiJS applications.\n * Extends {@link FederatedEvent} to provide mouse-specific properties and methods\n * while maintaining compatibility with the DOM MouseEvent interface.\n *\n * Key features:\n * - Tracks mouse button states\n * - Provides modifier key states\n * - Supports coordinate systems (client, screen, global)\n * - Enables precise position tracking\n * @example\n * ```ts\n * // Basic mouse event handling\n * sprite.on('mousemove', (event: FederatedMouseEvent) => {\n *     // Get coordinates in different spaces\n *     console.log('Global position:', event.global.x, event.global.y);\n *     console.log('Client position:', event.client.x, event.client.y);\n *     console.log('Screen position:', event.screen.x, event.screen.y);\n *\n *     // Check button and modifier states\n *     if (event.buttons === 1 && event.ctrlKey) {\n *         console.log('Left click + Control key');\n *     }\n *\n *     // Get local coordinates relative to any container\n *     const localPos = event.getLocalPosition(container);\n *     console.log('Local position:', localPos.x, localPos.y);\n * });\n *\n * // Handle mouse button states\n * sprite.on('mousedown', (event: FederatedMouseEvent) => {\n *     console.log('Mouse button:', event.button); // 0=left, 1=middle, 2=right\n *     console.log('Active buttons:', event.buttons);\n * });\n * ```\n * @category events\n * @see {@link FederatedEvent} For base event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent} DOM MouseEvent Interface\n * @standard\n */\nexport class FederatedMouseEvent extends FederatedEvent<\nMouseEvent | PointerEvent | PixiTouch\n> implements MouseEvent\n{\n    /** Whether the \"alt\" key was pressed when this mouse event occurred. */\n    public altKey: boolean;\n\n    /** The specific button that was pressed in this mouse event. */\n    public button: number;\n\n    /** The button depressed when this event occurred. */\n    public buttons: number;\n\n    /** Whether the \"control\" key was pressed when this mouse event occurred. */\n    public ctrlKey: boolean;\n\n    /** Whether the \"meta\" key was pressed when this mouse event occurred. */\n    public metaKey: boolean;\n\n    /** This is currently not implemented in the Federated Events API. */\n    public relatedTarget: EventTarget;\n\n    /** Whether the \"shift\" key was pressed when this mouse event occurred. */\n    public shiftKey: boolean;\n\n    /** The coordinates of the mouse event relative to the canvas. */\n    public client: Point = new Point();\n\n    /** @readonly */\n    public get clientX(): number { return this.client.x; }\n\n    /** @readonly */\n    public get clientY(): number { return this.client.y; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n     * @readonly\n     */\n    get x(): number { return this.clientX; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n     * @readonly\n     */\n    get y(): number { return this.clientY; }\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    public movement: Point = new Point();\n\n    /** @readonly */\n    get movementX(): number { return this.movement.x; }\n\n    /** @readonly */\n    get movementY(): number { return this.movement.y; }\n\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    public offset: Point = new Point();\n\n    /** @readonly */\n    get offsetX(): number { return this.offset.x; }\n\n    /** @readonly */\n    get offsetY(): number { return this.offset.y; }\n\n    /** The pointer coordinates in world space. */\n    public global: Point = new Point();\n\n    /** @readonly */\n    get globalX(): number { return this.global.x; }\n\n    /** @readonly */\n    get globalY(): number { return this.global.y; }\n\n    /**\n     * The pointer coordinates in the renderer's {@link AbstractRenderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    public screen: Point = new Point();\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for `screen.x`.\n     * @readonly\n     */\n    get screenX(): number { return this.screen.x; }\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for `screen.y`.\n     * @readonly\n     */\n    get screenY(): number { return this.screen.y; }\n\n    /**\n     * Converts global coordinates into container-local coordinates.\n     *\n     * This method transforms coordinates from world space to a container's local space,\n     * useful for precise positioning and hit testing.\n     * @param container - The Container to get local coordinates for\n     * @param point - Optional Point object to store the result. If not provided, a new Point will be created\n     * @param globalPos - Optional custom global coordinates. If not provided, the event's global position is used\n     * @returns The local coordinates as a Point object\n     * @example\n     * ```ts\n     * // Basic usage - get local coordinates relative to a container\n     * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n     *     // Get position relative to the sprite\n     *     const localPos = event.getLocalPosition(sprite);\n     *     console.log('Local position:', localPos.x, localPos.y);\n     * });\n     * // Using custom global coordinates\n     * const customGlobal = new Point(100, 100);\n     * sprite.on('pointermove', (event: FederatedMouseEvent) => {\n     *     // Transform custom coordinates\n     *     const localPos = event.getLocalPosition(sprite, undefined, customGlobal);\n     *     console.log('Custom local position:', localPos.x, localPos.y);\n     * });\n     * ```\n     * @see {@link Container.worldTransform} For the transformation matrix\n     * @see {@link Point} For the point class used to store coordinates\n     */\n    public getLocalPosition<P extends PointData = Point>(container: Container, point?: P, globalPos?: PointData): P\n    {\n        return container.worldTransform.applyInverse<P>(globalPos || this.global, point);\n    }\n\n    /**\n     * Whether the modifier key was pressed when this event natively occurred.\n     * @param key - The modifier key.\n     */\n    public getModifierState(key: string): boolean\n    {\n        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n\n    /**\n     * Not supported.\n     * @param _typeArg\n     * @param _canBubbleArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     * @param _screenXArg\n     * @param _screenYArg\n     * @param _clientXArg\n     * @param _clientYArg\n     * @param _ctrlKeyArg\n     * @param _altKeyArg\n     * @param _shiftKeyArg\n     * @param _metaKeyArg\n     * @param _buttonArg\n     * @param _relatedTargetArg\n     * @deprecated since 7.0.0\n     * @ignore\n     */\n    // eslint-disable-next-line max-params\n    public initMouseEvent(\n        _typeArg: string,\n        _canBubbleArg: boolean,\n        _cancelableArg: boolean,\n        _viewArg: Window,\n        _detailArg: number,\n        _screenXArg: number,\n        _screenYArg: number,\n        _clientXArg: number,\n        _clientYArg: number,\n        _ctrlKeyArg: boolean,\n        _altKeyArg: boolean,\n        _shiftKeyArg: boolean,\n        _metaKeyArg: boolean,\n        _buttonArg: number,\n        _relatedTargetArg: EventTarget\n    ): void\n    {\n        throw new Error('Method not implemented.');\n    }\n}\n","import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A specialized event class for pointer interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide advanced pointer-specific features\n * while maintaining compatibility with the DOM PointerEvent interface.\n *\n * Key features:\n * - Supports multi-touch interactions\n * - Provides pressure sensitivity\n * - Handles stylus input\n * - Tracks pointer dimensions\n * - Supports tilt detection\n * @example\n * ```ts\n * // Basic pointer event handling\n * sprite.on('pointerdown', (event: FederatedPointerEvent) => {\n *     // Access pointer information\n *     console.log('Pointer ID:', event.pointerId);\n *     console.log('Pointer Type:', event.pointerType);\n *     console.log('Is Primary:', event.isPrimary);\n *\n *     // Get pressure and tilt data\n *     console.log('Pressure:', event.pressure);\n *     console.log('Tilt:', event.tiltX, event.tiltY);\n *\n *     // Access contact geometry\n *     console.log('Size:', event.width, event.height);\n * });\n *\n * // Handle stylus-specific features\n * sprite.on('pointermove', (event: FederatedPointerEvent) => {\n *     if (event.pointerType === 'pen') {\n *         // Handle stylus tilt\n *         const tiltAngle = Math.atan2(event.tiltY, event.tiltX);\n *         console.log('Tilt angle:', tiltAngle);\n *\n *         // Use barrel button pressure\n *         console.log('Tangential pressure:', event.tangentialPressure);\n *     }\n * });\n * ```\n * @see {@link FederatedMouseEvent} For base mouse event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent} DOM PointerEvent Interface\n * @see {@link EventSystem} For the event management system\n * @category events\n * @standard\n */\nexport class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent\n{\n    /**\n     * The unique identifier of the pointer.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}\n     */\n    public pointerId: number;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    public width = 0;\n\n    /**\n     * The angle in radians of a pointer or stylus measuring the vertical angle between\n     * the device's surface to the pointer or stylus.\n     * A stylus at 0 degrees would be directly parallel whereas at π/2 degrees it would be perpendicular.\n     * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/altitudeAngle)\n     */\n    public altitudeAngle: number;\n\n    /**\n     * The angle in radians of a pointer or stylus measuring an arc from the X axis of the device to\n     * the pointer or stylus projected onto the screen's plane.\n     * A stylus at 0 degrees would be pointing to the \"0 o'clock\" whereas at π/2 degrees it would be pointing at \"6 o'clock\".\n     * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/azimuthAngle)\n     */\n    public azimuthAngle: number;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    public height = 0;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    public isPrimary = false;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */\n    public pointerType: string;\n\n    /**\n     * Pressure applied by the pointing device during the event.\n     *s\n     * A Touch's force property will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */\n    public pressure: number;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public tangentialPressure: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     */\n    public tiltX: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     */\n    public tiltY: number;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public twist: number;\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /**\n     * Only included for completeness for now\n     * @ignore\n     */\n    public getCoalescedEvents(): PointerEvent[]\n    {\n        if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove')\n        {\n            return [this];\n        }\n\n        return [];\n    }\n\n    /**\n     * Only included for completeness for now\n     * @ignore\n     */\n    public getPredictedEvents(): PointerEvent[]\n    {\n        throw new Error('getPredictedEvents is not supported!');\n    }\n}\n","import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A specialized event class for wheel/scroll interactions in PixiJS applications.\n * Extends {@link FederatedMouseEvent} to provide wheel-specific properties while\n * maintaining compatibility with the DOM WheelEvent interface.\n *\n * Key features:\n * - Provides scroll delta information\n * - Supports different scroll modes (pixel, line, page)\n * - Inherits mouse event properties\n * - Normalizes cross-browser wheel events\n * @example\n * ```ts\n * // Basic wheel event handling\n * sprite.on('wheel', (event: FederatedWheelEvent) => {\n *     // Get scroll amount\n *     console.log('Vertical scroll:', event.deltaY);\n *     console.log('Horizontal scroll:', event.deltaX);\n *\n *     // Check scroll mode\n *     if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_LINE) {\n *         console.log('Scrolling by lines');\n *     } else if (event.deltaMode === FederatedWheelEvent.DOM_DELTA_PAGE) {\n *         console.log('Scrolling by pages');\n *     } else {\n *         console.log('Scrolling by pixels');\n *     }\n *\n *     // Get scroll position\n *     console.log('Scroll at:', event.global.x, event.global.y);\n * });\n *\n * // Common use case: Zoom control\n * container.on('wheel', (event: FederatedWheelEvent) => {\n *     // Prevent page scrolling\n *     event.preventDefault();\n *\n *     // Zoom in/out based on scroll direction\n *     const zoomFactor = 1 + (event.deltaY / 1000);\n *     container.scale.set(container.scale.x * zoomFactor);\n * });\n * ```\n * @see {@link FederatedMouseEvent} For base mouse event functionality\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent} DOM WheelEvent Interface\n * @see {@link EventSystem} For the event management system\n * @category events\n * @standard\n */\nexport class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent\n{\n    /**\n     * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n     * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n     */\n    public deltaMode: number;\n\n    /** Horizontal scroll amount */\n    public deltaX: number;\n\n    /** Vertical scroll amount */\n    public deltaY: number;\n\n    /** z-axis scroll amount. */\n    public deltaZ: number;\n\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_PIXEL = 0;\n\n    /**\n     * Units specified in pixels.\n     * @ignore\n     */\n    public readonly DOM_DELTA_PIXEL = 0;\n\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_LINE = 1;\n\n    /**\n     * Units specified in lines.\n     * @ignore\n     */\n    public readonly DOM_DELTA_LINE = 1;\n\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    public static readonly DOM_DELTA_PAGE = 2;\n\n    /**\n     * Units specified in pages.\n     * @ignore\n     */\n    public readonly DOM_DELTA_PAGE = 2;\n}\n","import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point';\nimport { warn } from '../utils/logging/warn';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { Container } from '../scene/container/Container';\nimport type { EmitterListeners, TrackingData } from './EventBoundaryTypes';\nimport type { FederatedEvent } from './FederatedEvent';\nimport type {\n    Cursor, EventMode, FederatedEventHandler,\n} from './FederatedEventTarget';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from 'pixi.js';\n * import { EventBoundary } from 'pixi.js';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends Container\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @category events\n * @advanced\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: Container;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: EventEmitter = new EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | (string & {});\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    public enableGlobalMoveEvents = true;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    private readonly _allInteractiveElements: Container[] = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    private _hitElements: Container[] = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    private _isPointerMoveEvent = false;\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: Container)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e - The event to dispatch.\n     * @param type - The type of event to dispatch. Defaults to `e.type`.\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e - The event to map.\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            // #if _DEBUG\n            warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n            // #endif\n        }\n    }\n\n    /**\n     * Finds the Container that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x - The x coordinate of the event.\n     * @param y - The y coordinate of the event.\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): Container\n    {\n        EventsTicker.pauseUpdate = true;\n        // if we are using global move events, we need to hit test the whole scene graph\n        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n        const fn = useMove ? 'hitTestMoveRecursive' : 'hitTestRecursive';\n        const invertedPath = this[fn](\n            this.rootTarget,\n            this.rootTarget.eventMode,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target `e.target`.\n     * @param e - The event to propagate.\n     * @param type - The type of event to propagate. Defaults to `e.type`.\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event `e` to all interactive containers. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `globalpointermove` event.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param targets - The targets to notify.\n     */\n    public all(e: FederatedEvent, type?: string | string[], targets = this._allInteractiveElements): void\n    {\n        if (targets.length === 0) return;\n\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const events = Array.isArray(type) ? type : [type];\n\n        // loop through all interactive elements and notify them of the event\n        // loop through targets backwards\n        for (let i = targets.length - 1; i >= 0; i--)\n        {\n            events.forEach((event) =>\n            {\n                e.currentTarget = targets[i];\n                this.notifyTarget(e, event);\n            });\n        }\n    }\n\n    /**\n     * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n     * `target`. The last element in the path is `target`.\n     * @param target - The target to find the propagation path to.\n     */\n    public propagationPath(target: Container): Container[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    protected hitTestMoveRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean,\n        ignore = false\n    ): Container[]\n    {\n        let shouldReturn = false;\n\n        // only bail out early if it is not interactive\n        if (this._interactivePrune(currentTarget)) return null;\n\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestMoveRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    location,\n                    testFn,\n                    pruneFn,\n                    ignore || pruneFn(currentTarget, location)\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive)\n                    {\n                        if (isInteractive) this._allInteractiveElements.push(currentTarget);\n                        nestedHit.push(currentTarget);\n                    }\n\n                    // store all hit elements to be returned once we have traversed the whole tree\n                    if (this._hitElements.length === 0) this._hitElements = nestedHit;\n\n                    shouldReturn = true;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n\n        // we don't carry on hit testing something once we have found a hit,\n        // now only care about gathering the interactive elements\n        if (ignore || this._hitElements.length > 0) return null;\n\n        if (shouldReturn) return this._hitElements as Container[];\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location)))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The Container that is to be hit tested.\n     * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the container.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean\n    ): Container[]\n    {\n        // Attempt to prune this Container and its subtree as an optimization.\n        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n            const relativeLocation = location;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    relativeLocation,\n                    testFn,\n                    pruneFn\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    private _isInteractive(int: EventMode): int is 'static' | 'dynamic'\n    {\n        return int === 'static' || int === 'dynamic';\n    }\n\n    private _interactivePrune(container: Container): boolean\n    {\n        // If container is a mask, invisible, or not renderable then it cannot be hit directly.\n        if (!container || !container.visible || !container.renderable || !container.measurable)\n        {\n            return true;\n        }\n\n        // If this Container is none then it cannot be hit by anything.\n        if (container.eventMode === 'none')\n        {\n            return true;\n        }\n\n        // If this Container is passive and it has no interactive children then it cannot be hit\n        if (container.eventMode === 'passive' && !container.interactiveChildren)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n     * and {@link Container._maskEffect} for pruning.\n     * @param container - The container to prune.\n     * @param location - The location to test for overlap.\n     */\n    protected hitPruneFn(container: Container, location: Point): boolean\n    {\n        if (container.hitArea)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (container.effects && container.effects.length)\n        {\n            for (let i = 0; i < container.effects.length; i++)\n            {\n                const effect = container.effects[i];\n\n                if (effect.containsPoint)\n                {\n                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n\n                    if (!effectContainsPoint)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container passes hit testing for the given location.\n     * @param container - The container to test.\n     * @param location - The location to test for overlap.\n     * @returns - Whether `container` passes hit testing for `location`.\n     */\n    protected hitTestFn(container: Container, location: Point): boolean\n    {\n        // If the container failed pruning with a hitArea, then it must pass it.\n        if (container.hitArea)\n        {\n            return true;\n        }\n\n        if ((container as Renderable)?.containsPoint)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            return (container as Renderable).containsPoint(tempLocalMapping) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     *\n     * If the `currentTarget` contains the property `on<type>`, then it is called here,\n     * simulating the behavior from version 6.x and prior.\n     * @param e - The event passed to the target.\n     * @param type - The type of event to notify. Defaults to `e.type`.\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        if (!e.currentTarget.isInteractive())\n        {\n            return;\n        }\n\n        type ??= e.type;\n\n        // call the `on${type}` for the current target if it exists\n        const handlerKey = `on${type}` as keyof Container;\n\n        (e.currentTarget[handlerKey] as FederatedEventHandler<FederatedEvent>)?.(e);\n\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this._notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this._notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from - The upstream `pointerdown` event.\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        this._isPointerMoveEvent = true;\n        const e = this.createPointerEvent(from);\n\n        this._isPointerMoveEvent = false;\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets?.length > 0 && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered Container is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const allMethods: string[] = [];\n        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n\n        this.moveOnAll ? allMethods.push('pointermove') : this.dispatchEvent(e, 'pointermove');\n        allowGlobalPointerEvents && allMethods.push('globalpointermove');\n\n        // Then pointermove\n        if (e.pointerType === 'touch')\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'touchmove') : this.dispatchEvent(e, 'touchmove');\n            allowGlobalPointerEvents && allMethods.push('globaltouchmove');\n        }\n\n        if (isMouse)\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'mousemove') : this.dispatchEvent(e, 'mousemove');\n            allowGlobalPointerEvents && allMethods.push('globalmousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        if (allMethods.length > 0)\n        {\n            this.all(e, allMethods);\n        }\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n     * and `click`/`rightclick`/`pointertap` events, in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                const isRightButton = clickEvent.button === 2;\n\n                this.dispatchEvent(clickEvent, isRightButton ? 'rightclick' : 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n     * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-wheel event as a wheel event');\n            // #endif\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: Container[]): Container\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose `originalEvent` is `from`, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The `originalEvent` for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: Container\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target\n            ?? this.hitTest(event.global.x, event.global.y) as Container\n            ?? this._hitElements[0];\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose `originalEvent` is `from`.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event `from`, with an optional `type` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link FederatedWheelEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link FederatedPointerEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link FederatedMouseEvent} data from `from` to `to`.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + shiftKey\n     * + global\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n        to.screen.copyFrom(from.screen);\n        to.shiftKey = from.shiftKey;\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link FederatedEvent} data from `from` into `to`.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.defaultPrevented = false;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private _notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n\n        if ('fn' in listeners)\n        {\n            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, undefined, true);\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, undefined, true);\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n","import { ExtensionType } from '../extensions/Extensions';\nimport { EventBoundary } from './EventBoundary';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { PointData } from '../maths/point/PointData';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { PixiTouch } from './FederatedEvent';\nimport type { EventMode } from './FederatedEventTarget';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\n/**\n * Options for configuring the PixiJS event system. These options control how the event system\n * handles different types of interactions and event propagation.\n * @example\n * ```ts\n * // Basic event system configuration\n * const app = new Application();\n * await app.init({\n *     // Configure default interaction mode\n *     eventMode: 'static',\n *\n *     // Configure event features\n *     eventFeatures: {\n *         move: true,           // Enable pointer movement events\n *         globalMove: false,    // Disable global move events\n *         click: true,          // Enable click events\n *         wheel: true          // Enable wheel/scroll events\n *     }\n * });\n *\n * // Access event system after initialization\n * const eventSystem = app.renderer.events;\n * console.log(eventSystem.features); // Check enabled features\n * ```\n * @see {@link EventSystem} For the main event system implementation\n * @see {@link EventMode} For interaction mode details\n * @see {@link EventSystemFeatures} For all available feature options\n * @advanced\n * @category events\n */\nexport interface EventSystemOptions\n{\n    /**\n     * The default event mode for all display objects.\n     * Controls how objects respond to interaction events.\n     *\n     * Possible values:\n     * - `'none'`: No interaction events\n     * - `'passive'`: Only container's children receive events (default)\n     * - `'auto'`: Receives events when parent is interactive\n     * - `'static'`: Standard interaction events\n     * - `'dynamic'`: Like static but with additional synthetic events\n     * @default 'passive'\n     */\n    eventMode?: EventMode;\n\n    /**\n     * Configuration for enabling/disabling specific event features.\n     * Use this to optimize performance by turning off unused functionality.\n     * @example\n     * ```ts\n     * const app = new Application();\n     * await app.init({\n     *     eventFeatures: {\n     *         // Core interaction events\n     *         move: true,        // Pointer/mouse/touch movement\n     *         click: true,       // Click/tap events\n     *         wheel: true,       // Mouse wheel/scroll events\n     *         // Global tracking\n     *         globalMove: false  // Global pointer movement\n     *     }\n     * });\n     * ```\n     */\n    eventFeatures?: Partial<EventSystemFeatures>;\n}\n\n/**\n * The event features that are enabled by the EventSystem. These features control\n * different types of interaction events in your PixiJS application.\n * @example\n * ```ts\n * // Configure features during application initialization\n * const app = new Application();\n * await app.init({\n *     eventFeatures: {\n *         // Basic interaction events\n *         move: true,        // Enable pointer movement tracking\n *         click: true,       // Enable click/tap events\n *         wheel: true,       // Enable mouse wheel/scroll events\n *         // Advanced features\n *         globalMove: false  // Disable global move tracking for performance\n *     }\n * });\n *\n * // Or configure after initialization\n * app.renderer.events.features.move = false;      // Disable movement events\n * app.renderer.events.features.globalMove = true; // Enable global tracking\n * ```\n * @since 7.2.0\n * @category events\n * @advanced\n */\nexport interface EventSystemFeatures\n{\n    /**\n     * Enables pointer events associated with pointer movement.\n     *\n     * When enabled, these events will fire:\n     * - `pointermove` / `mousemove` / `touchmove`\n     * - `pointerout` / `mouseout`\n     * - `pointerover` / `mouseover`\n     * @example\n     * ```ts\n     * // Enable movement events\n     * app.renderer.events.features.move = true;\n     *\n     * // Listen for movement\n     * sprite.on('pointermove', (event) => {\n     *     console.log('Pointer position:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    move: boolean;\n\n    /**\n     * Enables global pointer move events that fire regardless of target.\n     *\n     * When enabled, these events will fire:\n     * - `globalpointermove`\n     * - `globalmousemove`\n     * - `globaltouchmove`\n     * @example\n     * ```ts\n     * // Enable global tracking\n     * app.renderer.events.features.globalMove = true;\n     *\n     * // Track pointer globally\n     * sprite.on('globalpointermove', (event) => {\n     *     // Fires even when pointer is not over sprite\n     *     console.log('Global position:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    globalMove: boolean;\n    /**\n     * Enables pointer events associated with clicking/tapping.\n     *\n     * When enabled, these events will fire:\n     * - `pointerdown` / `mousedown` / `touchstart` / `rightdown`\n     * - `pointerup` / `mouseup` / `touchend` / `rightup`\n     * - `pointerupoutside` / `mouseupoutside` / `touchendoutside` / `rightupoutside`\n     * - `click` / `tap`\n     * @example\n     * ```ts\n     * // Enable click events\n     * app.renderer.events.features.click = true;\n     *\n     * // Handle clicks\n     * sprite.on('click', (event) => {\n     *     console.log('Clicked at:', event.global.x, event.global.y);\n     * });\n     * ```\n     * @default true\n     */\n    click: boolean;\n    /**\n     * Enables mouse wheel/scroll events.\n     * @example\n     * ```ts\n     * // Enable wheel events\n     * app.renderer.events.features.wheel = true;\n     *\n     * // Handle scrolling\n     * sprite.on('wheel', (event) => {\n     *     // Zoom based on scroll direction\n     *     const scale = 1 + (event.deltaY / 1000);\n     *     sprite.scale.set(sprite.scale.x * scale);\n     * });\n     * ```\n     * @default true\n     */\n    wheel: boolean;\n}\n\n/**\n * The system for handling UI events in PixiJS applications. This class manages mouse, touch, and pointer events,\n * normalizing them into a consistent event model.\n * @example\n * ```ts\n * // Access event system through renderer\n * const eventSystem = app.renderer.events;\n *\n * // Configure event features\n * eventSystem.features.globalMove = false;  // Disable global move events\n * eventSystem.features.click = true;        // Enable click events\n *\n * // Set custom cursor styles\n * eventSystem.cursorStyles.default = 'pointer';\n * eventSystem.cursorStyles.grab = 'grab';\n *\n * // Get current pointer position\n * const pointer = eventSystem.pointer;\n * console.log(pointer.global.x, pointer.global.y);\n * ```\n *\n * Features:\n * - Normalizes browser events into consistent format\n * - Supports mouse, touch, and pointer events\n * - Handles event delegation and bubbling\n * - Provides cursor management\n * - Configurable event features\n * @see {@link EventBoundary} For event propagation and handling\n * @see {@link FederatedEvent} For the base event class\n * @see {@link EventMode} For interaction modes\n * @category events\n * @standard\n */\nexport class EventSystem implements System<EventSystemOptions>\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'events',\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.CanvasSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        priority: -1,\n    };\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * @since 7.2.0\n     * @example\n     * ```ts\n     * import { EventSystem, EventSystemFeatures } from 'pixi.js';\n     * // Access the default event features\n     * EventSystem.defaultEventFeatures = {\n     *     // Enable pointer movement events\n     *     move: true,\n     *     // Enable global pointer move events\n     *     globalMove: true,\n     *     // Enable click events\n     *     click: true,\n     *     // Enable wheel events\n     *     wheel: true,\n     * };\n     * ```\n     */\n    public static defaultEventFeatures: EventSystemFeatures = {\n        /** Enables pointer events associated with pointer movement. */\n        move: true,\n        /** Enables global pointer move events. */\n        globalMove: true,\n        /** Enables pointer events associated with clicking. */\n        click: true,\n        /** Enables wheel events. */\n        wheel: true,\n    };\n\n    private static _defaultEventMode: EventMode;\n\n    /**\n     * The default interaction mode for all display objects.\n     * @see Container.eventMode\n     * @type {EventMode}\n     * @readonly\n     * @since 7.2.0\n     */\n    public static get defaultEventMode()\n    {\n        return this._defaultEventMode;\n    }\n\n    /**\n     * The {@link EventBoundary} for the stage.\n     *\n     * The {@link EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed Containers).\n     * @advanced\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /**\n     * Indicates whether the current device supports touch events according to the W3C Touch Events spec.\n     * This is used to determine the appropriate event handling strategy.\n     * @see {@link https://www.w3.org/TR/touch-events/} W3C Touch Events Specification\n     * @readonly\n     * @default 'ontouchstart' in globalThis\n     */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /**\n     * Indicates whether the current device supports pointer events according to the W3C Pointer Events spec.\n     * Used to optimize event handling and provide more consistent cross-device interaction.\n     * @see {@link https://www.w3.org/TR/pointerevents/} W3C Pointer Events Specification\n     * @readonly\n     * @default !!globalThis.PointerEvent\n     */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Controls whether default browser actions are automatically prevented on pointer events.\n     * When true, prevents default browser actions from occurring on pointer events.\n     * @remarks\n     * - Does not apply to pointer events for backwards compatibility\n     * - preventDefault on pointer events stops mouse events from firing\n     * - For every pointer event, there will always be either a mouse or touch event alongside it\n     * - Setting this to false allows default browser actions (text selection, dragging images, etc.)\n     * @example\n     * ```ts\n     * // Allow default browser actions\n     * app.renderer.events.autoPreventDefault = false;\n     *\n     * // Block default actions (default)\n     * app.renderer.events.autoPreventDefault = true;\n     *\n     * // Example with text selection\n     * const text = new Text('Selectable text');\n     * text.eventMode = 'static';\n     * app.renderer.events.autoPreventDefault = false; // Allow text selection\n     * ```\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of custom cursor styles that can be used across the application.\n     * Used to define how different cursor modes are handled when interacting with display objects.\n     * @example\n     * ```ts\n     * // Access event system through renderer\n     * const eventSystem = app.renderer.events;\n     *\n     * // Set string-based cursor styles\n     * eventSystem.cursorStyles.default = 'pointer';\n     * eventSystem.cursorStyles.hover = 'grab';\n     * eventSystem.cursorStyles.drag = 'grabbing';\n     *\n     * // Use CSS object for complex styling\n     * eventSystem.cursorStyles.custom = {\n     *     cursor: 'url(\"custom.png\") 2 2, auto',\n     *     userSelect: 'none'\n     * };\n     *\n     * // Use a url for custom cursors\n     * const defaultIcon = 'url(\\'https://pixijs.com/assets/bunny.png\\'),auto';\n     * eventSystem.cursorStyles.icon = defaultIcon;\n     *\n     * // Use callback function for dynamic cursors\n     * eventSystem.cursorStyles.dynamic = (mode) => {\n     *     // Update cursor based on mode\n     *     document.body.style.cursor = mode === 'hover'\n     *         ? 'pointer'\n     *         : 'default';\n     * };\n     *\n     * // Apply cursor style to a sprite\n     * sprite.cursor = 'hover'; // Will use the hover style defined above\n     * sprite.cursor = 'icon'; // Will apply the icon cursor\n     * sprite.cursor = 'custom'; // Will apply the custom CSS styles\n     * sprite.cursor = 'drag'; // Will apply the grabbing cursor\n     * sprite.cursor = 'default'; // Will apply the default pointer cursor\n     * sprite.cursor = 'dynamic'; // Will call the dynamic function\n     * ```\n     * @remarks\n     * - Strings are treated as CSS cursor values\n     * - Objects are applied as CSS styles to the DOM element\n     * - Functions are called directly for custom cursor handling\n     * - Default styles for 'default' and 'pointer' are provided\n     * @default\n     * ```ts\n     * {\n     *     default: 'inherit',\n     *     pointer: 'pointer' // Default cursor styles\n     * }\n     * ```\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    public domElement: HTMLElement = null;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * @since 7.2.0\n     * @example\n     * const app = new Application()\n     * app.renderer.events.features.globalMove = false\n     *\n     * // to override all features use Object.assign\n     * Object.assign(app.renderer.events.features, {\n     *  move: false,\n     *  globalMove: false,\n     *  click: false,\n     *  wheel: false,\n     * })\n     */\n    public readonly features: EventSystemFeatures;\n\n    private _currentCursor: string;\n    private readonly _rootPointerEvent: FederatedPointerEvent;\n    private readonly _rootWheelEvent: FederatedWheelEvent;\n    private _eventsAdded: boolean;\n\n    /**\n     * @param {Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n        EventsTicker.init(this);\n\n        this.autoPreventDefault = true;\n        this._eventsAdded = false;\n\n        this._rootPointerEvent = new FederatedPointerEvent(null);\n        this._rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        this.features = new Proxy({ ...EventSystem.defaultEventFeatures }, {\n            set: (target, key, value) =>\n            {\n                if (key === 'globalMove')\n                {\n                    this.rootBoundary.enableGlobalMoveEvents = value;\n                }\n                target[key as keyof EventSystemFeatures] = value;\n\n                return true;\n            }\n        });\n\n        this._onPointerDown = this._onPointerDown.bind(this);\n        this._onPointerMove = this._onPointerMove.bind(this);\n        this._onPointerUp = this._onPointerUp.bind(this);\n        this._onPointerOverOut = this._onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options: EventSystemOptions): void\n    {\n        const { canvas, resolution } = this.renderer;\n\n        this.setTargetElement(canvas as HTMLCanvasElement);\n        this.resolution = resolution;\n        EventSystem._defaultEventMode = options.eventMode ?? 'passive';\n        Object.assign(this.features, options.eventFeatures ?? {});\n        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n    }\n\n    /**\n     * Handle changing resolution.\n     * @ignore\n     */\n    public resolutionChange(resolution: number): void\n    {\n        this.resolution = resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    public destroy(): void\n    {\n        this.setTargetElement(null);\n        this.renderer = null;\n        this._currentCursor = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * The cursor can be a CSS cursor string, a custom callback function, or a key from the cursorStyles dictionary.\n     * @param mode - Cursor mode to set. Can be:\n     * - A CSS cursor string (e.g., 'pointer', 'grab')\n     * - A key from the cursorStyles dictionary\n     * - null/undefined to reset to default\n     * @example\n     * ```ts\n     * // Using predefined cursor styles\n     * app.renderer.events.setCursor('pointer');    // Set standard pointer cursor\n     * app.renderer.events.setCursor('grab');       // Set grab cursor\n     * app.renderer.events.setCursor(null);         // Reset to default\n     *\n     * // Using custom cursor styles\n     * app.renderer.events.cursorStyles.custom = 'url(\"cursor.png\"), auto';\n     * app.renderer.events.setCursor('custom');     // Apply custom cursor\n     *\n     * // Using callback-based cursor\n     * app.renderer.events.cursorStyles.dynamic = (mode) => {\n     *     document.body.style.cursor = mode === 'hover' ? 'pointer' : 'default';\n     * };\n     * app.renderer.events.setCursor('dynamic');    // Trigger cursor callback\n     * ```\n     * @remarks\n     * - Has no effect on OffscreenCanvas except for callback-based cursors\n     * - Caches current cursor to avoid unnecessary DOM updates\n     * - Supports CSS cursor values, style objects, and callback functions\n     * @see {@link EventSystem.cursorStyles} For defining custom cursor styles\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Reference\n     */\n    public setCursor(mode: string): void\n    {\n        mode ||= 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this._currentCursor === mode)\n        {\n            return;\n        }\n        this._currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * The global pointer event instance containing the most recent pointer state.\n     * This is useful for accessing pointer information without listening to events.\n     * @example\n     * ```ts\n     * // Access current pointer position at any time\n     * const eventSystem = app.renderer.events;\n     * const pointer = eventSystem.pointer;\n     *\n     * // Get global coordinates\n     * console.log('Position:', pointer.global.x, pointer.global.y);\n     *\n     * // Check button state\n     * console.log('Buttons pressed:', pointer.buttons);\n     *\n     * // Get pointer type and pressure\n     * console.log('Type:', pointer.pointerType);\n     * console.log('Pressure:', pointer.pressure);\n     * ```\n     * @readonly\n     * @since 7.2.0\n     * @see {@link FederatedPointerEvent} For all available pointer properties\n     */\n    public get pointer(): Readonly<FederatedPointerEvent>\n    {\n        return this._rootPointerEvent;\n    }\n\n    /**\n     * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const events = this._normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private _onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.move) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        EventsTicker.pointerMoved();\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        if (!this.features.wheel) return;\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n     * This method manages the DOM event bindings for the event system, allowing you to\n     * change or remove the target element that receives input events.\n     * > [!IMPORTANT] This will default to the canvas element of the renderer, so you\n     * > should not need to call this unless you are using a custom element.\n     * @param element - The new DOM element to bind events to, or null to remove all event bindings\n     * @example\n     * ```ts\n     * // Set a new canvas element as the target\n     * const canvas = document.createElement('canvas');\n     * app.renderer.events.setTargetElement(canvas);\n     *\n     * // Remove all event bindings\n     * app.renderer.events.setTargetElement(null);\n     *\n     * // Switch to a different canvas\n     * const newCanvas = document.querySelector('#game-canvas');\n     * app.renderer.events.setTargetElement(newCanvas);\n     * ```\n     * @remarks\n     * - Automatically removes event listeners from previous element\n     * - Required for the event system to function\n     * - Safe to call multiple times\n     * @see {@link EventSystem#domElement} The current DOM element\n     * @see {@link EventsTicker} For the ticker system that tracks pointer movement\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this._removeEvents();\n        this.domElement = element;\n        EventsTicker.domElement = element;\n        this._addEvents();\n    }\n\n    /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n    private _addEvents(): void\n    {\n        if (this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.addTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = 'none';\n                style.msTouchAction = 'none';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = 'none';\n            }\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this._onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.addEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.addEventListener('touchend', this._onPointerUp, true);\n                this.domElement.addEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this._eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n    private _removeEvents(): void\n    {\n        if (!this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.removeTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        // offscreen canvas does not have style, so check first\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = '';\n                style.msTouchAction = '';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = '';\n            }\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this._onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.removeEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.removeEventListener('touchend', this._onPointerUp, true);\n                this.domElement.removeEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this._eventsAdded = false;\n    }\n\n    /**\n     * Maps coordinates from DOM/screen space into PixiJS normalized coordinates.\n     * This takes into account the current scale, position, and resolution of the DOM element.\n     * @param point - The point to store the mapped coordinates in\n     * @param x - The x coordinate in DOM/client space\n     * @param y - The y coordinate in DOM/client space\n     * @example\n     * ```ts\n     * // Map mouse coordinates to PixiJS space\n     * const point = new Point();\n     * app.renderer.events.mapPositionToPoint(\n     *     point,\n     *     event.clientX,\n     *     event.clientY\n     * );\n     * console.log('Mapped position:', point.x, point.y);\n     *\n     * // Using with pointer events\n     * sprite.on('pointermove', (event) => {\n     *     // event.global already contains mapped coordinates\n     *     console.log('Global:', event.global.x, event.global.y);\n     *\n     *     // Map to local coordinates\n     *     const local = event.getLocalPosition(sprite);\n     *     console.log('Local:', local.x, local.y);\n     * });\n     * ```\n     * @remarks\n     * - Accounts for element scaling and positioning\n     * - Adjusts for device pixel ratio/resolution\n     */\n    public mapPositionToPoint(point: PointData, x: number, y: number): void\n    {\n        const rect = this.domElement.isConnected\n            ? this.domElement.getBoundingClientRect()\n            : {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private _normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this._rootWheelEvent;\n\n        this._transferMouseData(event, nativeEvent);\n\n        // When WheelEvent is triggered by scrolling with mouse wheel, reading WheelEvent.deltaMode\n        // before deltaX/deltaY/deltaZ on Firefox will result in WheelEvent.DOM_DELTA_LINE (1),\n        // while reading WheelEvent.deltaMode after deltaX/deltaY/deltaZ on Firefox or reading\n        // in any order on other browsers will result in WheelEvent.DOM_DELTA_PIXEL (0).\n        // Therefore, we need to read WheelEvent.deltaMode after deltaX/deltaY/deltaZ in order to\n        // make its behavior more consistent across browsers.\n        // @see https://github.com/pixijs/pixijs/issues/8970\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n        event.deltaMode = nativeEvent.deltaMode;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private _bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this._transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the `nativeEvent` to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private _transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n","import { EventSystem } from './EventSystem';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { Container } from '../scene/container/Container';\nimport type { AllFederatedEventMap } from './FederatedEventMap';\nimport type { FederatedPointerEvent } from './FederatedPointerEvent';\nimport type { FederatedWheelEvent } from './FederatedWheelEvent';\n\n/**\n * The type of cursor to use when the mouse pointer is hovering over an interactive element.\n * Accepts any valid CSS cursor value.\n * @example\n * ```ts\n * // Basic cursor types\n * sprite.cursor = 'pointer';    // Hand cursor for clickable elements\n * sprite.cursor = 'grab';       // Grab cursor for draggable elements\n * sprite.cursor = 'crosshair';  // Precise cursor for selection\n *\n * // Direction cursors\n * sprite.cursor = 'n-resize';   // North resize\n * sprite.cursor = 'ew-resize';  // East-west resize\n * sprite.cursor = 'nesw-resize';// Northeast-southwest resize\n *\n * // Custom cursor with fallback\n * sprite.cursor = 'url(\"custom.png\"), auto';\n * ```\n *\n * Common cursor values:\n * - Basic: `auto`, `default`, `none`, `pointer`, `wait`\n * - Text: `text`, `vertical-text`\n * - Links: `alias`, `copy`, `move`\n * - Selection: `cell`, `crosshair`\n * - Drag: `grab`, `grabbing`\n * - Disabled: `not-allowed`, `no-drop`\n * - Resize: `n-resize`, `e-resize`, `s-resize`, `w-resize`\n * - Bidirectional: `ns-resize`, `ew-resize`, `nesw-resize`, `nwse-resize`\n * - Other: `help`, `progress`\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Documentation\n * @category events\n * @standard\n */\nexport type Cursor = 'auto'\n| 'default'\n| 'none'\n| 'context-menu'\n| 'help'\n| 'pointer'\n| 'progress'\n| 'wait'\n| 'cell'\n| 'crosshair'\n| 'text'\n| 'vertical-text'\n| 'alias'\n| 'copy'\n| 'move'\n| 'no-drop'\n| 'not-allowed'\n| 'e-resize'\n| 'n-resize'\n| 'ne-resize'\n| 'nw-resize'\n| 's-resize'\n| 'se-resize'\n| 'sw-resize'\n| 'w-resize'\n| 'ns-resize'\n| 'ew-resize'\n| 'nesw-resize'\n| 'col-resize'\n| 'nwse-resize'\n| 'row-resize'\n| 'all-scroll'\n| 'zoom-in'\n| 'zoom-out'\n| 'grab'\n| 'grabbing';\n\n/**\n * Interface defining a hit area for pointer interaction. The hit area specifies\n * the region in which pointer events should be captured by a display object.\n * @example\n * ```ts\n * // Create a rectangular hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n *\n * // Create a circular hit area\n * sprite.hitArea = new Circle(50, 50, 50);\n *\n * // Custom hit area implementation\n * sprite.hitArea = {\n *     contains(x: number, y: number) {\n *         // Custom hit testing logic\n *         return x >= 0 && x <= 100 && y >= 0 && y <= 100;\n *     }\n * };\n * ```\n * @remarks\n * - Hit areas override the default bounds-based hit testing\n * - Can improve performance by simplifying hit tests\n * - Useful for irregular shapes or precise interaction areas\n * - Common implementations include Rectangle, Circle, Polygon\n * @see {@link Container.eventMode} For enabling interactivity\n * @see {@link Container.interactive} For backwards compatibility\n * @category events\n * @standard\n */\nexport interface IHitArea\n{\n    /**\n     * Checks if the given coordinates are inside this hit area.\n     * @param {number} x - The x coordinate to check\n     * @param {number} y - The y coordinate to check\n     * @returns True if the coordinates are inside the hit area\n     */\n    contains(x: number, y: number): boolean;\n}\n\n/**\n * Function type for handlers, e.g., onclick\n * @category events\n * @advanced\n */\nexport type FederatedEventHandler<T = FederatedPointerEvent> = (event: T) => void;\n\n/**\n * The type of interaction behavior for a Container. This is set via the {@link Container#eventMode} property.\n * @example\n * ```ts\n * // Basic event mode setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';    // Enable standard interaction\n * sprite.on('pointerdown', () => { console.log('clicked!'); });\n *\n * // Different event modes\n * sprite.eventMode = 'none';      // Disable all interaction\n * sprite.eventMode = 'passive';   // Only allow interaction on children\n * sprite.eventMode = 'auto';      // Like DOM pointer-events: auto\n * sprite.eventMode = 'dynamic';   // For moving/animated objects\n * ```\n *\n * Available modes:\n * - `'none'`: Ignores all interaction events, even on its children\n * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive children.\n * Interactive children will still emit events.\n * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7\n * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from\n * a ticker to allow for interaction when the mouse isn't moving\n *\n * Performance tips:\n * - Use `'none'` for pure visual elements\n * - Use `'passive'` for containers with some interactive children\n * - Use `'static'` for standard buttons/controls\n * - Use `'dynamic'` only for moving/animated interactive elements\n * @since 7.2.0\n * @category events\n * @standard\n */\nexport type EventMode = 'none' | 'passive' | 'auto' | 'static' | 'dynamic';\n\n/**\n * The properties available for any interactive object. This interface defines the core interaction\n * properties and event handlers that can be set on any Container in PixiJS.\n * @example\n * ```ts\n * // Basic interactive setup\n * const sprite = new Sprite(texture);\n * sprite.eventMode = 'static';\n * sprite.cursor = 'pointer';\n *\n * // Using event handlers\n * sprite.on('click', (event) => console.log('Sprite clicked!', event));\n * sprite.on('pointerdown', (event) => console.log('Pointer down!', event));\n *\n * // Using property-based event handlers\n * sprite.onclick = (event) => console.log('Clicked!');\n * sprite.onpointerenter = () => sprite.alpha = 0.7;\n * sprite.onpointerleave = () => sprite.alpha = 1.0;\n *\n * // Custom hit area\n * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n * ```\n *\n * Core Properties:\n * - `eventMode`: Controls how the object handles interaction events\n * - `cursor`: Sets the mouse cursor when hovering\n * - `hitArea`: Defines custom hit testing area\n * - `interactive`: Alias for `eventMode` to enable interaction with \"static\" or \"passive\" modes\n * - `interactiveChildren`: Controls hit testing on children\n *\n * Event Handlers:\n * - Mouse: click, mousedown, mouseup, mousemove, mouseenter, mouseleave\n * - Touch: touchstart, touchend, touchmove, tap\n * - Pointer: pointerdown, pointerup, pointermove, pointerover\n * - Global: globalpointermove, globalmousemove, globaltouchmove\n * > [!IMPORTANT] Global events are fired when the pointer moves even if it is outside the bounds of the Container.\n * @see {@link EventMode} For interaction mode details\n * @see {@link Cursor} For cursor style options\n * @see {@link IHitArea} For hit area implementation\n * @category events\n * @standard\n */\nexport interface FederatedOptions\n{\n    /**\n     * The cursor style to display when the mouse pointer is hovering over the object.\n     * Accepts any valid CSS cursor value or custom cursor URL.\n     * @example\n     * ```ts\n     * // Common cursor types\n     * sprite.cursor = 'pointer';     // Hand cursor for clickable elements\n     * sprite.cursor = 'grab';        // Grab cursor for draggable elements\n     * sprite.cursor = 'crosshair';   // Precise cursor for selection\n     * sprite.cursor = 'not-allowed'; // Indicate disabled state\n     *\n     * // Direction cursors\n     * sprite.cursor = 'n-resize';    // North resize\n     * sprite.cursor = 'ew-resize';   // East-west resize\n     * sprite.cursor = 'nesw-resize'; // Northeast-southwest resize\n     *\n     * // Custom cursor with fallback\n     * sprite.cursor = 'url(\"custom.png\"), auto';\n     * sprite.cursor = 'url(\"cursor.cur\") 2 2, pointer'; // With hotspot offset\n     * ```\n     * @type {Cursor | string}\n     * @default undefined\n     * @see {@link EventSystem.cursorStyles} For setting global cursor styles\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/cursor} MDN Cursor Documentation\n     */\n    cursor?: Cursor | (string & {});\n    /**\n     * Enable interaction events for the Container. Touch, pointer and mouse events are supported.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     *\n     * // Enable standard interaction (like buttons)\n     * sprite.eventMode = 'static';\n     * sprite.on('pointerdown', () => console.log('clicked!'));\n     *\n     * // Enable for moving objects\n     * sprite.eventMode = 'dynamic';\n     * sprite.on('pointermove', () => updatePosition());\n     *\n     * // Disable all interaction\n     * sprite.eventMode = 'none';\n     *\n     * // Only allow child interactions\n     * sprite.eventMode = 'passive';\n     * ```\n     *\n     * Available modes:\n     *\n     * - `'none'`: Ignores all interaction events, even on its children. Best for pure visuals.\n     * - `'passive'`: **(default)** Does not emit events and ignores hit testing on itself and non-interactive\n     * children. Interactive children will still emit events.\n     * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7.\n     * - `'static'`: Emit events and is hit tested. Same as `interactive = true` in v7. Best for buttons/UI.\n     * - `'dynamic'`: Like static but also receives synthetic events when pointer is idle. Best for moving objects.\n     *\n     * Performance tips:\n     * - Use `'none'` for pure visual elements\n     * - Use `'passive'` for containers with some interactive children\n     * - Use `'static'` for standard UI elements\n     * - Use `'dynamic'` only when needed for moving/animated elements\n     * @since 7.2.0\n     */\n    eventMode?: EventMode;\n    /**\n     * Whether this object should fire UI events. This is an alias for `eventMode` set to `'static'` or `'passive'`.\n     * Setting this to true will enable interaction events like `pointerdown`, `click`, etc.\n     * Setting it to false will disable all interaction events on this object.\n     * @see {@link Container.eventMode}\n     * @example\n     * ```ts\n     * // Enable interaction events\n     * sprite.interactive = true;  // Sets eventMode = 'static'\n     * sprite.interactive = false; // Sets eventMode = 'passive'\n     * ```\n     */\n    interactive?: boolean\n    /**\n     * Controls whether children of this container can receive pointer events.\n     *\n     * Setting this to false allows PixiJS to skip hit testing on all children,\n     * improving performance for containers with many non-interactive children.\n     * @default true\n     * @example\n     * ```ts\n     * // Container with many visual-only children\n     * const container = new Container();\n     * container.interactiveChildren = false; // Skip hit testing children\n     *\n     * // Menu with interactive buttons\n     * const menu = new Container();\n     * menu.interactiveChildren = true; // Test all children\n     * menu.addChild(button1, button2, button3);\n     *\n     * // Performance optimization\n     * background.interactiveChildren = false;\n     * foreground.interactiveChildren = true;\n     * ```\n     */\n    interactiveChildren?: boolean;\n    /**\n     * Defines a custom hit area for pointer interaction testing. When set, this shape will be used\n     * for hit testing instead of the container's standard bounds.\n     * @example\n     * ```ts\n     * import { Rectangle, Circle, Sprite } from 'pixi.js';\n     *\n     * // Rectangular hit area\n     * const button = new Sprite(texture);\n     * button.eventMode = 'static';\n     * button.hitArea = new Rectangle(0, 0, 100, 50);\n     *\n     * // Circular hit area\n     * const icon = new Sprite(texture);\n     * icon.eventMode = 'static';\n     * icon.hitArea = new Circle(32, 32, 32);\n     *\n     * // Custom hit area with polygon\n     * const custom = new Sprite(texture);\n     * custom.eventMode = 'static';\n     * custom.hitArea = new Polygon([0,0, 100,0, 100,100, 0,100]);\n     *\n     * // Custom hit testing logic\n     * sprite.hitArea = {\n     *     contains(x: number, y: number) {\n     *         // Custom collision detection\n     *         return x >= 0 && x <= width && y >= 0 && y <= height;\n     *     }\n     * };\n     * ```\n     * @remarks\n     * - Takes precedence over the container's bounds for hit testing\n     * - Can improve performance by simplifying collision checks\n     * - Useful for irregular shapes or precise click areas\n     */\n    hitArea?: IHitArea | null;\n\n    /**\n     * Property-based event handler for the `click` event.\n     * Fired when a pointer device (mouse, touch, etc.) completes a click action.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('click', (event) => {\n     *    console.log('Sprite clicked at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onclick = (event) => {\n     *     console.log('Clicked at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onclick?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mousedown` event.\n     * Fired when a mouse button is pressed while the pointer is over the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mousedown', (event) => {\n     *    sprite.alpha = 0.5; // Visual feedback\n     *    console.log('Mouse button:', event.button);\n     * });\n     * // Using property-based handler\n     * sprite.onmousedown = (event) => {\n     *     sprite.alpha = 0.5; // Visual feedback\n     *     console.log('Mouse button:', event.button);\n     * };\n     * ```\n     * @default null\n     */\n    onmousedown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseenter` event.\n     * Fired when the mouse pointer enters the bounds of the object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseenter', (event) => {\n     *     sprite.scale.set(1.1);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseenter = (event) => {\n     *     sprite.scale.set(1.1);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseenter?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseleave` event.\n     * Fired when the pointer leaves the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseleave', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseleave = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseleave?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mousemove` event.\n     * Fired when the pointer moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mousemove', (event) => {\n     *    // Get coordinates relative to the sprite\n     *   console.log('Local:', event.getLocalPosition(sprite));\n     * });\n     * // Using property-based handler\n     * sprite.onmousemove = (event) => {\n     *     // Get coordinates relative to the sprite\n     *     console.log('Local:', event.getLocalPosition(sprite));\n     * };\n     * ```\n     * @default null\n     */\n    onmousemove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globalmousemove` event.\n     *\n     * Fired when the mouse moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globalmousemove', (event) => {\n     *     // Move sprite to mouse position\n     *     sprite.position.copyFrom(event.global);\n     * });\n     * // Using property-based handler\n     * sprite.onglobalmousemove = (event) => {\n     *     // Move sprite to mouse position\n     *     sprite.position.copyFrom(event.global);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the mouse is outside the object's bounds\n     * - Useful for drag operations or global mouse tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n     */\n    onglobalmousemove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseout` event.\n     * Fired when the pointer moves out of the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseout', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseout = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseout?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseover` event.\n     * Fired when the pointer moves onto the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseover', (event) => {\n     *      sprite.scale.set(1.1);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseover = (event) => {\n     *     sprite.scale.set(1.1);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseover?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseup` event.\n     * Fired when a mouse button is released over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseup = (event) => {\n     *      sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `mouseupoutside` event.\n     * Fired when a mouse button is released outside the display object that initially\n     * registered a mousedown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('mouseupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onmouseupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onmouseupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointercancel` event.\n     * Fired when a pointer device interaction is canceled or lost.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointercancel', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointercancel = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointercancel?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerdown` event.\n     * Fired when a pointer device button (mouse, touch, pen, etc.) is pressed.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerdown', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerdown = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerdown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerenter` event.\n     * Fired when a pointer device enters the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerenter', (event) => {\n     *     sprite.scale.set(1.2);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerenter = (event) => {\n     *     sprite.scale.set(1.2);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerenter?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerleave` event.\n     * Fired when a pointer device leaves the bounds of the display object. Does not bubble.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * // Using emitter handler\n     * sprite.on('pointerleave', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerleave = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerleave?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointermove` event.\n     * Fired when a pointer device moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointermove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointermove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointermove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globalpointermove` event.\n     *\n     * Fired when the pointer moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globalpointermove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onglobalpointermove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the mouse is outside the object's bounds\n     * - Useful for drag operations or global mouse tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globaltouchmove`\n     */\n    onglobalpointermove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerout` event.\n     * Fired when the pointer moves out of the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerout', (event) => {\n     *    sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerout = (event) => {\n     *    sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerout?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerover` event.\n     * Fired when the pointer moves over the bounds of the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerover', (event) => {\n     *     sprite.scale.set(1.2);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerover = (event) => {\n     *     sprite.scale.set(1.2);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerover?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointertap` event.\n     * Fired when a pointer device completes a tap action (e.g., touch or mouse click).\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointertap', (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onpointertap = (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onpointertap?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerup` event.\n     * Fired when a pointer device button (mouse, touch, pen, etc.) is released.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerup = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `pointerupoutside` event.\n     * Fired when a pointer device button is released outside the bounds of the display object\n     * that initially registered a pointerdown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('pointerupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onpointerupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onpointerupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightclick` event.\n     * Fired when a right-click (context menu) action is performed on the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightclick', (event) => {\n     *     console.log('Right-clicked at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onrightclick = (event) => {\n     *     console.log('Right-clicked at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    onrightclick?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightdown` event.\n     * Fired when a right mouse button is pressed down over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightdown', (event) => {\n     *     sprite.scale.set(0.9);\n     * });\n     * // Using property-based handler\n     * sprite.onrightdown = (event) => {\n     *     sprite.scale.set(0.9);\n     * };\n     * ```\n     * @default null\n     */\n    onrightdown?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightup` event.\n     * Fired when a right mouse button is released over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightup', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onrightup = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onrightup?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `rightupoutside` event.\n     * Fired when a right mouse button is released outside the bounds of the display object\n     * that initially registered a rightdown.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('rightupoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.onrightupoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    onrightupoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `tap` event.\n     * Fired when a tap action (touch) is completed on the object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('tap', (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontap = (event) => {\n     *     console.log('Sprite tapped at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontap?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchcancel` event.\n     * Fired when a touch interaction is canceled, such as when the touch is interrupted.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchcancel', (event) => {\n     *     console.log('Touch canceled at:', event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchcancel = (event) => {\n     *     console.log('Touch canceled at:', event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchcancel?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchend` event.\n     * Fired when a touch interaction ends, such as when the finger is lifted from the screen.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchend', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchend = (event) => {\n     *    sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchend?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchendoutside` event.\n     * Fired when a touch interaction ends outside the bounds of the display object\n     * that initially registered a touchstart.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchendoutside', (event) => {\n     *     sprite.scale.set(1.0);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchendoutside = (event) => {\n     *     sprite.scale.set(1.0);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchendoutside?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchmove` event.\n     * Fired when a touch interaction moves while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchmove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchmove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchmove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `globaltouchmove` event.\n     *\n     * Fired when a touch interaction moves anywhere, regardless of whether the pointer is over this object.\n     * The object must have `eventMode` set to 'static' or 'dynamic' to receive this event.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('globaltouchmove', (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * });\n     * // Using property-based handler\n     * sprite.onglobaltouchmove = (event) => {\n     *     sprite.position.set(event.global.x, event.global.y);\n     * };\n     * ```\n     * @default null\n     * @remarks\n     * - Fires even when the touch is outside the object's bounds\n     * - Useful for drag operations or global touch tracking\n     * - Must have `eventMode` set appropriately to receive events\n     * - Part of the global move events family along with `globalpointermove` and `globalmousemove`\n     */\n    onglobaltouchmove?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `touchstart` event.\n     * Fired when a touch interaction starts, such as when a finger touches the screen.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('touchstart', (event) => {\n     *     sprite.scale.set(0.9);\n     * });\n     * // Using property-based handler\n     * sprite.ontouchstart = (event) => {\n     *     sprite.scale.set(0.9);\n     * };\n     * ```\n     * @default null\n     */\n    ontouchstart?: FederatedEventHandler | null;\n\n    /**\n     * Property-based event handler for the `wheel` event.\n     * Fired when the mouse wheel is scrolled while over the display object.\n     * @example\n     * ```ts\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     *\n     * // Using emitter handler\n     * sprite.on('wheel', (event) => {\n     *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n     *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n     * });\n     * // Using property-based handler\n     * sprite.onwheel = (event) => {\n     *     sprite.scale.x += event.deltaY * 0.01; // Zoom in/out\n     *     sprite.scale.y += event.deltaY * 0.01; // Zoom in/out\n     * };\n     * ```\n     * @default null\n     */\n    onwheel?: FederatedEventHandler<FederatedWheelEvent> | null;\n}\n\n/**\n * The options for the `addEventListener` method.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}\n * @category events\n * @advanced\n */\nexport type AddListenerOptions = boolean | AddEventListenerOptions;\n/**\n * The options for the `removeEventListener` method.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener}\n * @category events\n * @advanced\n */\nexport type RemoveListenerOptions = boolean | EventListenerOptions;\n\n/**\n * Additional properties for a Container that is used for interaction events.\n * @category events\n * @advanced\n */\nexport interface IFederatedContainer extends FederatedOptions\n{\n    /** The parent of this event target. */\n    readonly parent?: Container;\n\n    /** The children of this event target. */\n    readonly children?: ReadonlyArray<Container>;\n\n    /** @private */\n    _internalEventMode: EventMode;\n\n    /**\n     * Determines if the container is interactive or not\n     * @returns {boolean} Whether the container is interactive or not\n     * @since 7.2.0\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'dynamic';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'none';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'passive';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'auto';\n     * sprite.isInteractive(); // false\n     */\n    isInteractive: () => boolean;\n    /**\n     * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n     * seeks to be compatible with the DOM's `addEventListener` with support for options.\n     * @param {any} type - The type of event to listen to.\n     * @param {any} listener - The listener callback or object.\n     * @param {any} options - Listener options, used for capture phase.\n     * @example\n     * // Tell the user whether they did a single, double, triple, or nth click.\n     * button.addEventListener('click', {\n     *     handleEvent(e): {\n     *         let prefix;\n     *\n     *         switch (e.detail) {\n     *             case 1: prefix = 'single'; break;\n     *             case 2: prefix = 'double'; break;\n     *             case 3: prefix = 'triple'; break;\n     *             default: prefix = e.detail + 'th'; break;\n     *         }\n     *\n     *         console.log('That was a ' + prefix + 'click');\n     *     }\n     * });\n     *\n     * // But skip the first click!\n     * button.parent.addEventListener('click', function blockClickOnce(e) {\n     *     e.stopImmediatePropagation();\n     *     button.parent.removeEventListener('click', blockClickOnce, true);\n     * }, {\n     *     capture: true,\n     * });\n     */\n    addEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: AddListenerOptions\n    ): void;\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    ): void;\n    /**\n     * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n     * seeks to be compatible with the DOM's `removeEventListener` with support for options.\n     * @param {K} type - The type of event the listener is bound to.\n     * @param {any} listener - The listener callback or object.\n     * @param {RemoveListenerOptions} options - The original listener options.\n     * This is required to deregister a capture phase listener.\n     */\n    removeEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: RemoveListenerOptions\n    ): void;\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    ): void;\n    /**\n     * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.\n     *\n     * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n     * @param {FederatedEvent} e - The event to dispatch.\n     * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.\n     * @example\n     * // Reuse a click event!\n     * button.dispatchEvent(clickEvent);\n     */\n    dispatchEvent(e: FederatedEvent): boolean;\n}\n\n/** @internal */\nexport const FederatedContainer: IFederatedContainer = {\n    onclick: null,\n    onmousedown: null,\n    onmouseenter: null,\n    onmouseleave: null,\n    onmousemove: null,\n    onglobalmousemove: null,\n    onmouseout: null,\n    onmouseover:  null,\n    onmouseup:  null,\n    onmouseupoutside: null,\n    onpointercancel: null,\n    onpointerdown:  null,\n    onpointerenter: null,\n    onpointerleave:  null,\n    onpointermove:  null,\n    onglobalpointermove:  null,\n    onpointerout:  null,\n    onpointerover:  null,\n    onpointertap:  null,\n    onpointerup:  null,\n    onpointerupoutside:  null,\n    onrightclick:  null,\n    onrightdown:  null,\n    onrightup:  null,\n    onrightupoutside:  null,\n    ontap:  null,\n    ontouchcancel:  null,\n    ontouchend:  null,\n    ontouchendoutside:  null,\n    ontouchmove:  null,\n    onglobaltouchmove:  null,\n    ontouchstart:  null,\n    onwheel:  null,\n    get interactive()\n    {\n        return this.eventMode === 'dynamic' || this.eventMode === 'static';\n    },\n    set interactive(value: boolean)\n    {\n        this.eventMode = value ? 'static' : 'passive';\n    },\n    _internalEventMode: undefined,\n    get eventMode()\n    {\n        return this._internalEventMode ?? EventSystem.defaultEventMode;\n    },\n    set eventMode(value)\n    {\n        this._internalEventMode = value;\n    },\n    isInteractive(): boolean\n    {\n        return this.eventMode === 'static' || this.eventMode === 'dynamic';\n    },\n    interactiveChildren: true,\n    hitArea: null,\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n        || (typeof options === 'object' && options.capture);\n        const signal = typeof options === 'object' ? options.signal : undefined;\n        const once = typeof options === 'object' ? (options.once === true) : false;\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        const listenerFn = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        const emitter = (this as unknown as EventEmitter);\n\n        if (signal)\n        {\n            signal.addEventListener('abort', () =>\n            {\n                emitter.off(type, listenerFn, context);\n            });\n        }\n\n        if (once)\n        {\n            emitter.once(type, listenerFn, context);\n        }\n        else\n        {\n            emitter.on(type, listenerFn, context);\n        }\n    },\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n            || (typeof options === 'object' && options.capture);\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        listener = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        (this as unknown as EventEmitter).off(type, listener, context);\n    },\n    dispatchEvent(e: Event): boolean\n    {\n        if (!(e instanceof FederatedEvent))\n        {\n            throw new Error('Container cannot propagate events outside of the Federated Events API');\n        }\n\n        e.defaultPrevented = false;\n        e.path = null;\n        e.target = this as Container;\n        e.manager.dispatchEvent(e);\n\n        return !e.defaultPrevented;\n    }\n};\n","import { extensions } from '../extensions/Extensions';\nimport { Container } from '../scene/container/Container';\nimport { EventSystem } from './EventSystem';\nimport { FederatedContainer } from './FederatedEventTarget';\n\nextensions.add(EventSystem);\nextensions.mixin(Container, FederatedContainer);\n","import { ExtensionType } from '../extensions/Extensions';\nimport { type DOMContainer } from './DOMContainer';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\n\n/**\n * The DOMPipe class is responsible for managing and rendering DOM elements within a PixiJS scene.\n * It maps dom elements to the canvas and ensures they are correctly positioned and visible.\n * @internal\n */\nexport class DOMPipe implements RenderPipe<DOMContainer>\n{\n    /**\n     * Static property defining the extension type and name for the DOMPipe.\n     * This is used to register the DOMPipe with different rendering pipelines.\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'dom',\n    } as const;\n\n    private _renderer: Renderer;\n\n    /** Array to keep track of attached DOM elements */\n    private readonly _attachedDomElements: DOMContainer[] = [];\n    /** The main DOM element that acts as a container for other DOM elements */\n    private readonly _domElement: HTMLDivElement;\n\n    /**\n     * Constructor for the DOMPipe class.\n     * @param renderer - The renderer instance that this DOMPipe will be associated with.\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        // Add this DOMPipe to the postrender runner of the renderer\n        // we want to dom elements are calculated after all things have been rendered\n        this._renderer.runners.postrender.add(this);\n\n        // Create a main DOM element to contain other DOM elements\n        this._domElement = document.createElement('div');\n        this._domElement.style.position = 'absolute';\n        this._domElement.style.top = '0';\n        this._domElement.style.left = '0';\n        this._domElement.style.pointerEvents = 'none';\n        this._domElement.style.zIndex = '1000';\n    }\n\n    /**\n     * Adds a renderable DOM container to the list of attached elements.\n     * @param domContainer - The DOM container to be added.\n     * @param _instructionSet - The instruction set (unused).\n     */\n    public addRenderable(domContainer: DOMContainer, _instructionSet: InstructionSet): void\n    {\n        if (!this._attachedDomElements.includes(domContainer))\n        {\n            this._attachedDomElements.push(domContainer);\n        }\n    }\n\n    /**\n     * Updates a renderable DOM container.\n     * @param _domContainer - The DOM container to be updated (unused).\n     */\n    public updateRenderable(_domContainer: DOMContainer): void\n    {\n        // Updates happen in postrender\n    }\n\n    /**\n     * Validates a renderable DOM container.\n     * @param _domContainer - The DOM container to be validated (unused).\n     * @returns Always returns true as validation is not required.\n     */\n    public validateRenderable(_domContainer: DOMContainer): boolean\n    {\n        return true;\n    }\n\n    /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */\n    public postrender(): void\n    {\n        const attachedDomElements = this._attachedDomElements;\n\n        if (attachedDomElements.length === 0)\n        {\n            this._domElement.remove();\n\n            return;\n        }\n\n        const canvas = this._renderer.view.canvas as HTMLCanvasElement;\n\n        if (this._domElement.parentNode !== canvas.parentNode)\n        {\n            canvas.parentNode?.appendChild(this._domElement);\n        }\n\n        const sx = (parseFloat(canvas.style.width) / canvas.width) * this._renderer.resolution;\n        const sy = (parseFloat(canvas.style.height) / canvas.height) * this._renderer.resolution;\n        // scale according to the canvas scale and translate\n\n        this._domElement.style.transform = `translate(${canvas.offsetLeft}px, ${canvas.offsetTop}px) scale(${sx}, ${sy})`;\n\n        for (let i = 0; i < attachedDomElements.length; i++)\n        {\n            const domContainer = attachedDomElements[i];\n            const element = domContainer.element;\n\n            if (!domContainer.parent || domContainer.globalDisplayStatus < 0b111)\n            {\n                element?.remove();\n                attachedDomElements.splice(i, 1);\n                i--;\n            }\n            else\n            {\n                if (!this._domElement.contains(element))\n                {\n                    element.style.position = 'absolute';\n                    element.style.pointerEvents = 'auto';\n                    this._domElement.appendChild(element);\n                }\n\n                const wt = domContainer.worldTransform;\n                const anchor = domContainer._anchor;\n                const ax = domContainer.width * anchor.x;\n                const ay = domContainer.height * anchor.y;\n\n                element.style.transformOrigin = `${ax}px ${ay}px`;\n                element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;\n                element.style.opacity = domContainer.groupAlpha.toString();\n            }\n        }\n    }\n\n    /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */\n    public destroy(): void\n    {\n        this._renderer.runners.postrender.remove(this);\n\n        for (let i = 0; i < this._attachedDomElements.length; i++)\n        {\n            const domContainer = this._attachedDomElements[i];\n\n            domContainer.element?.remove();\n        }\n\n        this._attachedDomElements.length = 0;\n        this._domElement.remove();\n        this._renderer = null;\n    }\n}\n","import { extensions } from '../extensions/Extensions';\nimport { DOMPipe } from './DOMPipe';\n\nexport * from './index';\n\nextensions.add(DOMPipe);\n"],"names":["FederatedEvent","constructor","manager","bubbles","cancelBubble","cancelable","composed","defaultPrevented","eventPhase","prototype","NONE","propagationStopped","propagationImmediatelyStopped","layer","Point","page","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","this","layerX","x","layerY","y","pageX","pageY","data","composedPath","path","length","target","propagationPath","initEvent","_type","_bubbles","_cancelable","Error","initUIEvent","_typeArg","_bubblesArg","_cancelableArg","_viewArg","_detailArg","preventDefault","nativeEvent","Event","stopImmediatePropagation","stopPropagation","appleIphone","appleIpod","appleTablet","appleUniversal","androidPhone","androidTablet","amazonPhone","amazonTablet","windowsPhone","windowsTablet","otherBlackBerry","otherBlackBerry10","otherOpera","otherChrome","otherFirefox","isAppleTabletOnIos13","navigator","platform","maxTouchPoints","MSStream","isMobile","param","nav","userAgent","tmp","split","match","regex","test","createMatch","result","apple","phone","ipod","tablet","universal","device","amazon","android","windows","other","blackberry","blackberry10","opera","firefox","chrome","any","isMobileJs","globalThis","_AccessibilitySystem","renderer","_mobileInfo","arguments","undefined","debug","_activateOnTab","_deactivateOnMouseMove","_isActive","_isMobileAccessibility","_div","_pool","_renderId","_children","_androidUpdateCount","_androidUpdateFrequency","_hookDiv","_createTouchHook","_renderer","isActive","isMobileAccessibility","hookDiv","document","createElement","style","width","height","position","top","left","zIndex","toString","backgroundColor","title","addEventListener","_activate","_destroyTouchHook","body","appendChild","removeChild","pointerEvents","_onKeyDown","bind","_onMouseMove","canvas","view","parentNode","_initAccessibilitySetup","observer","MutationObserver","disconnect","observe","childList","subtree","runners","postrender","add","lastObjectRendered","_updateAccessibleObjects","_deactivate","removeEventListener","remove","child","_accessibleDiv","_accessibleActive","forEach","div","container","visible","accessibleChildren","accessible","_addChild","children","i","init","options","mergedOptions","accessibilityOptions","defaultOptions","activateOnTab","deactivateOnMouseMove","enabledByDefault","now","performance","renderingToScreen","activeIds","Set","indexOf","has","push","removeItems","viewWidth","viewHeight","screen","hitArea","getBounds","rectangle","wt","worldTransform","sx","resolution","sy","tx","a","ty","d","_capHitArea","_updateDebugHTML","innerHTML","type","tabIndex","pop","accessibleType","cssText","accessibleText","innerText","borderStyle","toLowerCase","includes","setAttribute","_onClick","_onFocus","_onFocusOut","accessiblePointerEvents","accessibleTitle","accessibleHint","interactive","_dispatchEvent","e","boundary","events","rootBoundary","event","Object","assign","rootTarget","type2","dispatchEvent","getAttribute","keyCode","movementX","movementY","destroy","setAccessibilityEnabled","enabled","extension","ExtensionType","WebGLSystem","WebGPUSystem","name","AccessibilitySystem","extensions","mixin","Container","EventsTicker","interactionFrequency","_deltaTime","_didMove","_tickerAdded","_pauseUpdate","removeTickerListener","pauseUpdate","paused","addTickerListener","domElement","Ticker","system","_tickerUpdate","UPDATE_PRIORITY","INTERACTION","pointerMoved","_update","rootPointerEvent","supportsTouchEvents","pointerType","supportsPointerEvents","PointerEvent","clientX","clientY","pointerId","MouseEvent","ticker","deltaTime","FederatedMouseEvent","client","movement","offset","global","offsetX","offsetY","globalX","globalY","screenX","screenY","getLocalPosition","point","globalPos","applyInverse","getModifierState","key","initMouseEvent","_canBubbleArg","_screenXArg","_screenYArg","_clientXArg","_clientYArg","_ctrlKeyArg","_altKeyArg","_shiftKeyArg","_metaKeyArg","_buttonArg","_relatedTargetArg","FederatedPointerEvent","isPrimary","getCoalescedEvents","getPredictedEvents","FederatedWheelEvent","DOM_DELTA_PIXEL","DOM_DELTA_LINE","DOM_DELTA_PAGE","tempHitLocation","tempLocalMapping","EventBoundary","dispatch","EventEmitter","moveOnAll","enableGlobalMoveEvents","mappingState","trackingData","eventPool","Map","_allInteractiveElements","_hitElements","_isPointerMoveEvent","hitPruneFn","hitTestFn","mapPointerDown","mapPointerMove","mapPointerOut","mapPointerOver","mapPointerUp","mapPointerUpOutside","mapWheel","mappingTable","addEventMapping","fn","priority","sort","b","propagate","emit","mapEvent","mappers","j","warn","hitTest","invertedPath","eventMode","set","currentTarget","notifyTarget","all","targets","Array","isArray","parent","reverse","hitTestMoveRecursive","location","testFn","pruneFn","ignore","shouldReturn","_interactivePrune","interactiveChildren","nestedHit","_isInteractive","isInteractive","isInteractiveMode","isInteractiveTarget","hitTestRecursive","relativeLocation","int","renderable","measurable","contains","effects","effect","containsPoint","handlerKey","_notifyListeners","from","createPointerEvent","isRightButton","button","pressTargetsByButton","freeEvent","isMouse","outTarget","findMountedTarget","overTargets","outType","outEvent","leaveEvent","overType","overEvent","clonePointerEvent","overTargetAncestor","enterEvent","allMethods","allowGlobalPointerEvents","splice","cursor","pressTarget","clickTarget","clickEvent","clicksByButton","clickCount","timeStamp","clickHistory","detail","wheelEvent","createWheelEvent","allocateEvent","copyPointerData","copyMouseData","copyData","originalEvent","copyWheelData","slice","to","deltaMode","deltaX","deltaY","deltaZ","pressure","tangentialPressure","tiltX","tiltY","twist","altKey","buttons","copyFrom","ctrlKey","metaKey","shiftKey","isTrusted","srcElement","which","id","overTarget","get","listeners","_events","once","removeListener","call","context","TOUCH_TO_POINTER","touchstart","touchend","touchendoutside","touchmove","touchcancel","_EventSystem","autoPreventDefault","_eventsAdded","_rootPointerEvent","_rootWheelEvent","cursorStyles","default","pointer","features","Proxy","defaultEventFeatures","value","_onPointerDown","_onPointerMove","_onPointerUp","_onPointerOverOut","onWheel","defaultEventMode","_defaultEventMode","setTargetElement","eventFeatures","globalMove","resolutionChange","_currentCursor","setCursor","mode","applyStyles","OffscreenCanvas","hasOwnProperty","click","_normalizeToPointerData","isNormalized","nativeEvent2","federatedEvent","_bootstrapEvent","move","normalizedEvents","outside","wheel","normalizeWheelEvent","element","_removeEvents","_addEvents","msPointerEnabled","msContentZooming","msTouchAction","touchAction","passive","capture","mapPositionToPoint","rect","isConnected","getBoundingClientRect","resolutionMultiplier","TouchEvent","li","changedTouches","touch","touches","radiusX","radiusY","identifier","force","tempEvent","_transferMouseData","startsWith","replace","relatedTarget","CanvasSystem","EventSystem","FederatedContainer","onclick","onmousedown","onmouseenter","onmouseleave","onmousemove","onglobalmousemove","onmouseout","onmouseover","onmouseup","onmouseupoutside","onpointercancel","onpointerdown","onpointerenter","onpointerleave","onpointermove","onglobalpointermove","onpointerout","onpointerover","onpointertap","onpointerup","onpointerupoutside","onrightclick","onrightdown","onrightup","onrightupoutside","ontap","ontouchcancel","ontouchend","ontouchendoutside","ontouchmove","onglobaltouchmove","ontouchstart","onwheel","_internalEventMode","listener","signal","listenerFn","handleEvent","emitter","off","on","DOMPipe","_attachedDomElements","_domElement","addRenderable","domContainer","_instructionSet","updateRenderable","_domContainer","validateRenderable","attachedDomElements","parseFloat","transform","offsetLeft","offsetTop","globalDisplayStatus","anchor","_anchor","ax","ay","transformOrigin","c","opacity","groupAlpha","WebGLPipes","WebGPUPipes","CanvasPipes"],"sourceRoot":""}